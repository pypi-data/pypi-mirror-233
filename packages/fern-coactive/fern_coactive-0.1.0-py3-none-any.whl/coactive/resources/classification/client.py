# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import pydantic

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...errors.forbidden_error import ForbiddenError
from ...errors.unauthorized_error import UnauthorizedError
from ...errors.unprocessable_entity_error import UnprocessableEntityError
from ...types.classification_embedding_vector_request import ClassificationEmbeddingVectorRequest
from ...types.classification_response import ClassificationResponse
from ...types.custom_classification_response import CustomClassificationResponse
from ...types.error_response import ErrorResponse
from ...types.http_validation_error import HttpValidationError
from ...types.text_detection_response import TextDetectionResponse
from ...types.visual_safety_classification_response import VisualSafetyClassificationResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ClassificationClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def classify_assets(
        self,
        *,
        threshold: typing.Optional[float] = None,
        embedding_id: typing.Optional[str] = OMIT,
        concept_id: typing.Optional[str] = OMIT,
        embedding_vectors: typing.Optional[typing.List[ClassificationEmbeddingVectorRequest]] = OMIT,
        paths: typing.Optional[typing.List[str]] = OMIT,
    ) -> ClassificationResponse:
        """
        Upload assets to classify based on embedding id using either public path to assets, or embedding vectors

        Parameters:
            - threshold: typing.Optional[float]. Threshold above which classification is positive

            - embedding_id: typing.Optional[str]. The embedding id to get all concepts to use for classification

            - concept_id: typing.Optional[str]. A concept id to use to classify an image

            - embedding_vectors: typing.Optional[typing.List[ClassificationEmbeddingVectorRequest]]. The embedding vectors to classify

            - paths: typing.Optional[typing.List[str]]. The assets to classify
        """
        _request: typing.Dict[str, typing.Any] = {}
        if embedding_id is not OMIT:
            _request["embeddingId"] = embedding_id
        if concept_id is not OMIT:
            _request["conceptId"] = concept_id
        if embedding_vectors is not OMIT:
            _request["embeddingVectors"] = embedding_vectors
        if paths is not OMIT:
            _request["paths"] = paths
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v0/classify/assets"),
            params=remove_none_from_dict({"threshold": threshold}),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClassificationResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def classify_assets_file(
        self, *, embedding_id: str, threshold: typing.Optional[float] = None, files: typing.List[str]
    ) -> ClassificationResponse:
        """
        Upload assets to classify based on embedding id using one of image file, , csv of paths or a csv embedding vectors

        Parameters:
            - embedding_id: str. The unique identifier for the embedding

            - threshold: typing.Optional[float]. Threshold above which classification is positive

            - files: typing.List[str]. 1 of 3 types of files are accepted: 1: CSV file with a list of paths to assets to classify, 'path' is required header2: CSV file with embedding vectors, 'external_id' and 'embedding_vector' are required headers3: Image file (jpg, png or webp)
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v0/classify/assets/file"),
            params=remove_none_from_dict({"embedding_id": embedding_id, "threshold": threshold}),
            json=jsonable_encoder({"files": files}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClassificationResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def classify_assets_custom_model(
        self, model_name: str, *, embedding_id: str, threshold: typing.Optional[float] = None, files: typing.List[str]
    ) -> CustomClassificationResponse:
        """
        Upload list of assets to classify based on embedding id and a custom model

        Parameters:
            - model_name: str. The name of the model to use

            - embedding_id: str. The unique identifier for the embedding

            - threshold: typing.Optional[float]. Threshold above which classification is positive

            - files: typing.List[str]. List of assets to classify
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/v0/classify/assets/custom/{model_name}"
            ),
            params=remove_none_from_dict({"embedding_id": embedding_id, "threshold": threshold}),
            json=jsonable_encoder({"files": files}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CustomClassificationResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def classify_assets_for_visual_safety(
        self,
        *,
        threshold: typing.Optional[float] = None,
        embedding_vectors: typing.Optional[typing.List[ClassificationEmbeddingVectorRequest]] = OMIT,
        paths: typing.Optional[typing.List[str]] = OMIT,
    ) -> VisualSafetyClassificationResponse:
        """
        Classify a list of assets to determine whether they meet visual safety standards

        Parameters:
            - threshold: typing.Optional[float]. Threshold above which classification is positive

            - embedding_vectors: typing.Optional[typing.List[ClassificationEmbeddingVectorRequest]]. The embedding vectors to classify

            - paths: typing.Optional[typing.List[str]]. The assets to classify
        """
        _request: typing.Dict[str, typing.Any] = {}
        if embedding_vectors is not OMIT:
            _request["embeddingVectors"] = embedding_vectors
        if paths is not OMIT:
            _request["paths"] = paths
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v0/classify/assets/visual-safety"),
            params=remove_none_from_dict({"threshold": threshold}),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VisualSafetyClassificationResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def classify_assets_for_visual_safety_file(
        self, *, threshold: typing.Optional[float] = None, files: typing.List[str]
    ) -> VisualSafetyClassificationResponse:
        """
        Classify a list of assets to determine whether they meet visual safety standards (jpg, png or webp)

        Parameters:
            - threshold: typing.Optional[float]. Threshold above which classification is positive

            - files: typing.List[str]. List of assets to classify for visual safety
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "api/v0/classify/assets/visual-safety/file"
            ),
            params=remove_none_from_dict({"threshold": threshold}),
            json=jsonable_encoder({"files": files}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VisualSafetyClassificationResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def detect_text(
        self,
        *,
        threshold: typing.Optional[float] = None,
        embedding_vectors: typing.Optional[typing.List[ClassificationEmbeddingVectorRequest]] = OMIT,
        paths: typing.Optional[typing.List[str]] = OMIT,
    ) -> TextDetectionResponse:
        """
        Classify a list of assets to determine whether or not they contain text

        Parameters:
            - threshold: typing.Optional[float]. Threshold above which classification is positive

            - embedding_vectors: typing.Optional[typing.List[ClassificationEmbeddingVectorRequest]]. The embedding vectors to classify

            - paths: typing.Optional[typing.List[str]]. Public paths of assets to classify
        """
        _request: typing.Dict[str, typing.Any] = {}
        if embedding_vectors is not OMIT:
            _request["embeddingVectors"] = embedding_vectors
        if paths is not OMIT:
            _request["paths"] = paths
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v0/classify/assets/text-detect"),
            params=remove_none_from_dict({"threshold": threshold}),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TextDetectionResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def detect_text_file(
        self, *, threshold: typing.Optional[float] = None, files: typing.List[str]
    ) -> TextDetectionResponse:
        """
        Classify a list of assets to determine whether or not they contain text

        Parameters:
            - threshold: typing.Optional[float]. Threshold above which classification is positive

            - files: typing.List[str]. List of assets to classify for visual safety
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v0/classify/assets/text-detect/file"),
            params=remove_none_from_dict({"threshold": threshold}),
            json=jsonable_encoder({"files": files}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TextDetectionResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncClassificationClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def classify_assets(
        self,
        *,
        threshold: typing.Optional[float] = None,
        embedding_id: typing.Optional[str] = OMIT,
        concept_id: typing.Optional[str] = OMIT,
        embedding_vectors: typing.Optional[typing.List[ClassificationEmbeddingVectorRequest]] = OMIT,
        paths: typing.Optional[typing.List[str]] = OMIT,
    ) -> ClassificationResponse:
        """
        Upload assets to classify based on embedding id using either public path to assets, or embedding vectors

        Parameters:
            - threshold: typing.Optional[float]. Threshold above which classification is positive

            - embedding_id: typing.Optional[str]. The embedding id to get all concepts to use for classification

            - concept_id: typing.Optional[str]. A concept id to use to classify an image

            - embedding_vectors: typing.Optional[typing.List[ClassificationEmbeddingVectorRequest]]. The embedding vectors to classify

            - paths: typing.Optional[typing.List[str]]. The assets to classify
        """
        _request: typing.Dict[str, typing.Any] = {}
        if embedding_id is not OMIT:
            _request["embeddingId"] = embedding_id
        if concept_id is not OMIT:
            _request["conceptId"] = concept_id
        if embedding_vectors is not OMIT:
            _request["embeddingVectors"] = embedding_vectors
        if paths is not OMIT:
            _request["paths"] = paths
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v0/classify/assets"),
            params=remove_none_from_dict({"threshold": threshold}),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClassificationResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def classify_assets_file(
        self, *, embedding_id: str, threshold: typing.Optional[float] = None, files: typing.List[str]
    ) -> ClassificationResponse:
        """
        Upload assets to classify based on embedding id using one of image file, , csv of paths or a csv embedding vectors

        Parameters:
            - embedding_id: str. The unique identifier for the embedding

            - threshold: typing.Optional[float]. Threshold above which classification is positive

            - files: typing.List[str]. 1 of 3 types of files are accepted: 1: CSV file with a list of paths to assets to classify, 'path' is required header2: CSV file with embedding vectors, 'external_id' and 'embedding_vector' are required headers3: Image file (jpg, png or webp)
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v0/classify/assets/file"),
            params=remove_none_from_dict({"embedding_id": embedding_id, "threshold": threshold}),
            json=jsonable_encoder({"files": files}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(ClassificationResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def classify_assets_custom_model(
        self, model_name: str, *, embedding_id: str, threshold: typing.Optional[float] = None, files: typing.List[str]
    ) -> CustomClassificationResponse:
        """
        Upload list of assets to classify based on embedding id and a custom model

        Parameters:
            - model_name: str. The name of the model to use

            - embedding_id: str. The unique identifier for the embedding

            - threshold: typing.Optional[float]. Threshold above which classification is positive

            - files: typing.List[str]. List of assets to classify
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/v0/classify/assets/custom/{model_name}"
            ),
            params=remove_none_from_dict({"embedding_id": embedding_id, "threshold": threshold}),
            json=jsonable_encoder({"files": files}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CustomClassificationResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def classify_assets_for_visual_safety(
        self,
        *,
        threshold: typing.Optional[float] = None,
        embedding_vectors: typing.Optional[typing.List[ClassificationEmbeddingVectorRequest]] = OMIT,
        paths: typing.Optional[typing.List[str]] = OMIT,
    ) -> VisualSafetyClassificationResponse:
        """
        Classify a list of assets to determine whether they meet visual safety standards

        Parameters:
            - threshold: typing.Optional[float]. Threshold above which classification is positive

            - embedding_vectors: typing.Optional[typing.List[ClassificationEmbeddingVectorRequest]]. The embedding vectors to classify

            - paths: typing.Optional[typing.List[str]]. The assets to classify
        """
        _request: typing.Dict[str, typing.Any] = {}
        if embedding_vectors is not OMIT:
            _request["embeddingVectors"] = embedding_vectors
        if paths is not OMIT:
            _request["paths"] = paths
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v0/classify/assets/visual-safety"),
            params=remove_none_from_dict({"threshold": threshold}),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VisualSafetyClassificationResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def classify_assets_for_visual_safety_file(
        self, *, threshold: typing.Optional[float] = None, files: typing.List[str]
    ) -> VisualSafetyClassificationResponse:
        """
        Classify a list of assets to determine whether they meet visual safety standards (jpg, png or webp)

        Parameters:
            - threshold: typing.Optional[float]. Threshold above which classification is positive

            - files: typing.List[str]. List of assets to classify for visual safety
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", "api/v0/classify/assets/visual-safety/file"
            ),
            params=remove_none_from_dict({"threshold": threshold}),
            json=jsonable_encoder({"files": files}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(VisualSafetyClassificationResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def detect_text(
        self,
        *,
        threshold: typing.Optional[float] = None,
        embedding_vectors: typing.Optional[typing.List[ClassificationEmbeddingVectorRequest]] = OMIT,
        paths: typing.Optional[typing.List[str]] = OMIT,
    ) -> TextDetectionResponse:
        """
        Classify a list of assets to determine whether or not they contain text

        Parameters:
            - threshold: typing.Optional[float]. Threshold above which classification is positive

            - embedding_vectors: typing.Optional[typing.List[ClassificationEmbeddingVectorRequest]]. The embedding vectors to classify

            - paths: typing.Optional[typing.List[str]]. Public paths of assets to classify
        """
        _request: typing.Dict[str, typing.Any] = {}
        if embedding_vectors is not OMIT:
            _request["embeddingVectors"] = embedding_vectors
        if paths is not OMIT:
            _request["paths"] = paths
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v0/classify/assets/text-detect"),
            params=remove_none_from_dict({"threshold": threshold}),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TextDetectionResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def detect_text_file(
        self, *, threshold: typing.Optional[float] = None, files: typing.List[str]
    ) -> TextDetectionResponse:
        """
        Classify a list of assets to determine whether or not they contain text

        Parameters:
            - threshold: typing.Optional[float]. Threshold above which classification is positive

            - files: typing.List[str]. List of assets to classify for visual safety
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v0/classify/assets/text-detect/file"),
            params=remove_none_from_dict({"threshold": threshold}),
            json=jsonable_encoder({"files": files}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(TextDetectionResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
