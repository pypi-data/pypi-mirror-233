# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import pydantic

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...errors.bad_request_error import BadRequestError
from ...errors.forbidden_error import ForbiddenError
from ...errors.not_found_error import NotFoundError
from ...errors.unauthorized_error import UnauthorizedError
from ...errors.unprocessable_entity_error import UnprocessableEntityError
from ...types.add_asset_item import AddAssetItem
from ...types.dataset_list_response import DatasetListResponse
from ...types.dataset_response import DatasetResponse
from ...types.dataset_status_enum import DatasetStatusEnum
from ...types.encoder_list_response import EncoderListResponse
from ...types.error_response import ErrorResponse
from ...types.http_validation_error import HttpValidationError
from ...types.keyframe_sampling_method_enum import KeyframeSamplingMethodEnum
from ...types.paged_assets_response import PagedAssetsResponse
from ...types.storage_type_enum import StorageTypeEnum
from ...types.update_asset_metadata_item import UpdateAssetMetadataItem

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class DatasetClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_datasets(
        self,
        *,
        offset: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        statuses_to_include: typing.Union[typing.Optional[DatasetStatusEnum], typing.List[DatasetStatusEnum]],
    ) -> DatasetListResponse:
        """
        Get all datasets paginated, optionally filtered by status

        Parameters:
            - offset: typing.Optional[int]. Starting index to return

            - limit: typing.Optional[int]. Max number of items to return

            - statuses_to_include: typing.Union[typing.Optional[DatasetStatusEnum], typing.List[DatasetStatusEnum]]. Dataset status to include in the list response
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v0/datasets"),
            params=remove_none_from_dict(
                {"offset": offset, "limit": limit, "statuses_to_include": statuses_to_include}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DatasetListResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_dataset(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        storage_type: StorageTypeEnum,
        data_path: typing.Optional[str] = OMIT,
        csv_path: typing.Optional[str] = OMIT,
        metadata_path: typing.Optional[str] = OMIT,
        encoder: typing.Optional[str] = OMIT,
        credentials_id: typing.Optional[str] = OMIT,
        ocr: typing.Optional[bool] = OMIT,
        keyframe_sampling_method: typing.Optional[KeyframeSamplingMethodEnum] = OMIT,
        keyframe_uniform_fps_sampling_rate: typing.Optional[float] = OMIT,
    ) -> DatasetResponse:
        """
        Create a new dataset. The dataset will not be available to query until the status is 'ready'.

        Parameters:
            - name: str. The name of the dataset

            - description: typing.Optional[str]. The description of the dataset

            - storage_type: StorageTypeEnum. The primary data source for the dataset

            - data_path: typing.Optional[str]. An S3 path prefix for all images and videos to add to the dataset

            - csv_path: typing.Optional[str]. An path to a previously uploaded CSV file containing data paths

            - metadata_path: typing.Optional[str]. An optional S3 path for a CSV file containing any metadata for your images and videos that should be available to query query

            - encoder: typing.Optional[str]. The name of the encoder to transform your image and video data

            - credentials_id: typing.Optional[str]. The id of the credentials to use to access external data

            - ocr: typing.Optional[bool]. Enable OCR (optical character recognition) for all assets in this dataset

            - keyframe_sampling_method: typing.Optional[KeyframeSamplingMethodEnum]. Sampling method to extract keyframes from any videos in dataset

            - keyframe_uniform_fps_sampling_rate: typing.Optional[float]. Num of keyframes/sec to sample from videos if using uniform sampling method
        """
        _request: typing.Dict[str, typing.Any] = {"name": name, "storageType": storage_type}
        if description is not OMIT:
            _request["description"] = description
        if data_path is not OMIT:
            _request["dataPath"] = data_path
        if csv_path is not OMIT:
            _request["csvPath"] = csv_path
        if metadata_path is not OMIT:
            _request["metadataPath"] = metadata_path
        if encoder is not OMIT:
            _request["encoder"] = encoder
        if credentials_id is not OMIT:
            _request["credentialsId"] = credentials_id
        if ocr is not OMIT:
            _request["ocr"] = ocr
        if keyframe_sampling_method is not OMIT:
            _request["keyframeSamplingMethod"] = keyframe_sampling_method
        if keyframe_uniform_fps_sampling_rate is not OMIT:
            _request["keyframeUniformFpsSamplingRate"] = keyframe_uniform_fps_sampling_rate
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v0/datasets"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DatasetResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_dataset(self, dataset_id: str) -> DatasetResponse:
        """
        Get dataset by id

        Parameters:
            - dataset_id: str. The unique identifier for the dataset
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v0/datasets/{dataset_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DatasetResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_dataset(
        self, dataset_id: str, *, name: typing.Optional[str] = OMIT, description: typing.Optional[str] = OMIT
    ) -> DatasetResponse:
        """
        Update dataset by id

        Parameters:
            - dataset_id: str. The unique identifier for the dataset

            - name: typing.Optional[str]. New name for the dataset

            - description: typing.Optional[str]. New description for the dataset
        """
        _request: typing.Dict[str, typing.Any] = {}
        if name is not OMIT:
            _request["name"] = name
        if description is not OMIT:
            _request["description"] = description
        _response = self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v0/datasets/{dataset_id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DatasetResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_dataset(self, dataset_id: str) -> typing.Any:
        """
        Delete dataset by id

        Parameters:
            - dataset_id: str. The unique identifier for the dataset
        """
        _response = self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v0/datasets/{dataset_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_dataset_images(
        self, dataset_id: str, *, offset: typing.Optional[int] = None, limit: typing.Optional[int] = None
    ) -> PagedAssetsResponse:
        """
        Get images by dataset id

        Parameters:
            - dataset_id: str. The unique identifier for the dataset

            - offset: typing.Optional[int]. Starting index to return

            - limit: typing.Optional[int]. Max number of items to return
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v0/datasets/{dataset_id}/images"),
            params=remove_none_from_dict({"offset": offset, "limit": limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PagedAssetsResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_dataset_videos(
        self, dataset_id: str, *, offset: typing.Optional[int] = None, limit: typing.Optional[int] = None
    ) -> PagedAssetsResponse:
        """
        Get videos by dataset id

        Parameters:
            - dataset_id: str. The unique identifier for the dataset

            - offset: typing.Optional[int]. Starting index to return

            - limit: typing.Optional[int]. Max number of items to return
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v0/datasets/{dataset_id}/videos"),
            params=remove_none_from_dict({"offset": offset, "limit": limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PagedAssetsResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_available_encoders(
        self, *, offset: typing.Optional[int] = None, limit: typing.Optional[int] = None
    ) -> EncoderListResponse:
        """
        Get all available encoders

        Parameters:
            - offset: typing.Optional[int]. Starting index to return

            - limit: typing.Optional[int]. Max number of items to return
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v0/encoders"),
            params=remove_none_from_dict({"offset": offset, "limit": limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EncoderListResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def add_assets_to_dataset(
        self,
        dataset_id: str,
        *,
        asset_paths: typing.Optional[typing.List[str]] = OMIT,
        items: typing.Optional[typing.List[AddAssetItem]] = OMIT,
    ) -> DatasetResponse:
        """
        Add assets to an existing dataset

        Parameters:
            - dataset_id: str. The unique identifier for the dataset

            - asset_paths: typing.Optional[typing.List[str]]. DEPRECATION WARNING! (This input will become deprecated in a future release). A list of full, absolute image or videos paths to add to the dataset

            - items: typing.Optional[typing.List[AddAssetItem]]. A list of assets to add with optional metadata, asset_paths will get deprecated and this key is the one that will be used going forward
        """
        _request: typing.Dict[str, typing.Any] = {}
        if asset_paths is not OMIT:
            _request["assetPaths"] = asset_paths
        if items is not OMIT:
            _request["items"] = items
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v0/datasets/{dataset_id}/assets"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DatasetResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_metadata_for_assets(
        self, dataset_id: str, *, items: typing.Optional[typing.List[UpdateAssetMetadataItem]] = OMIT
    ) -> DatasetResponse:
        """
        Update asset metadata in an existing dataset

        Parameters:
            - dataset_id: str. The unique identifier for the dataset

            - items: typing.Optional[typing.List[UpdateAssetMetadataItem]]. A list of assets to add with metadata
        """
        _request: typing.Dict[str, typing.Any] = {}
        if items is not OMIT:
            _request["items"] = items
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/v0/datasets/{dataset_id}/assets_metadata"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DatasetResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncDatasetClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_datasets(
        self,
        *,
        offset: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        statuses_to_include: typing.Union[typing.Optional[DatasetStatusEnum], typing.List[DatasetStatusEnum]],
    ) -> DatasetListResponse:
        """
        Get all datasets paginated, optionally filtered by status

        Parameters:
            - offset: typing.Optional[int]. Starting index to return

            - limit: typing.Optional[int]. Max number of items to return

            - statuses_to_include: typing.Union[typing.Optional[DatasetStatusEnum], typing.List[DatasetStatusEnum]]. Dataset status to include in the list response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v0/datasets"),
            params=remove_none_from_dict(
                {"offset": offset, "limit": limit, "statuses_to_include": statuses_to_include}
            ),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DatasetListResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_dataset(
        self,
        *,
        name: str,
        description: typing.Optional[str] = OMIT,
        storage_type: StorageTypeEnum,
        data_path: typing.Optional[str] = OMIT,
        csv_path: typing.Optional[str] = OMIT,
        metadata_path: typing.Optional[str] = OMIT,
        encoder: typing.Optional[str] = OMIT,
        credentials_id: typing.Optional[str] = OMIT,
        ocr: typing.Optional[bool] = OMIT,
        keyframe_sampling_method: typing.Optional[KeyframeSamplingMethodEnum] = OMIT,
        keyframe_uniform_fps_sampling_rate: typing.Optional[float] = OMIT,
    ) -> DatasetResponse:
        """
        Create a new dataset. The dataset will not be available to query until the status is 'ready'.

        Parameters:
            - name: str. The name of the dataset

            - description: typing.Optional[str]. The description of the dataset

            - storage_type: StorageTypeEnum. The primary data source for the dataset

            - data_path: typing.Optional[str]. An S3 path prefix for all images and videos to add to the dataset

            - csv_path: typing.Optional[str]. An path to a previously uploaded CSV file containing data paths

            - metadata_path: typing.Optional[str]. An optional S3 path for a CSV file containing any metadata for your images and videos that should be available to query query

            - encoder: typing.Optional[str]. The name of the encoder to transform your image and video data

            - credentials_id: typing.Optional[str]. The id of the credentials to use to access external data

            - ocr: typing.Optional[bool]. Enable OCR (optical character recognition) for all assets in this dataset

            - keyframe_sampling_method: typing.Optional[KeyframeSamplingMethodEnum]. Sampling method to extract keyframes from any videos in dataset

            - keyframe_uniform_fps_sampling_rate: typing.Optional[float]. Num of keyframes/sec to sample from videos if using uniform sampling method
        """
        _request: typing.Dict[str, typing.Any] = {"name": name, "storageType": storage_type}
        if description is not OMIT:
            _request["description"] = description
        if data_path is not OMIT:
            _request["dataPath"] = data_path
        if csv_path is not OMIT:
            _request["csvPath"] = csv_path
        if metadata_path is not OMIT:
            _request["metadataPath"] = metadata_path
        if encoder is not OMIT:
            _request["encoder"] = encoder
        if credentials_id is not OMIT:
            _request["credentialsId"] = credentials_id
        if ocr is not OMIT:
            _request["ocr"] = ocr
        if keyframe_sampling_method is not OMIT:
            _request["keyframeSamplingMethod"] = keyframe_sampling_method
        if keyframe_uniform_fps_sampling_rate is not OMIT:
            _request["keyframeUniformFpsSamplingRate"] = keyframe_uniform_fps_sampling_rate
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v0/datasets"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DatasetResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_dataset(self, dataset_id: str) -> DatasetResponse:
        """
        Get dataset by id

        Parameters:
            - dataset_id: str. The unique identifier for the dataset
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v0/datasets/{dataset_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DatasetResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_dataset(
        self, dataset_id: str, *, name: typing.Optional[str] = OMIT, description: typing.Optional[str] = OMIT
    ) -> DatasetResponse:
        """
        Update dataset by id

        Parameters:
            - dataset_id: str. The unique identifier for the dataset

            - name: typing.Optional[str]. New name for the dataset

            - description: typing.Optional[str]. New description for the dataset
        """
        _request: typing.Dict[str, typing.Any] = {}
        if name is not OMIT:
            _request["name"] = name
        if description is not OMIT:
            _request["description"] = description
        _response = await self._client_wrapper.httpx_client.request(
            "PATCH",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v0/datasets/{dataset_id}"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DatasetResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_dataset(self, dataset_id: str) -> typing.Any:
        """
        Delete dataset by id

        Parameters:
            - dataset_id: str. The unique identifier for the dataset
        """
        _response = await self._client_wrapper.httpx_client.request(
            "DELETE",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v0/datasets/{dataset_id}"),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_dataset_images(
        self, dataset_id: str, *, offset: typing.Optional[int] = None, limit: typing.Optional[int] = None
    ) -> PagedAssetsResponse:
        """
        Get images by dataset id

        Parameters:
            - dataset_id: str. The unique identifier for the dataset

            - offset: typing.Optional[int]. Starting index to return

            - limit: typing.Optional[int]. Max number of items to return
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v0/datasets/{dataset_id}/images"),
            params=remove_none_from_dict({"offset": offset, "limit": limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PagedAssetsResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_dataset_videos(
        self, dataset_id: str, *, offset: typing.Optional[int] = None, limit: typing.Optional[int] = None
    ) -> PagedAssetsResponse:
        """
        Get videos by dataset id

        Parameters:
            - dataset_id: str. The unique identifier for the dataset

            - offset: typing.Optional[int]. Starting index to return

            - limit: typing.Optional[int]. Max number of items to return
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v0/datasets/{dataset_id}/videos"),
            params=remove_none_from_dict({"offset": offset, "limit": limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(PagedAssetsResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_available_encoders(
        self, *, offset: typing.Optional[int] = None, limit: typing.Optional[int] = None
    ) -> EncoderListResponse:
        """
        Get all available encoders

        Parameters:
            - offset: typing.Optional[int]. Starting index to return

            - limit: typing.Optional[int]. Max number of items to return
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "api/v0/encoders"),
            params=remove_none_from_dict({"offset": offset, "limit": limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(EncoderListResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def add_assets_to_dataset(
        self,
        dataset_id: str,
        *,
        asset_paths: typing.Optional[typing.List[str]] = OMIT,
        items: typing.Optional[typing.List[AddAssetItem]] = OMIT,
    ) -> DatasetResponse:
        """
        Add assets to an existing dataset

        Parameters:
            - dataset_id: str. The unique identifier for the dataset

            - asset_paths: typing.Optional[typing.List[str]]. DEPRECATION WARNING! (This input will become deprecated in a future release). A list of full, absolute image or videos paths to add to the dataset

            - items: typing.Optional[typing.List[AddAssetItem]]. A list of assets to add with optional metadata, asset_paths will get deprecated and this key is the one that will be used going forward
        """
        _request: typing.Dict[str, typing.Any] = {}
        if asset_paths is not OMIT:
            _request["assetPaths"] = asset_paths
        if items is not OMIT:
            _request["items"] = items
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", f"api/v0/datasets/{dataset_id}/assets"),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DatasetResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_metadata_for_assets(
        self, dataset_id: str, *, items: typing.Optional[typing.List[UpdateAssetMetadataItem]] = OMIT
    ) -> DatasetResponse:
        """
        Update asset metadata in an existing dataset

        Parameters:
            - dataset_id: str. The unique identifier for the dataset

            - items: typing.Optional[typing.List[UpdateAssetMetadataItem]]. A list of assets to add with metadata
        """
        _request: typing.Dict[str, typing.Any] = {}
        if items is not OMIT:
            _request["items"] = items
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/v0/datasets/{dataset_id}/assets_metadata"
            ),
            json=jsonable_encoder(_request),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(DatasetResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
