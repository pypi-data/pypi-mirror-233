# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import pydantic

from ...core.api_error import ApiError
from ...core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_dict import remove_none_from_dict
from ...errors.bad_request_error import BadRequestError
from ...errors.forbidden_error import ForbiddenError
from ...errors.not_found_error import NotFoundError
from ...errors.unauthorized_error import UnauthorizedError
from ...errors.unprocessable_entity_error import UnprocessableEntityError
from ...types.error_response import ErrorResponse
from ...types.http_validation_error import HttpValidationError
from ...types.similarity_search_response import SimilaritySearchResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class SimilaritySearchClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get_similar_images_grouped(
        self, embedding_id: str, *, group_by: str, limit: typing.Optional[int] = None, file: typing.IO
    ) -> SimilaritySearchResponse:
        """
        Returns the images most similar to the image at the provided path within the same embedding space grouped by the group by key

        Parameters:
            - embedding_id: str. The unique identifier for the embedding

            - group_by: str. If provided the result will be grouped by the provided asset metadata key

            - limit: typing.Optional[int]. Max number of items to return

            - file: typing.IO.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/v0/similarity-search/embeddings/{embedding_id}/grouped-search",
            ),
            params=remove_none_from_dict({"group_by": group_by, "limit": limit}),
            data=jsonable_encoder({}),
            files={"file": file},
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SimilaritySearchResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_similar_images_grouped_semantic(
        self,
        embedding_id: str,
        *,
        group_by: str,
        metadata_key: typing.Optional[str] = None,
        metadata_value: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        file: typing.IO,
    ) -> SimilaritySearchResponse:
        """
        Returns the images most similar to the image at the provided path within the same embedding space grouped by the group by key and optionally by the semantic notion of metadata about the assets

        Parameters:
            - embedding_id: str. The unique identifier for the embedding

            - group_by: str. If provided the result will be grouped by the provided asset metadata key

            - metadata_key: typing.Optional[str]. The metadata key field to add the semantic search on, if left blank all columns will be taken into consideration. Required if metadata key is passed in, else optional.

            - metadata_value: typing.Optional[str]. The metadata value to use for the semantic search. Required if metadata key is passed in, else optional.

            - limit: typing.Optional[int]. Max number of items to return

            - file: typing.IO.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/v0/similarity-search/embeddings/{embedding_id}/grouped-search/semantic",
            ),
            params=remove_none_from_dict(
                {"group_by": group_by, "metadata_key": metadata_key, "metadata_value": metadata_value, "limit": limit}
            ),
            data=jsonable_encoder({}),
            files={"file": file},
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SimilaritySearchResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def search_images_by_text_grouped(
        self,
        embedding_id: str,
        *,
        group_by: typing.Optional[str] = None,
        query: str,
        limit: typing.Optional[int] = None,
    ) -> SimilaritySearchResponse:
        """
        Returns the images most similar to the text query provided within the same embedding space grouped by the group by key

        Parameters:
            - embedding_id: str. The unique identifier for the embedding

            - group_by: typing.Optional[str]. If provided the result will be grouped by the provided asset metadata key

            - query: str. The query string to fetch images of

            - limit: typing.Optional[int]. Max number of items to return
        """
        _response = self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/v0/similarity-search/similarity-search/embeddings/{embedding_id}/grouped-search/text",
            ),
            params=remove_none_from_dict({"group_by": group_by, "query": query, "limit": limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SimilaritySearchResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_similar_images(
        self, embedding_id: str, *, limit: typing.Optional[int] = None, file: typing.IO
    ) -> typing.Any:
        """
        Returns the images most similar to the image at the provided path within the same embedding space

        Parameters:
            - embedding_id: str. The unique identifier for the embedding

            - limit: typing.Optional[int]. Max number of items to return

            - file: typing.IO.
        """
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/v0/similarity-search/embeddings/{embedding_id}/search"
            ),
            params=remove_none_from_dict({"limit": limit}),
            data=jsonable_encoder({}),
            files={"file": file},
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncSimilaritySearchClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get_similar_images_grouped(
        self, embedding_id: str, *, group_by: str, limit: typing.Optional[int] = None, file: typing.IO
    ) -> SimilaritySearchResponse:
        """
        Returns the images most similar to the image at the provided path within the same embedding space grouped by the group by key

        Parameters:
            - embedding_id: str. The unique identifier for the embedding

            - group_by: str. If provided the result will be grouped by the provided asset metadata key

            - limit: typing.Optional[int]. Max number of items to return

            - file: typing.IO.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/v0/similarity-search/embeddings/{embedding_id}/grouped-search",
            ),
            params=remove_none_from_dict({"group_by": group_by, "limit": limit}),
            data=jsonable_encoder({}),
            files={"file": file},
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SimilaritySearchResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_similar_images_grouped_semantic(
        self,
        embedding_id: str,
        *,
        group_by: str,
        metadata_key: typing.Optional[str] = None,
        metadata_value: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        file: typing.IO,
    ) -> SimilaritySearchResponse:
        """
        Returns the images most similar to the image at the provided path within the same embedding space grouped by the group by key and optionally by the semantic notion of metadata about the assets

        Parameters:
            - embedding_id: str. The unique identifier for the embedding

            - group_by: str. If provided the result will be grouped by the provided asset metadata key

            - metadata_key: typing.Optional[str]. The metadata key field to add the semantic search on, if left blank all columns will be taken into consideration. Required if metadata key is passed in, else optional.

            - metadata_value: typing.Optional[str]. The metadata value to use for the semantic search. Required if metadata key is passed in, else optional.

            - limit: typing.Optional[int]. Max number of items to return

            - file: typing.IO.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/v0/similarity-search/embeddings/{embedding_id}/grouped-search/semantic",
            ),
            params=remove_none_from_dict(
                {"group_by": group_by, "metadata_key": metadata_key, "metadata_value": metadata_value, "limit": limit}
            ),
            data=jsonable_encoder({}),
            files={"file": file},
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SimilaritySearchResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def search_images_by_text_grouped(
        self,
        embedding_id: str,
        *,
        group_by: typing.Optional[str] = None,
        query: str,
        limit: typing.Optional[int] = None,
    ) -> SimilaritySearchResponse:
        """
        Returns the images most similar to the text query provided within the same embedding space grouped by the group by key

        Parameters:
            - embedding_id: str. The unique identifier for the embedding

            - group_by: typing.Optional[str]. If provided the result will be grouped by the provided asset metadata key

            - query: str. The query string to fetch images of

            - limit: typing.Optional[int]. Max number of items to return
        """
        _response = await self._client_wrapper.httpx_client.request(
            "GET",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/",
                f"api/v0/similarity-search/similarity-search/embeddings/{embedding_id}/grouped-search/text",
            ),
            params=remove_none_from_dict({"group_by": group_by, "query": query, "limit": limit}),
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(SimilaritySearchResponse, _response.json())  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_similar_images(
        self, embedding_id: str, *, limit: typing.Optional[int] = None, file: typing.IO
    ) -> typing.Any:
        """
        Returns the images most similar to the image at the provided path within the same embedding space

        Parameters:
            - embedding_id: str. The unique identifier for the embedding

            - limit: typing.Optional[int]. Max number of items to return

            - file: typing.IO.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(
                f"{self._client_wrapper.get_base_url()}/", f"api/v0/similarity-search/embeddings/{embedding_id}/search"
            ),
            params=remove_none_from_dict({"limit": limit}),
            data=jsonable_encoder({}),
            files={"file": file},
            headers=self._client_wrapper.get_headers(),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.Any, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise UnauthorizedError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(ErrorResponse, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 422:
            raise UnprocessableEntityError(pydantic.parse_obj_as(HttpValidationError, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
