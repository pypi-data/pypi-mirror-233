{
  "hash": "cd956a652aa3d5d5355e99ea3149e70b",
  "result": {
    "markdown": "---\ntitle: Scalar UDFs\n---\n\n\n\nScalar user-defined function APIs\n\n# scalar { #ibis.expr.operations.udf.scalar }\n\n`expr.operations.udf.scalar()`\n\nScalar user-defined functions.\n\n::: {.callout-note}\n## The `scalar` class itself is **not** a public API, its methods are.\n:::\n\n## Methods\n\n| Name | Description |\n| --- | --- |\n| [pandas](#ibis.expr.operations.udf.scalar.pandas) | Construct a **vectorized** scalar user-defined function that accepts pandas Series' as inputs. |\n| [pyarrow](#ibis.expr.operations.udf.scalar.pyarrow) | Construct a **vectorized** scalar user-defined function that accepts PyArrow Arrays as input. |\n| [python](#ibis.expr.operations.udf.scalar.python) | Construct a **non-vectorized** scalar user-defined function that accepts Python scalar values as inputs. |\n\n### pandas { #ibis.expr.operations.udf.scalar.pandas }\n\n`pandas(cls, fn=None, *args, name=None, schema=None, **kwargs)`\n\nConstruct a **vectorized** scalar user-defined function that accepts pandas Series' as inputs.\n\n#### Parameters\n\n| Name     | Type                                  | Description                                                             | Default   |\n|----------|---------------------------------------|-------------------------------------------------------------------------|-----------|\n| `fn`     | [Callable](`typing.Callable`) \\| None | The The function to wrap.                                               | `None`    |\n| `args`   | [Any](`typing.Any`)                   | Configuration arguments for the UDF.                                    | `()`      |\n| `name`   | [str](`str`) \\| None                  | The name of the UDF in the backend if different from the function name. | `None`    |\n| `schema` | [str](`str`) \\| None                  | The schema in which to create the UDF.                                  | `None`    |\n| `kwargs` | [Any](`typing.Any`)                   | Additional configuration arguments for the UDF.                         | `{}`      |\n\n#### Examples\n\n```python\n>>> import ibis\n>>> @ibis.udf.scalar.pandas\n... def add_one(x: int) -> int:\n...     return x + 1\n>>> expr = add_one(2)\n>>> con = ibis.connect(os.environ[\"SNOWFLAKE_URL\"])  # doctest: +SKIP\n>>> con.execute(expr)  # doctest: +SKIP\n3\n```\n\n#### See Also\n\n- [`python`](./scalar-udfs.qmd#ibis.expr.operations.scalar.python)\n- [`pyarrow`](./scalar-udfs.qmd#ibis.expr.operations.scalar.pyarrow)\n\n### pyarrow { #ibis.expr.operations.udf.scalar.pyarrow }\n\n`pyarrow(cls, fn=None, *args, name=None, schema=None, **kwargs)`\n\nConstruct a **vectorized** scalar user-defined function that accepts PyArrow Arrays as input.\n\n#### Parameters\n\n| Name     | Type                                  | Description                                                             | Default   |\n|----------|---------------------------------------|-------------------------------------------------------------------------|-----------|\n| `fn`     | [Callable](`typing.Callable`) \\| None | The The function to wrap.                                               | `None`    |\n| `args`   | [Any](`typing.Any`)                   | Configuration arguments for the UDF.                                    | `()`      |\n| `name`   | [str](`str`) \\| None                  | The name of the UDF in the backend if different from the function name. | `None`    |\n| `schema` | [str](`str`) \\| None                  | The schema in which to create the UDF.                                  | `None`    |\n| `kwargs` | [Any](`typing.Any`)                   | Additional configuration arguments for the UDF.                         | `{}`      |\n\n#### Examples\n\n\n::: {#7d8f6e38 .cell execution_count=1}\n``` {.python .cell-code}\n>>> import ibis\n>>> import pyarrow.compute as pc\n>>> @ibis.udf.scalar.pyarrow\n... def add_one(x: int) -> int:\n...     return pc.add(x, 1)\n>>> expr = add_one(2)\n>>> con = ibis.connect(\"duckdb://\")\n>>> con.execute(expr)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3\n```\n:::\n:::\n\n\n#### See Also\n\n- [`python`](./scalar-udfs.qmd#ibis.expr.operations.scalar.python)\n- [`pandas`](./scalar-udfs.qmd#ibis.expr.operations.scalar.pandas)\n\n### python { #ibis.expr.operations.udf.scalar.python }\n\n`python(cls, fn=None, *args, name=None, schema=None, **kwargs)`\n\nConstruct a **non-vectorized** scalar user-defined function that accepts Python scalar values as inputs.\n\n::: {.callout-warning collapse=\"true\"}\n## `python` UDFs are likely to be slow\n\n`python` UDFs are not vectorized: they are executed row by row with one\nPython function call per row\n\nThis calling pattern tends to be **much** slower than\n[`pandas`](./scalar-udfs.qmd#ibis.expr.operations.scalar.pandas)\nor\n[`pyarrow`](./scalar-udfs.qmd#ibis.expr.operations.scalar.pyarrow)-based\nvectorized UDFs.\n:::\n\n#### Parameters\n\n| Name     | Type                                  | Description                                                             | Default   |\n|----------|---------------------------------------|-------------------------------------------------------------------------|-----------|\n| `fn`     | [Callable](`typing.Callable`) \\| None | The The function to wrap.                                               | `None`    |\n| `args`   | [Any](`typing.Any`)                   | Configuration arguments for the UDF.                                    | `()`      |\n| `name`   | [str](`str`) \\| None                  | The name of the UDF in the backend if different from the function name. | `None`    |\n| `schema` | [str](`str`) \\| None                  | The schema in which to create the UDF.                                  | `None`    |\n| `kwargs` | [Any](`typing.Any`)                   | Additional configuration arguments for the UDF.                         | `{}`      |\n\n#### Examples\n\n::: {#7720f70e .cell execution_count=2}\n``` {.python .cell-code}\n>>> import ibis\n>>> @ibis.udf.scalar.python\n... def add_one(x: int) -> int:\n...     return x + 1\n>>> expr = add_one(2)\n>>> con = ibis.connect(\"duckdb://\")\n>>> con.execute(expr)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n3\n```\n:::\n:::\n\n\n#### See Also\n\n- [`pandas`](./scalar-udfs.qmd#ibis.expr.operations.scalar.pandas)\n- [`pyarrow`](./scalar-udfs.qmd#ibis.expr.operations.scalar.pyarrow)\n\n",
    "supporting": [
      "scalar-udfs_files"
    ],
    "filters": [],
    "includes": {}
  }
}