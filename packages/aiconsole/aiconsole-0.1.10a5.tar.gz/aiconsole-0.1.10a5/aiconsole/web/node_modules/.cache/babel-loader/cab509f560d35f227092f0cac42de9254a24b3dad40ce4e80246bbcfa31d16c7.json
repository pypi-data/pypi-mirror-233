{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useDebouncedValue } from '@mantine/hooks';\nimport { create } from 'zustand';\nexport const usePromptStore = create((set, get) => ({\n  strategy: undefined,\n  mode: 'QUALITY',\n  manuals: [],\n  messages: [],\n  setMessages: newMessages => set(state => ({\n    messages: newMessages\n  })),\n  removeMessage: index => set(state => ({\n    messages: state.messages.filter((_, i) => i !== index)\n  })),\n  messagesWithPrompt: () => {\n    return [...get().messages, {\n      role: 'user',\n      content: get().getPrompt()\n    }];\n  },\n  analysisAbortController: undefined,\n  // Initialize fetchAbortController as undefined\n\n  doGPT: async () => {\n    var _get$strategy, _response$body;\n    let response = await fetch(`http://${window.location.hostname}:8000/gpt`, {\n      method: 'POST',\n      body: JSON.stringify({\n        messages: get().messages,\n        relevant_manuals: get().manuals,\n        strategy: ((_get$strategy = get().strategy) === null || _get$strategy === void 0 ? void 0 : _get$strategy.id) || '???',\n        mode: get().mode\n      }),\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n    const reader = (_response$body = response.body) === null || _response$body === void 0 ? void 0 : _response$body.getReader();\n    const decoder = new TextDecoder('utf-8');\n    let newMessages = [...get().messages, {\n      role: 'assistant',\n      content: ''\n    }];\n    while (true) {\n      const {\n        value,\n        done\n      } = (await (reader === null || reader === void 0 ? void 0 : reader.read())) || {\n        value: undefined,\n        done: true\n      };\n      let text = decoder.decode(value);\n      if (text.includes('§§§§§CLEAR§§§§§')) {\n        newMessages[newMessages.length - 1].content = '';\n        //delete everything up to $$$CLEAR$$$ in text\n        text = text.substring(text.indexOf('§§§§§CLEAR§§§§§') + 15);\n      }\n      newMessages[newMessages.length - 1].content += text;\n      get().setMessages(newMessages.slice());\n      //console.log(newMessages);\n\n      if (done) {\n        break;\n      }\n    }\n  },\n  getPrompt: () => {\n    return get().promptHistory[get().promptIndex];\n  },\n  analysisTimeoutId: undefined,\n  requestAnalysis: () => {\n    var _get$analysisAbortCon;\n    // Create new AbortController instance for every new analysis request\n\n    (_get$analysisAbortCon = get().analysisAbortController) === null || _get$analysisAbortCon === void 0 ? void 0 : _get$analysisAbortCon.abort(); // Abort existing fetch operation if any\n    const abortController = new AbortController();\n    set(state => ({\n      analysisAbortController: abortController\n    }));\n    if (get().analysisTimeoutId) {\n      clearTimeout(get().analysisTimeoutId);\n    }\n    const timeoutId = setTimeout(() => {\n      get().doAnalysis();\n    }, 1000);\n    set(state => ({\n      analysisTimeoutId: timeoutId\n    }));\n  },\n  doAnalysis: async () => {\n    var _get$analysisAbortCon2, _get$analysisAbortCon4, _get$analysisAbortCon5;\n    set(state => ({\n      analysisTimeoutId: undefined\n    }));\n    if ((_get$analysisAbortCon2 = get().analysisAbortController) !== null && _get$analysisAbortCon2 !== void 0 && _get$analysisAbortCon2.signal.aborted) {\n      // If existing fetch operation has been aborted, stop proceeding\n      return;\n    }\n    let response;\n    try {\n      var _get$analysisAbortCon3;\n      response = await fetch(`http://${window.location.hostname}:8000/analyse`, {\n        method: 'POST',\n        body: JSON.stringify({\n          messages: get().messagesWithPrompt(),\n          mode: get().mode\n        }),\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        signal: (_get$analysisAbortCon3 = get().analysisAbortController) === null || _get$analysisAbortCon3 === void 0 ? void 0 : _get$analysisAbortCon3.signal // Passing abort signal to fetch operation\n      });\n    } catch (err) {\n      if (err.name === 'AbortError') {\n        console.log('Fetch operation aborted');\n        return;\n      } else {\n        throw err;\n      }\n    }\n    if ((_get$analysisAbortCon4 = get().analysisAbortController) !== null && _get$analysisAbortCon4 !== void 0 && _get$analysisAbortCon4.signal.aborted) {\n      // If existing fetch operation has been aborted, stop proceeding\n      return;\n    }\n    let data = await response.json();\n    if ((_get$analysisAbortCon5 = get().analysisAbortController) !== null && _get$analysisAbortCon5 !== void 0 && _get$analysisAbortCon5.signal.aborted) {\n      // If existing fetch operation has been aborted, stop proceeding\n      return;\n    }\n    set(state => ({\n      strategy: data.strategy,\n      manuals: data.manuals,\n      usedTokens: data.usedTokens,\n      availableTokens: data.availableTokens\n    }));\n    set(state => ({\n      analysisAbortController: undefined\n    }));\n  },\n  usedTokens: 0,\n  availableTokens: 0,\n  promptHistory: [''],\n  promptIndex: 0,\n  historyUp: () => set(state => ({\n    promptIndex: Math.min(state.promptHistory.length - 1, state.promptIndex + 1)\n  })),\n  historyDown: () => set(state => ({\n    promptIndex: Math.max(0, state.promptIndex - 1)\n  })),\n  editPrompt: prompt => {\n    set(state => ({\n      promptHistory: [...state.promptHistory.slice(0, state.promptIndex), prompt, ...state.promptHistory.slice(state.promptIndex + 1, state.promptHistory.length)]\n    }));\n    get().requestAnalysis();\n  },\n  newPrompt: () => set(state => ({\n    promptHistory: ['', ...state.promptHistory],\n    promptIndex: 0\n  }))\n}));\nexport function useDebouncedPrompt() {\n  _s();\n  const prompt = usePromptStore(state => state.promptHistory[state.promptIndex]).trim();\n  const [debouncedPrompt] = useDebouncedValue(prompt, 150, {\n    leading: true\n  });\n  return debouncedPrompt;\n}\n_s(useDebouncedPrompt, \"X4qn8ZpkGMRvkHk5aWvkWtvJexM=\", false, function () {\n  return [usePromptStore, useDebouncedValue];\n});","map":{"version":3,"names":["useDebouncedValue","create","usePromptStore","set","get","strategy","undefined","mode","manuals","messages","setMessages","newMessages","state","removeMessage","index","filter","_","i","messagesWithPrompt","role","content","getPrompt","analysisAbortController","doGPT","_get$strategy","_response$body","response","fetch","window","location","hostname","method","body","JSON","stringify","relevant_manuals","id","headers","reader","getReader","decoder","TextDecoder","value","done","read","text","decode","includes","length","substring","indexOf","slice","promptHistory","promptIndex","analysisTimeoutId","requestAnalysis","_get$analysisAbortCon","abort","abortController","AbortController","clearTimeout","timeoutId","setTimeout","doAnalysis","_get$analysisAbortCon2","_get$analysisAbortCon4","_get$analysisAbortCon5","signal","aborted","_get$analysisAbortCon3","err","name","console","log","data","json","usedTokens","availableTokens","historyUp","Math","min","historyDown","max","editPrompt","prompt","newPrompt","useDebouncedPrompt","_s","trim","debouncedPrompt","leading"],"sources":["/Users/maciel/Projects/aiconsole/web/src/workspace/prompt_store.ts"],"sourcesContent":["import { useDebouncedValue } from '@mantine/hooks';\nimport { create } from 'zustand';\n\nexport type GPTMessage = {\n  role: string;\n  content: string;\n};\n\nexport type Manual = {\n  id: string;\n  usage: string;\n  content: string;\n};\n\nexport type Strategy = {\n  id: string;\n  usage: string;\n  content: string;\n};\n\n\nexport type GPTMode = 'QUALITY' | 'FAST';\n\ntype PromptStore = {\n  strategy?: Strategy;\n  mode: GPTMode;\n  manuals: Manual[];\n  messages: GPTMessage[];\n  setMessages: (newMessages: GPTMessage[]) => void;\n  removeMessage: (index: number) => void;\n\n  usedTokens: number;\n  availableTokens: number;\n\n  promptHistory: string[];\n  promptIndex: number;\n\n  historyUp: () => void;\n  historyDown: () => void;\n  newPrompt: () => void;\n  editPrompt: (prompt: string) => void;\n  getPrompt: () => string;\n\n  requestAnalysis: () => void;\n  doAnalysis: () => void;\n  analysisTimeoutId: NodeJS.Timeout | undefined;\n\n  doGPT: () => void;\n\n  messagesWithPrompt: () => GPTMessage[];\n\n  analysisAbortController: AbortController | undefined; // New property to handle fetch operation cancellation\n\n};\n\nexport const usePromptStore = create<PromptStore>((set, get) => ({\n  strategy: undefined,\n  mode: 'QUALITY',\n  manuals: [],\n  messages: [],\n  setMessages: (newMessages: GPTMessage[]) =>\n    set((state) => ({\n      messages: newMessages,\n    })),\n  removeMessage: (index: number) =>\n    set((state) => ({\n      messages: state.messages.filter((_, i) => i !== index),\n    })),\n\n  messagesWithPrompt: () => {\n    return [...get().messages, { role: 'user', content: get().getPrompt() }];\n  },\n\n  analysisAbortController: undefined, // Initialize fetchAbortController as undefined\n\n\n  doGPT: async () => {\n    let response = await fetch(`http://${window.location.hostname}:8000/gpt`, {\n      method: 'POST',\n      body: JSON.stringify({\n        messages: get().messages,\n        relevant_manuals: get().manuals,\n        strategy: get().strategy?.id || '???',\n        mode: get().mode\n      }),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    });\n\n    const reader = response.body?.getReader();\n    const decoder = new TextDecoder('utf-8');\n\n    let newMessages = [...get().messages, { role: 'assistant', content: '' }];\n\n    while (true) {\n      const { value, done } = (await reader?.read()) || { value: undefined, done: true };\n\n      let text = decoder.decode(value);\n      if (text.includes('§§§§§CLEAR§§§§§')) {\n        newMessages[newMessages.length - 1].content = '';\n        //delete everything up to $$$CLEAR$$$ in text\n        text = text.substring(text.indexOf('§§§§§CLEAR§§§§§') + 15);\n      }\n\n      newMessages[newMessages.length - 1].content += text;\n      get().setMessages(newMessages.slice());\n      //console.log(newMessages);\n\n      if (done) {\n        break;\n      }\n    }\n  },\n\n  getPrompt: () => {\n    return get().promptHistory[get().promptIndex];\n  },\n\n  analysisTimeoutId: undefined,\n  \n  requestAnalysis: () => {\n    // Create new AbortController instance for every new analysis request\n\n    get().analysisAbortController?.abort(); // Abort existing fetch operation if any\n    const abortController = new AbortController();\n    \n    set((state) => ({\n      analysisAbortController: abortController \n    }));\n    \n    if (get().analysisTimeoutId) {\n      clearTimeout(get().analysisTimeoutId);\n    }\n\n    const timeoutId = setTimeout(() => {\n      get().doAnalysis();\n    }, 1000);\n\n    set((state) => ({\n      analysisTimeoutId: timeoutId,\n    }));\n  },\n\n  doAnalysis: async () => {\n    set((state) => ({\n      analysisTimeoutId: undefined,\n    }));\n\n    if (get().analysisAbortController?.signal.aborted) { // If existing fetch operation has been aborted, stop proceeding\n      return;\n    }\n\n    let response;\n    try {\n      response = await fetch(`http://${window.location.hostname}:8000/analyse`, {\n        method: 'POST',\n        body: JSON.stringify({\n          messages: get().messagesWithPrompt(),\n          mode: get().mode,\n        }),\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        signal: get().analysisAbortController?.signal // Passing abort signal to fetch operation\n      });\n    } catch (err) {\n      if ((err as any).name === 'AbortError') {  \n        console.log('Fetch operation aborted'); \n        return;\n      } else {\n        throw err;\n      }\n    }\n\n    if (get().analysisAbortController?.signal.aborted) { // If existing fetch operation has been aborted, stop proceeding\n      return;\n    }\n\n    let data = await response.json();\n\n    if (get().analysisAbortController?.signal.aborted) { // If existing fetch operation has been aborted, stop proceeding\n      return;\n    }\n\n    set((state) => ({\n      strategy: data.strategy,\n      manuals: data.manuals,\n      usedTokens: data.usedTokens,\n      availableTokens: data.availableTokens,\n    }));\n\n    set((state) => ({\n      analysisAbortController: undefined\n    }));\n  },\n\n  usedTokens: 0,\n  availableTokens: 0,\n  promptHistory: [''],\n  promptIndex: 0,\n  historyUp: () =>\n    set((state) => ({\n      promptIndex: Math.min(state.promptHistory.length - 1, state.promptIndex + 1),\n    })),\n  historyDown: () => set((state) => ({ promptIndex: Math.max(0, state.promptIndex - 1) })),\n  editPrompt: (prompt) => {\n    set((state) => ({\n      promptHistory: [\n        ...state.promptHistory.slice(0, state.promptIndex),\n        prompt,\n        ...state.promptHistory.slice(state.promptIndex + 1, state.promptHistory.length),\n      ],\n    }));\n    get().requestAnalysis();\n  },\n  newPrompt: () =>\n    set((state) => ({\n      promptHistory: ['', ...state.promptHistory],\n      promptIndex: 0,\n    })),\n}));\n\nexport function useDebouncedPrompt() {\n  const prompt = usePromptStore((state) => state.promptHistory[state.promptIndex]).trim();\n  const [debouncedPrompt] = useDebouncedValue(prompt, 150, { leading: true });\n\n  return debouncedPrompt;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}