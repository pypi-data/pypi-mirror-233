import json
import os
import time

import pyotp
from cryptography.fernet import InvalidToken
from InquirerPy import inquirer, prompt
from InquirerPy.base.control import Choice
from InquirerPy.utils import color_print

from aws_assume_role_otp.config import get_config
from aws_assume_role_otp.encryption import decrypt, encrypt
from aws_assume_role_otp.sts import can_assume_role, is_access_key_valid


class Role:
    def __init__(self, arn: str, profile: str):
        self.arn = arn
        self.profile = profile


class Credentials:
    def __init__(
        self,
        access_key_id: str,
        secret_access_key: str,
        otp: str,
        serial: str,
    ):
        self.access_key_id = access_key_id
        self.secret_access_key = secret_access_key
        self.otp = otp
        self.serial = serial


def credentials_configured() -> bool:
    config = get_config()
    file_exist = os.path.exists(config.key_path)
    if not file_exist:
        return False
    # Check if the encryption is not corrupted
    try:
        get_credentials()
        return True
    except InvalidToken:
        color_print(
            [
                (
                    "#FF0000",
                    "It seems your encrypted key was generated by a different version. Please reconfigure it",
                )
            ]
        )
        return False


def persist(credentias: Credentials, roles: list[Role]):
    config = get_config()
    with open(config.key_path, "w") as f:
        f.write(
            encrypt(
                json.dumps(
                    {
                        "access_key_id": credentias.access_key_id,
                        "secret_access_key": credentias.secret_access_key,
                        "otp": credentias.otp,
                        "serial": credentias.serial,
                        "roles": [
                            {"arn": role.arn, "profile": role.profile}
                            for role in roles
                        ],
                    }
                )
            )
        )


def get_credentials() -> Credentials:
    config = get_config()
    with open(config.key_path, "r") as f:
        data = json.loads(decrypt(f.read()))
        return Credentials(
            access_key_id=data["access_key_id"],
            secret_access_key=data["secret_access_key"],
            otp=data["otp"],
            serial=data["serial"],
        )


def get_roles() -> list[Role]:
    config = get_config()
    with open(config.key_path, "r") as f:
        data = json.loads(decrypt(f.read()))
        return [Role(role["arn"], role["profile"]) for role in data["roles"]]


def add_roles_form(credentials: Credentials) -> list[Role]:
    color_print([("#FFE4B5", "Inform the Roles ARN and alias you want to use")])
    roles = []
    proceed = False
    totp = pyotp.TOTP(credentials.otp)
    while not proceed:
        questions = [
            {
                "type": "input",
                "message": "Role ARN",
                "name": "arn",
                "validate": lambda result: len(result) > 0,
                "invalid_message": "Input cannot be empty.",
            },
            {
                "type": "input",
                "message": "AWS Profile to use when assuming the role. Leave it empty to export environment variables",
                "name": "profile",
            },
        ]
        results = prompt(questions)
        if not can_assume_role(
            access_key_id=credentials.access_key_id,
            secret_access_key=credentials.secret_access_key,
            role_arn=results["arn"],
            serial=credentials.serial,
            token=totp.now(),
        ):
            color_print(
                [
                    (
                        "#FF0000",
                        f"It was not possible to assume the role {results['arn']}. Please check you have the right permissions to assume the role",
                    )
                ]
            )
            continue

        roles.append(Role(results["arn"], results["profile"]))
        proceed = not inquirer.confirm(
            message="Do you want to add another role",
            default=True,
        ).execute()
    return roles


def configure_credentials() -> None:
    color_print([("#1E90FF", "Configuring credentials")])
    questions = [
        {
            "type": "input",
            "message": "Access Key Id",
            "name": "access_key_id",
            "validate": lambda result: len(result) > 0,
            "invalid_message": "Input cannot be empty.",
        },
        {
            "type": "input",
            "message": "Secret Access Key",
            "name": "secret_access_key",
            "validate": lambda result: len(result) > 0,
            "invalid_message": "Input cannot be empty.",
        },
        {
            "type": "input",
            "message": "MFA Secret key (you can get the 64 characters string from the AWS Console IAM MFA Assign page clicking on show secret link)",
            "name": "otp",
            "validate": lambda result: len(result) == 64,
            "invalid_message": "Input lenght must be 64 characters",
        },
    ]

    results = prompt(questions)
    access_key_id = results["access_key_id"]
    secret_access_key = results["secret_access_key"]
    otp = results["otp"]

    if not is_access_key_valid(access_key_id, secret_access_key):
        raise Exception("Invalid access key id or secret access key")

    totp = pyotp.TOTP(otp)
    proceed = False
    color_print([("#FFE4B5", "Confirm your MFA code on AWS")])
    while not proceed:
        color_print([("#ADFF2F", "Your MFA code 1 is: "), ("#1E90FF", totp.now())])
        color_print([("#FFE4B5", "MFA code 2 will be sent in 30 seconds")])
        time.sleep(30)
        color_print([("#ADFF2F", "Your MFA code 2 is: "), ("#1E90FF", totp.now())])
        proceed = inquirer.confirm(
            message="If the code works, you should be able to see the MFA ARN otherwise you can try again with new codes. Do you want to proceed?",
            default=True,
        ).execute()

    serial = inquirer.text(
        message="What is the MFA serial ARN generated by AWS:",
        validate=lambda result: len(result) > 0,
        invalid_message="Serial cannot be empty",
    ).execute()

    credentials = Credentials(
        access_key_id=access_key_id,
        secret_access_key=secret_access_key,
        otp=otp,
        serial=serial,
    )
    roles = add_roles_form(credentials)
    persist(credentials, roles)
    color_print(
        [
            (
                "#FFE4B5",
                "Credentials configured. Consider waiting for 30 seconds before assuming any role",
            )
        ]
    )


def prompt_role(roles: list[Role]) -> Role:
    questions = [
        {
            "type": "list",
            "message": "Select the role to assume",
            "name": "role",
            "choices": [Choice(role.arn, role.profile) for role in roles],
        }
    ]
    results = prompt(questions)
    return Role(
        results["role"],
        [role.profile for role in roles if role.arn == results["role"]][0],
    )


def add_role(credentials: Credentials, roles: list[Role]) -> None:
    color_print([("#FFE4B5", "Adding new roles")])
    persist(credentials, roles + add_roles_form(credentials))


def remove_role(credentials: Credentials, roles: list[Role]) -> None:
    color_print([("#FFE4B5", "Select the role to remove")])
    role = prompt_role(roles)
    for i, o in enumerate(roles):
        if o.arn == role.arn:
            del roles[i]
            break
    persist(credentials, roles)
