# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_byteblower')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_byteblower')
    _byteblower = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_byteblower', [dirname(__file__)])
        except ImportError:
            import _byteblower
            return _byteblower
        try:
            _mod = imp.load_module('_byteblower', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _byteblower = swig_import_helper()
    del swig_import_helper
else:
    import _byteblower
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _byteblower.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _byteblower.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _byteblower.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _byteblower.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _byteblower.SwigPyIterator_equal(self, x)

    def copy(self):
        return _byteblower.SwigPyIterator_copy(self)

    def next(self):
        return _byteblower.SwigPyIterator_next(self)

    def __next__(self):
        return _byteblower.SwigPyIterator___next__(self)

    def previous(self):
        return _byteblower.SwigPyIterator_previous(self)

    def advance(self, n):
        return _byteblower.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _byteblower.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _byteblower.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _byteblower.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _byteblower.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _byteblower.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _byteblower.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _byteblower.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class ByteBlowerAPIException(Exception):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteBlowerAPIException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ByteBlowerAPIException, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _byteblower.new_ByteBlowerAPIException()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_ByteBlowerAPIException
    __del__ = lambda self: None

    def getPublicName(self):
        return _byteblower.ByteBlowerAPIException_getPublicName(self)

    def getInfo(self):
        return _byteblower.ByteBlowerAPIException_getInfo(self)

    def getMessage(self):
        return _byteblower.ByteBlowerAPIException_getMessage(self)

    def what(self):
        return _byteblower.ByteBlowerAPIException_what(self)

    def setServer(self, server):
        return _byteblower.ByteBlowerAPIException_setServer(self, server)

    def setPublicName(self, name):
        return _byteblower.ByteBlowerAPIException_setPublicName(self, name)

    def setPrivateName(self, name):
        return _byteblower.ByteBlowerAPIException_setPrivateName(self, name)

    def setInfo(self, info):
        return _byteblower.ByteBlowerAPIException_setInfo(self, info)
ByteBlowerAPIException_swigregister = _byteblower.ByteBlowerAPIException_swigregister
ByteBlowerAPIException_swigregister(ByteBlowerAPIException)


def Demangle(inName):
    return _byteblower.Demangle(inName)
Demangle = _byteblower.Demangle
class TechnicalError(ByteBlowerAPIException):
    __swig_setmethods__ = {}
    for _s in [ByteBlowerAPIException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TechnicalError, name, value)
    __swig_getmethods__ = {}
    for _s in [ByteBlowerAPIException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TechnicalError, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_TechnicalError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_TechnicalError
    __del__ = lambda self: None
TechnicalError_swigregister = _byteblower.TechnicalError_swigregister
TechnicalError_swigregister(TechnicalError)

class DomainError(ByteBlowerAPIException):
    __swig_setmethods__ = {}
    for _s in [ByteBlowerAPIException]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DomainError, name, value)
    __swig_getmethods__ = {}
    for _s in [ByteBlowerAPIException]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DomainError, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_DomainError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_DomainError
    __del__ = lambda self: None
DomainError_swigregister = _byteblower.DomainError_swigregister
DomainError_swigregister(DomainError)

class ConfigError(DomainError):
    __swig_setmethods__ = {}
    for _s in [DomainError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ConfigError, name, value)
    __swig_getmethods__ = {}
    for _s in [DomainError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ConfigError, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_ConfigError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_ConfigError
    __del__ = lambda self: None
ConfigError_swigregister = _byteblower.ConfigError_swigregister
ConfigError_swigregister(ConfigError)

class InitializationError(DomainError):
    __swig_setmethods__ = {}
    for _s in [DomainError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InitializationError, name, value)
    __swig_getmethods__ = {}
    for _s in [DomainError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InitializationError, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_InitializationError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_InitializationError
    __del__ = lambda self: None
InitializationError_swigregister = _byteblower.InitializationError_swigregister
InitializationError_swigregister(InitializationError)

class InProgressError(DomainError):
    __swig_setmethods__ = {}
    for _s in [DomainError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InProgressError, name, value)
    __swig_getmethods__ = {}
    for _s in [DomainError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InProgressError, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_InProgressError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_InProgressError
    __del__ = lambda self: None
InProgressError_swigregister = _byteblower.InProgressError_swigregister
InProgressError_swigregister(InProgressError)

class AddressResolutionFailed(InitializationError):
    __swig_setmethods__ = {}
    for _s in [InitializationError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AddressResolutionFailed, name, value)
    __swig_getmethods__ = {}
    for _s in [InitializationError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AddressResolutionFailed, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_AddressResolutionFailed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_AddressResolutionFailed
    __del__ = lambda self: None
AddressResolutionFailed_swigregister = _byteblower.AddressResolutionFailed_swigregister
AddressResolutionFailed_swigregister(AddressResolutionFailed)

class DHCPFailed(InitializationError):
    __swig_setmethods__ = {}
    for _s in [InitializationError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DHCPFailed, name, value)
    __swig_getmethods__ = {}
    for _s in [InitializationError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DHCPFailed, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_DHCPFailed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_DHCPFailed
    __del__ = lambda self: None
DHCPFailed_swigregister = _byteblower.DHCPFailed_swigregister
DHCPFailed_swigregister(DHCPFailed)

class RouterRequired(InitializationError):
    __swig_setmethods__ = {}
    for _s in [InitializationError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RouterRequired, name, value)
    __swig_getmethods__ = {}
    for _s in [InitializationError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RouterRequired, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_RouterRequired(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_RouterRequired
    __del__ = lambda self: None
RouterRequired_swigregister = _byteblower.RouterRequired_swigregister
RouterRequired_swigregister(RouterRequired)

class RouterSolicitationFailed(InitializationError):
    __swig_setmethods__ = {}
    for _s in [InitializationError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RouterSolicitationFailed, name, value)
    __swig_getmethods__ = {}
    for _s in [InitializationError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RouterSolicitationFailed, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_RouterSolicitationFailed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_RouterSolicitationFailed
    __del__ = lambda self: None
RouterSolicitationFailed_swigregister = _byteblower.RouterSolicitationFailed_swigregister
RouterSolicitationFailed_swigregister(RouterSolicitationFailed)

class TCPAlreadyConnected(InitializationError):
    __swig_setmethods__ = {}
    for _s in [InitializationError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TCPAlreadyConnected, name, value)
    __swig_getmethods__ = {}
    for _s in [InitializationError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TCPAlreadyConnected, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_TCPAlreadyConnected(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_TCPAlreadyConnected
    __del__ = lambda self: None
TCPAlreadyConnected_swigregister = _byteblower.TCPAlreadyConnected_swigregister
TCPAlreadyConnected_swigregister(TCPAlreadyConnected)

class TCPConnectionRefused(InitializationError):
    __swig_setmethods__ = {}
    for _s in [InitializationError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TCPConnectionRefused, name, value)
    __swig_getmethods__ = {}
    for _s in [InitializationError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TCPConnectionRefused, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_TCPConnectionRefused(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_TCPConnectionRefused
    __del__ = lambda self: None
TCPConnectionRefused_swigregister = _byteblower.TCPConnectionRefused_swigregister
TCPConnectionRefused_swigregister(TCPConnectionRefused)

class TCPConnectionTimout(InitializationError):
    __swig_setmethods__ = {}
    for _s in [InitializationError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TCPConnectionTimout, name, value)
    __swig_getmethods__ = {}
    for _s in [InitializationError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TCPConnectionTimout, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_TCPConnectionTimout(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_TCPConnectionTimout
    __del__ = lambda self: None
TCPConnectionTimout_swigregister = _byteblower.TCPConnectionTimout_swigregister
TCPConnectionTimout_swigregister(TCPConnectionTimout)

class TCPConnectionResetByPeer(DomainError):
    __swig_setmethods__ = {}
    for _s in [DomainError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TCPConnectionResetByPeer, name, value)
    __swig_getmethods__ = {}
    for _s in [DomainError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TCPConnectionResetByPeer, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_TCPConnectionResetByPeer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_TCPConnectionResetByPeer
    __del__ = lambda self: None
TCPConnectionResetByPeer_swigregister = _byteblower.TCPConnectionResetByPeer_swigregister
TCPConnectionResetByPeer_swigregister(TCPConnectionResetByPeer)

class TCPConnectionAborted(DomainError):
    __swig_setmethods__ = {}
    for _s in [DomainError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TCPConnectionAborted, name, value)
    __swig_getmethods__ = {}
    for _s in [DomainError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TCPConnectionAborted, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_TCPConnectionAborted(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_TCPConnectionAborted
    __del__ = lambda self: None
TCPConnectionAborted_swigregister = _byteblower.TCPConnectionAborted_swigregister
TCPConnectionAborted_swigregister(TCPConnectionAborted)

class PortNumberAlreadyUsed(ConfigError):
    __swig_setmethods__ = {}
    for _s in [ConfigError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PortNumberAlreadyUsed, name, value)
    __swig_getmethods__ = {}
    for _s in [ConfigError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PortNumberAlreadyUsed, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_PortNumberAlreadyUsed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_PortNumberAlreadyUsed
    __del__ = lambda self: None
PortNumberAlreadyUsed_swigregister = _byteblower.PortNumberAlreadyUsed_swigregister
PortNumberAlreadyUsed_swigregister(PortNumberAlreadyUsed)

class ByteBlowerServerUnreachable(DomainError):
    __swig_setmethods__ = {}
    for _s in [DomainError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteBlowerServerUnreachable, name, value)
    __swig_getmethods__ = {}
    for _s in [DomainError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ByteBlowerServerUnreachable, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_ByteBlowerServerUnreachable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_ByteBlowerServerUnreachable
    __del__ = lambda self: None
ByteBlowerServerUnreachable_swigregister = _byteblower.ByteBlowerServerUnreachable_swigregister
ByteBlowerServerUnreachable_swigregister(ByteBlowerServerUnreachable)

class MeetingPointUnreachable(DomainError):
    __swig_setmethods__ = {}
    for _s in [DomainError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MeetingPointUnreachable, name, value)
    __swig_getmethods__ = {}
    for _s in [DomainError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MeetingPointUnreachable, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_MeetingPointUnreachable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_MeetingPointUnreachable
    __del__ = lambda self: None
MeetingPointUnreachable_swigregister = _byteblower.MeetingPointUnreachable_swigregister
MeetingPointUnreachable_swigregister(MeetingPointUnreachable)

class ByteBlowerServerIncompatible(DomainError):
    __swig_setmethods__ = {}
    for _s in [DomainError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteBlowerServerIncompatible, name, value)
    __swig_getmethods__ = {}
    for _s in [DomainError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ByteBlowerServerIncompatible, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_ByteBlowerServerIncompatible(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_ByteBlowerServerIncompatible
    __del__ = lambda self: None
ByteBlowerServerIncompatible_swigregister = _byteblower.ByteBlowerServerIncompatible_swigregister
ByteBlowerServerIncompatible_swigregister(ByteBlowerServerIncompatible)

class UnsupportedFeature(DomainError):
    __swig_setmethods__ = {}
    for _s in [DomainError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UnsupportedFeature, name, value)
    __swig_getmethods__ = {}
    for _s in [DomainError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UnsupportedFeature, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_UnsupportedFeature(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_UnsupportedFeature
    __del__ = lambda self: None
UnsupportedFeature_swigregister = _byteblower.UnsupportedFeature_swigregister
UnsupportedFeature_swigregister(UnsupportedFeature)

class ResponseTimeout(DomainError):
    __swig_setmethods__ = {}
    for _s in [DomainError]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ResponseTimeout, name, value)
    __swig_getmethods__ = {}
    for _s in [DomainError]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ResponseTimeout, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_ResponseTimeout(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_ResponseTimeout
    __del__ = lambda self: None
ResponseTimeout_swigregister = _byteblower.ResponseTimeout_swigregister
ResponseTimeout_swigregister(ResponseTimeout)

EXCENTIS_ARCHLIB_HAVE_COMPAT_WARNINGS = _byteblower.EXCENTIS_ARCHLIB_HAVE_COMPAT_WARNINGS
EXCENTIS_COMPAT_HAS_CXX0X = _byteblower.EXCENTIS_COMPAT_HAS_CXX0X
EXCENTIS_COMPAT_HAS_CPP0X = _byteblower.EXCENTIS_COMPAT_HAS_CPP0X
EXCENTIS_COMPAT_HAS_CXX11 = _byteblower.EXCENTIS_COMPAT_HAS_CXX11
class DataSize(_object):
    """

    Represents a data size.  The DataSize can be expressed in multiple formats.

    Example

    TODO


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataSize, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataSize, name)
    __repr__ = _swig_repr

    def __init__(self, bytes):
        this = _byteblower.new_DataSize(bytes)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def BytesGet(self):
        """


        :return: The size in bytes
        :rtype: long

        Example

        TODO

        """
        return _byteblower.DataSize_BytesGet(self)


    def KibiBytesGet(self):
        """


        :return: The size in kibibytes
        :rtype: long

        Example

        TODO

        """
        return _byteblower.DataSize_KibiBytesGet(self)


    def MebiBytesGet(self):
        """


        :return: The size in mebibytes
        :rtype: long

        Example

        TODO

        """
        return _byteblower.DataSize_MebiBytesGet(self)


    def GibiBytesGet(self):
        """


        :return: The size in gibibytes
        :rtype: long


        Example

        TODO


        """
        return _byteblower.DataSize_GibiBytesGet(self)


    def toString(self):
        """



        :return: A human readable format of the size
        :rtype: str

        Example

        TODO

        """
        return _byteblower.DataSize_toString(self)

    __swig_destroy__ = _byteblower.delete_DataSize
    __del__ = lambda self: None
DataSize_swigregister = _byteblower.DataSize_swigregister
DataSize_swigregister(DataSize)
cvar = _byteblower.cvar
MAX_U_INT16 = cvar.MAX_U_INT16
MAX_U_INT32 = cvar.MAX_U_INT32
MAX_U_INT64 = cvar.MAX_U_INT64
MAX_INT16 = cvar.MAX_INT16
MAX_INT32 = cvar.MAX_INT32
MAX_INT64 = cvar.MAX_INT64

class Duration(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Duration, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Duration, name)
    __repr__ = _swig_repr

    def __init__(self, ns):
        this = _byteblower.new_Duration(ns)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NanosecondsGet(self):
        return _byteblower.Duration_NanosecondsGet(self)

    def MicrosecondsGet(self):
        return _byteblower.Duration_MicrosecondsGet(self)

    def MillisecondsGet(self):
        return _byteblower.Duration_MillisecondsGet(self)

    def SecondsGet(self):
        return _byteblower.Duration_SecondsGet(self)

    def toString(self):
        return _byteblower.Duration_toString(self)
    __swig_destroy__ = _byteblower.delete_Duration
    __del__ = lambda self: None
Duration_swigregister = _byteblower.Duration_swigregister
Duration_swigregister(Duration)

ResultDataType_Cumulative = _byteblower.ResultDataType_Cumulative
ResultDataType_Interval = _byteblower.ResultDataType_Interval
class DataRate(_object):
    """

    Represents a data rate.  The datarate can be expressed in multiple formats.

    Example

    .. code-block:: python

       httpResultData = httpClient.ResultHistoryGet().CumulativeLatestGet()
       dataRate = httpResultData.RxByteCountRateGet()


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataRate, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataRate, name)
    __repr__ = _swig_repr

    def __init__(self, inSize, inDuration):
        this = _byteblower.new_DataRate(inSize, inDuration)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def toString(self):
        """

        Returns the bytes per second in a readable string format

        :return: A human readable format of the speed
        :rtype: str

        Example
        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.toString())


        """
        return _byteblower.DataRate_toString(self)


    def ByteRateGet(self):
        """

        Returns the bytes per second of the http session

        :return: The speed in bytes per second
        :rtype: long


        Example
        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.ByteRateGet())


        """
        return _byteblower.DataRate_ByteRateGet(self)


    def BitRateGet(self):
        """

        Returns the bits per second of the http session

        :return: The speed in bits per second
        :rtype: long

        Example
        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.BitRateGet())


        """
        return _byteblower.DataRate_BitRateGet(self)


    def KbpsGet(self):
        """

        Returns the kilobits per second of the http session

        :return: The speed in kilobits per second
        :rtype: long

        Example
        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.KbpsGet())


        """
        return _byteblower.DataRate_KbpsGet(self)


    def MbpsGet(self):
        """

        Returns the megabits per second of the http session

        :return: The speed in megabits per second
        :rtype: long

        Example
        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.MbpsGet())


        """
        return _byteblower.DataRate_MbpsGet(self)


    def GbpsGet(self):
        """

        Returns the gigabits per second of the http session

        :return: The speed in gigabits per second
        :rtype: long

        Example
        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.GbpsGet())


        """
        return _byteblower.DataRate_GbpsGet(self)


    def bitrate(self):
        """


        .. deprecated: 2.x
           Use :meth:`BitRateGet` instead

        :return: The speed in bits per second
        :rtype: long

        Example
        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.bitrate())


        """
        return _byteblower.DataRate_bitrate(self)


    def byterate(self):
        """


        .. deprecated: 2.x
           Use :meth:`ByteRateGet` instead

        :return: The speed in bytes per second
        :rtype: long

        Example
        .. code-block:: python
           :emphasize-lines: 1

           print(dataRate.byterate())


        """
        return _byteblower.DataRate_byterate(self)

    __swig_destroy__ = _byteblower.delete_DataRate
    __del__ = lambda self: None
DataRate_swigregister = _byteblower.DataRate_swigregister
DataRate_swigregister(DataRate)

FrameTagType_TimeStamp = _byteblower.FrameTagType_TimeStamp
FrameTagType_SequenceNumber = _byteblower.FrameTagType_SequenceNumber
TimeStampFormat_Microseconds = _byteblower.TimeStampFormat_Microseconds
TimeStampFormat_Microseconds_CRC = _byteblower.TimeStampFormat_Microseconds_CRC
TimeStampFormat_TenNanoseconds = _byteblower.TimeStampFormat_TenNanoseconds
SequenceNumberFormat_SequenceNumber_0 = _byteblower.SequenceNumberFormat_SequenceNumber_0
SequenceNumberFormat_SequenceNumber_0_CRC = _byteblower.SequenceNumberFormat_SequenceNumber_0_CRC
LinkStatus_Offline = _byteblower.LinkStatus_Offline
LinkStatus_Online = _byteblower.LinkStatus_Online
LinkStatus_Unplugged = _byteblower.LinkStatus_Unplugged
LinkStatus_Unknown = _byteblower.LinkStatus_Unknown

def ConvertLinkStatusToString(inLinkStatus):
    return _byteblower.ConvertLinkStatusToString(inLinkStatus)
ConvertLinkStatusToString = _byteblower.ConvertLinkStatusToString

def ParseLinkStatus(arg1):
    return _byteblower.ParseLinkStatus(arg1)
ParseLinkStatus = _byteblower.ParseLinkStatus
LinkType_Ethernet = _byteblower.LinkType_Ethernet
LinkType_USB = _byteblower.LinkType_USB

def ConvertLinkTypeToString(inLinkType):
    return _byteblower.ConvertLinkTypeToString(inLinkType)
ConvertLinkTypeToString = _byteblower.ConvertLinkTypeToString

def ParseLinkType(arg1):
    return _byteblower.ParseLinkType(arg1)
ParseLinkType = _byteblower.ParseLinkType
PhysicalInterfaceType_Trunk = _byteblower.PhysicalInterfaceType_Trunk
PhysicalInterfaceType_NonTrunk = _byteblower.PhysicalInterfaceType_NonTrunk
PhysicalInterfaceType_NonTrunkUSB = _byteblower.PhysicalInterfaceType_NonTrunkUSB

def ConvertPhysicalInterfaceTypeToString(inType):
    return _byteblower.ConvertPhysicalInterfaceTypeToString(inType)
ConvertPhysicalInterfaceTypeToString = _byteblower.ConvertPhysicalInterfaceTypeToString

def ParsePhysicalInterfaceType(inString):
    return _byteblower.ParsePhysicalInterfaceType(inString)
ParsePhysicalInterfaceType = _byteblower.ParsePhysicalInterfaceType
IGMPVersion_IGMPv1 = _byteblower.IGMPVersion_IGMPv1
IGMPVersion_IGMPv2 = _byteblower.IGMPVersion_IGMPv2
IGMPVersion_IGMPv3 = _byteblower.IGMPVersion_IGMPv3

def ParseIGMPVersion(inIGMPVersion):
    return _byteblower.ParseIGMPVersion(inIGMPVersion)
ParseIGMPVersion = _byteblower.ParseIGMPVersion

def IGMPVersionToString(inIGMPVersion):
    return _byteblower.IGMPVersionToString(inIGMPVersion)
IGMPVersionToString = _byteblower.IGMPVersionToString
MLDVersion_MLDv1 = _byteblower.MLDVersion_MLDv1
MLDVersion_MLDv2 = _byteblower.MLDVersion_MLDv2

def ParseMLDVersion(inMLDVersion):
    return _byteblower.ParseMLDVersion(inMLDVersion)
ParseMLDVersion = _byteblower.ParseMLDVersion

def MLDVersionToString(inMLDVersion):
    return _byteblower.MLDVersionToString(inMLDVersion)
MLDVersionToString = _byteblower.MLDVersionToString
MulticastSourceFilter_Exclude = _byteblower.MulticastSourceFilter_Exclude
MulticastSourceFilter_Include = _byteblower.MulticastSourceFilter_Include

def ParseMulticastFilter(inMulticastFilter):
    return _byteblower.ParseMulticastFilter(inMulticastFilter)
ParseMulticastFilter = _byteblower.ParseMulticastFilter

def MulticastFilterToString(inMulticastFilter):
    return _byteblower.MulticastFilterToString(inMulticastFilter)
MulticastFilterToString = _byteblower.MulticastFilterToString
RetransmissionPolicy_Unknown = _byteblower.RetransmissionPolicy_Unknown
RetransmissionPolicy_RfcSuggested = _byteblower.RetransmissionPolicy_RfcSuggested
RetransmissionPolicy_FixedTiming = _byteblower.RetransmissionPolicy_FixedTiming
TimeUnit_Seconds = _byteblower.TimeUnit_Seconds
TimeUnit_Milliseconds = _byteblower.TimeUnit_Milliseconds
TimeUnit_Microseconds = _byteblower.TimeUnit_Microseconds
TimeUnit_Nanoseconds = _byteblower.TimeUnit_Nanoseconds

def ConvertTimeUnitToString(inTimeUnit):
    return _byteblower.ConvertTimeUnitToString(inTimeUnit)
ConvertTimeUnitToString = _byteblower.ConvertTimeUnitToString

def ParseTimeUnitFromString(arg1):
    return _byteblower.ParseTimeUnitFromString(arg1)
ParseTimeUnitFromString = _byteblower.ParseTimeUnitFromString

def ToNanoseconds(unit):
    return _byteblower.ToNanoseconds(unit)
ToNanoseconds = _byteblower.ToNanoseconds
DescriptionFormat_PlainText = _byteblower.DescriptionFormat_PlainText
class AbstractObject(_object):
    """

    Base class for most of the ByteBlowerobjects

    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AbstractObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AbstractObject, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def ParentGet(self):
        """

        Returns the parent object.

        """
        return _byteblower.AbstractObject_ParentGet(self)


    def DescriptionGet(self, *args):
        """

        Gets a textual description for the current object

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # ...
           # :return: TODO



        Gets a textual description for the current object

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # ...
           # :return: TODO


        """
        return _byteblower.AbstractObject_DescriptionGet(self, *args)


    def Refresh(self):
        """

        Retrieves the latest data from the server for this object.

        """
        return _byteblower.AbstractObject_Refresh(self)

AbstractObject_swigregister = _byteblower.AbstractObject_swigregister
AbstractObject_swigregister(AbstractObject)

class AbstractRefreshableResult(AbstractObject):
    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AbstractRefreshableResult, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AbstractRefreshableResult, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_AbstractRefreshableResult
    __del__ = lambda self: None
AbstractRefreshableResult_swigregister = _byteblower.AbstractRefreshableResult_swigregister
AbstractRefreshableResult_swigregister(AbstractRefreshableResult)

class ByteBlowerInterface(AbstractObject):
    """


    Example

    .. code-block:: python

    	interface = bbServer.InterfaceGetByName('trunk-1-14')
        packetDump = interface.PacketDumpCreate()


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteBlowerInterface, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ByteBlowerInterface, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetPhysicalInterface(self):
        return _byteblower.ByteBlowerInterface_GetPhysicalInterface(self)

    def NameGet(self):
        """

        Returns the name of the ByteBlower Interface 

        :return: Name of the ByteBlower Interface
        :rtype: str  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

            print(interface.NameGet())


        """
        return _byteblower.ByteBlowerInterface_NameGet(self)


    def SpeedGet(self):
        """



        :return: TODO??
        :rtype: long

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(interface.SpeedGet())


        """
        return _byteblower.ByteBlowerInterface_SpeedGet(self)


    def PortIdGet(self):
        """



        :return: The id of the first ByteBlower port on this interface

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(interface.PortIdGet())


        """
        return _byteblower.ByteBlowerInterface_PortIdGet(self)


    def PortCountGet(self):
        """



        :return: number of ports on this ByteBlowerInterface
        :rtype: long

        Example

        .. code-block:: python
        	:emphasize-lines: 1

            print(interface.PortCountGet())


        """
        return _byteblower.ByteBlowerInterface_PortCountGet(self)


    def PortGet(self):
        """



        :return: A list of ByteBlower ports on this interface
        :rtype: ByteBlowerPortList

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	portList = interface.PortGet()


        """
        return _byteblower.ByteBlowerInterface_PortGet(self)


    def PortCreate(self):
        """


        Creates a new ByteBlower port on this ByteBlowerInterface.  

        :return: ByteBlowerPort
        :rtype: unknown

        Example

        .. code-block:: python
        	:emphasize-lines: 1

            port = interface.PortCreate()


        """
        return _byteblower.ByteBlowerInterface_PortCreate(self)


    def PortDestroy(self, inPort):
        """


        :param port: ByteBlowerPort object that you want to destroy from the interface`.  


        Example

        .. code-block:: python
        	:emphasize-lines: 1

           interface.PortDestroy(port)


        """
        return _byteblower.ByteBlowerInterface_PortDestroy(self, inPort)


    def PacketDumpCreate(self):
        """



        :return: returns a PacketDump object
        :rtype: PacketDump

        Example

        .. code-block:: python
           :emphasize-lines: 1

            packetDump = interface.PacketDumpCreate()


        """
        return _byteblower.ByteBlowerInterface_PacketDumpCreate(self)


    def PacketDumpDestroy(self, packet_dump):
        """


        Destroys a PacketDump on this interface
        :param: PacketDump object that you want to destroy from the interface`.  
        Example

        .. code-block:: python
           :emphasize-lines: 1

        	packetDump = interface.PacketDumpCreate()
            interface.PacketDumpDestroy(packetDump)


        """
        return _byteblower.ByteBlowerInterface_PacketDumpDestroy(self, packet_dump)


    def SwitchIdGet(self):
        """

        Returns the ID of the switch where the ByteBlower Interface ?? Deprecated??

        :return: Id of the switch where the ByteBlower Interface is connected
        :rtype: int

        Example

        .. code-block:: python
        	:emphasize-lines: 1



        """
        return _byteblower.ByteBlowerInterface_SwitchIdGet(self)

ByteBlowerInterface_swigregister = _byteblower.ByteBlowerInterface_swigregister
ByteBlowerInterface_swigregister(ByteBlowerInterface)

class ByteBlower(AbstractObject):
    """

    Singleton class that is the entry point to start using the ByteBlower API.  

    Typically, this is the first class you will use when writing a ByteBlower test 
    script. Use this class to connect to ByteBlower servers, to start or stop all 
    configured ByteBlower ports across those servers, and to control the logging 
    behavior.

    Retrieve the singleton ByteBlower *object* using the static method 
    :meth:`InstanceGet`.

    This class contains some static convenience methods. 
    They are wrappers around the corresponding non-static methods of the singleton 
    object.  


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteBlower, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ByteBlower, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    DefaultTimeout = _byteblower.ByteBlower_DefaultTimeout

    def InstanceGet():
        """

        Creates or returns the ByteBlower API singleton instance.  

        This object is the entry point to start working with the ByteBlower Python API.  

        If no ByteBlower instance is created yet, this method creates one and returns the object. If the instance exists already, it is simply returned.
        Any other static call will implicitly instantiate this singleton object.  

        :return:  ByteBlower singleton instance.  

        Example

        .. code-block:: python

           instance = bb.InstanceGet()


        """
        return _byteblower.ByteBlower_InstanceGet()

    InstanceGet = staticmethod(InstanceGet)

    def APIVersionGet(self):
        """

        Returns the version of the API.  

        .. versionadded:: 2.6.0  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(bb.APIVersionGet())
           # returns 2.10.0


        """
        return _byteblower.ByteBlower_APIVersionGet(self)


    def ServerAdd(self, *args):
        """

        Opens a connection to a ByteBlower server and adds it to the current API instance.  

        A single client instance may be connected to multiple ByteBlower servers. This
        allows to use a set of ByteBlower servers as a single system. On the other 
        hand, multiple client instances may be connected to a single (shared) 
        ByteBlower server and will share its resources. See :class:`.ByteBlowerServer` for more 
        information.  

        :param server: IP address or hostname of the ByteBlower server to connect.
        :param port: Remote TCP port on which to connect the ByteBlower server. Should 
                     normally never be overridden.  Default: `9002`  

        :return:  A :class:`.ByteBlowerServer` object that represents the server connection.  

        :raises: :exc:`.ByteBlowerServerUnreachable`: When the ByteBlower server daemon
                 could not be reached. Typical causes are an incorrect  or unreachable
                 DNS name or IP address or a ByteBlower server daemon that is not 
                 running (on purpose or due to a software issue). 

        :raises: :exc:`.ByteBlowerServerIncompatible` When the ByteBlower server daemon is running an incompatible version.  

        :raises: <python_error>: Relevant network error: When something unexpectedly 
                 went wrong with the network connection.  

        :raises: :exc:`NotImplementedError` When the *<port>* parameter is provided and
                 is no integer.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example connects to the server 'byteblower-1.lab.byteblower.com

           bb = bb.ServerAdd('byteblower-1.lab.byteblower.com')



        Opens a connection to a ByteBlower server and adds it to the current API instance.  

        A single client instance may be connected to multiple ByteBlower servers. This
        allows to use a set of ByteBlower servers as a single system. On the other 
        hand, multiple client instances may be connected to a single (shared) 
        ByteBlower server and will share its resources. See :class:`.ByteBlowerServer` for more 
        information.  

        :param server: IP address or hostname of the ByteBlower server to connect.
        :param port: Remote TCP port on which to connect the ByteBlower server. Should 
                     normally never be overridden.  Default: `9002`  

        :return:  A :class:`.ByteBlowerServer` object that represents the server connection.  

        :raises: :exc:`.ByteBlowerServerUnreachable`: When the ByteBlower server daemon
                 could not be reached. Typical causes are an incorrect  or unreachable
                 DNS name or IP address or a ByteBlower server daemon that is not 
                 running (on purpose or due to a software issue). 

        :raises: :exc:`.ByteBlowerServerIncompatible` When the ByteBlower server daemon is running an incompatible version.  

        :raises: <python_error>: Relevant network error: When something unexpectedly 
                 went wrong with the network connection.  

        :raises: :exc:`NotImplementedError` When the *<port>* parameter is provided and
                 is no integer.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example connects to the server 'byteblower-1.lab.byteblower.com

           bb = bb.ServerAdd('byteblower-1.lab.byteblower.com')



        Opens a connection to a ByteBlower server and adds it to the current API instance.  

        A single client instance may be connected to multiple ByteBlower servers. This
        allows to use a set of ByteBlower servers as a single system. On the other 
        hand, multiple client instances may be connected to a single (shared) 
        ByteBlower server and will share its resources. See :class:`.ByteBlowerServer` for more 
        information.  

        :param server: IP address or hostname of the ByteBlower server to connect.
        :param port: Remote TCP port on which to connect the ByteBlower server. Should 
                     normally never be overridden.  Default: `9002`  

        :return:  A :class:`.ByteBlowerServer` object that represents the server connection.  

        :raises: :exc:`.ByteBlowerServerUnreachable`: When the ByteBlower server daemon
                 could not be reached. Typical causes are an incorrect  or unreachable
                 DNS name or IP address or a ByteBlower server daemon that is not 
                 running (on purpose or due to a software issue). 

        :raises: :exc:`.ByteBlowerServerIncompatible` When the ByteBlower server daemon is running an incompatible version.  

        :raises: <python_error>: Relevant network error: When something unexpectedly 
                 went wrong with the network connection.  

        :raises: :exc:`NotImplementedError` When the *<port>* parameter is provided and
                 is no integer.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example connects to the server 'byteblower-1.lab.byteblower.com

           bb = bb.ServerAdd('byteblower-1.lab.byteblower.com')


        """
        return _byteblower.ByteBlower_ServerAdd(self, *args)


    def ServerGet(self):
        """

        Returns all server connections within this API instance.  

        See :meth:`ServerAdd` for more information.  

        :return: a :class:`.ByteBlowerServerList` object

        Example

        .. code-block:: python
        	:emphasize-lines: 1
             server = bb.ServerGet()


        """
        return _byteblower.ByteBlower_ServerGet(self)


    def ServerRemove(self, inByteBlowerServer):
        return _byteblower.ByteBlower_ServerRemove(self, inByteBlowerServer)

    def ServerRemoveAll(self):
        return _byteblower.ByteBlower_ServerRemoveAll(self)

    def MeetingPointAdd(self, *args):
        """

        Opens a connection to a :class:`.MeetingPoint` and adds it to the current API instance.  

        A single client instance may be connected to multiple MeetingPoint servers. 
        This allows to use a set of Meeting point servers as a single system. On the 
        other hand, multiple client instances may be connected to a single (shared) 
        MeetingPoint server and will share its resources. See MeetingPoint for more 
        information.  

        .. versionadded:: 2.6.0  

        :param server: IP address or hostname of the MeetingPoint server to connect.  
        :param port: Remote TCP port on which to connect the MeetingPoint server. 
                     Should normally never be overridden. Default: `9101`  

        :return: A MeetingPoint object that represents the server connection.  

        :raises: :exc:`.MeetingPointUnreachable` - When the  MeetingPoint server daemon
                 could not be reached. 
                 Typical causes are an incorrect or unreachable DNS name or IP address or a MeetingPoint server daemon that
                 is not running (on purpose or due to a software  issue).  
        :raises: <python_error> - Relevant network error: When something unexpectedly 
                 went wrong with the network connection.  
        :raises: :exc:`NotImplementedError` - When the *<port>* 
                 parameter is provided and is no integer.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	bb.MeetingPointAdd('byteblower-1.lab.byteblower.com')



        Opens a connection to a :class:`.MeetingPoint` and adds it to the current API instance.  

        A single client instance may be connected to multiple MeetingPoint servers. 
        This allows to use a set of Meeting point servers as a single system. On the 
        other hand, multiple client instances may be connected to a single (shared) 
        MeetingPoint server and will share its resources. See MeetingPoint for more 
        information.  

        .. versionadded:: 2.6.0  

        :param server: IP address or hostname of the MeetingPoint server to connect.  
        :param port: Remote TCP port on which to connect the MeetingPoint server. 
                     Should normally never be overridden. Default: `9101`  

        :return: A MeetingPoint object that represents the server connection.  

        :raises: :exc:`.MeetingPointUnreachable` - When the  MeetingPoint server daemon
                 could not be reached. 
                 Typical causes are an incorrect or unreachable DNS name or IP address or a MeetingPoint server daemon that
                 is not running (on purpose or due to a software  issue).  
        :raises: <python_error> - Relevant network error: When something unexpectedly 
                 went wrong with the network connection.  
        :raises: :exc:`NotImplementedError` - When the *<port>* 
                 parameter is provided and is no integer.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	bb.MeetingPointAdd('byteblower-1.lab.byteblower.com')



        Opens a connection to a :class:`.MeetingPoint` and adds it to the current API instance.  

        A single client instance may be connected to multiple MeetingPoint servers. 
        This allows to use a set of Meeting point servers as a single system. On the 
        other hand, multiple client instances may be connected to a single (shared) 
        MeetingPoint server and will share its resources. See MeetingPoint for more 
        information.  

        .. versionadded:: 2.6.0  

        :param server: IP address or hostname of the MeetingPoint server to connect.  
        :param port: Remote TCP port on which to connect the MeetingPoint server. 
                     Should normally never be overridden. Default: `9101`  

        :return: A MeetingPoint object that represents the server connection.  

        :raises: :exc:`.MeetingPointUnreachable` - When the  MeetingPoint server daemon
                 could not be reached. 
                 Typical causes are an incorrect or unreachable DNS name or IP address or a MeetingPoint server daemon that
                 is not running (on purpose or due to a software  issue).  
        :raises: <python_error> - Relevant network error: When something unexpectedly 
                 went wrong with the network connection.  
        :raises: :exc:`NotImplementedError` - When the *<port>* 
                 parameter is provided and is no integer.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	bb.MeetingPointAdd('byteblower-1.lab.byteblower.com')


        """
        return _byteblower.ByteBlower_MeetingPointAdd(self, *args)


    def MeetingPointGet(self):
        """

        Returns all Meeting Point connections within this API instance.  

        See :meth:`MeetingPointAdd` for more information  

        .. versionadded:: 2.6.0  

        :return: :class:`.MeetingPointList` with objects created within this API 
                 instance. Can be empty  

        Example

        .. code-block:: python

           meetingPoint = bb.MeetingPointGet()


        """
        return _byteblower.ByteBlower_MeetingPointGet(self)


    def MeetingPointRemove(self, inMeetingPoint):
        return _byteblower.ByteBlower_MeetingPointRemove(self, inMeetingPoint)

    def MeetingPointRemoveAll(self):
        return _byteblower.ByteBlower_MeetingPointRemoveAll(self)

    def ServerCount(self):
        return _byteblower.ByteBlower_ServerCount(self)

    def PortsStart(self, inPorts):
        """

        Starts all traffic streams and application schedules on the specified ByteBlower ports.  

        More specifically, for each traffic stream and schedulable object on the specified ports, the configured *time to wait* kicks off and when this time has passed the corresponding action is performed.  

        Typical actions include starting a traffic stream or sending out a multicast join message or HTTP request. See :class:`.Stream` and :meth:`SchedulesStart` for more information.  

        Streams or schedulable objects that are already scheduled and streams that are already active are ignored. Schedulable objects that are already stopped are scheduled again. See :meth:`SchedulesStart` for more information.  

        If a port does not contain any streams or schedules, nothing happens for that port.   

        :param ports: :class:`.ByteBlowerPortList`

        :raises: ByteBlower.Exception.InvalidValue.NotAnObject - When one of the items in *<ports>* is no object identifier.  
        :raises: ByteBlower.Exception.InvalidValue.ObjectType - When one of the items in *<ports>* is no ByteBlowerPort object.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	bb.PortsStart()



        """
        return _byteblower.ByteBlower_PortsStart(self, inPorts)


    def PortsStop(self, inPorts):
        """

        Stops all traffic streams and application schedules on the specified ByteBlower ports.  

        More specifically, all traffic streams and schedulable objects that are currently scheduled are cancelled and all active traffic streams are stopped. Since schedulable objects are only active for an instant, aborting these is not possible.  

        For more information about schedulable objects, see :meth:`SchedulesStart`.  

        Streams and schedules that are not running are ignored. This may be because they have not yet started or because they are already finished or stopped.  

        If a port does not contain any streams or schedules, nothing happens for that port.  

        :param args:  Zero, one or more ByteBlowerPort objects on which to abort traffic streams and application schedules.  

        :raises: ByteBlower.Exception.InvalidValue.NotAnObject -  When one of the items in *<ports>* is no object identifier.  
        :raises: ByteBlower.Exception.InvalidValue.ObjectType - When one of the items in *<ports>* is no ByteBlowerPort object.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	bb.PortsStop()



        """
        return _byteblower.ByteBlower_PortsStop(self, inPorts)


    def PortsStartAll(self):
        return _byteblower.ByteBlower_PortsStartAll(self)

    def PortsStopAll(self):
        return _byteblower.ByteBlower_PortsStopAll(self)

    def WirelessEndpointsStart(self, inWirelessEndpoints):
        """

        Starts all traffic streams and application schedules on the specified Wireless Endpoints.  

        More specifically, for each traffic stream and trigger object on the specified 
        endpoints, the configured *time to wait* kicks off and when this time has 
        passed the corresponding action is performed.  

        Typical actions include starting a traffic stream or HTTP request. See 
        :class:`.StreamMobile` for more information.  If a wireless endpoint does not 
        contain any streams or schedules, nothing happens for that Wireless Endpoint.  

        :param wirelessEndpoints: a :class:`.WirelessEndpointList` object with zero, one or more WirelessEndpoint objects on which to start traffic streams and application schedules.  

        :raises: ByteBlower.Exception.InvalidValue.NotAnObject - When one of the items in *<wirelessEndpoints>* is no object identifier.  
        :raises: ByteBlower.Exception.InvalidValue.ObjectType - When one of the items in *<wirelessEndpoints>* is no WirelessEndpoint object.  
        :raises: :exc:`.TechnicalError` - When the items in *<wirelessEndpoints>* are spread across multiple MeetingPoints.  


        """
        return _byteblower.ByteBlower_WirelessEndpointsStart(self, inWirelessEndpoints)


    def WirelessEndpointsStartAndWait(self, inWirelessEndpoints):
        """

        Starts all traffic streams and application schedules on the specified Wireless Endpoints And waits until the devices are started.  

        More specifically, for each traffic stream and trigger object on the specified endpoints, the configured *time to wait* kicks off and when this time has passed the corresponding action is performed.  

        Typical actions include starting a traffic stream or HTTP request. See :class:`.StreamMobile` for more information.  

        If a wireless endpoint does not contain any streams or schedules, nothing happens for that Wireless Endpoint.  

        :param wireless_endpoints: Zero, one or more WirelessEndpont objects on which to start traffic streams and application schedules.  

        :raises: ByteBlower.Exception.InvalidValue.NotAnObject - When one of the items in *<wirelessEndpoints>* is no object identifier.  
        :raises: ByteBlower.Exception.InvalidValue.ObjectType - When one of the items in *<wirelessEndpoints>* is no WirelessEndpoint object.  
        :raises: :exc:`.TechnicalError` - When the items in *<wirelessEndpoints>* are spread across multiple MeetingPoints.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	bb.WirelessEndpointsStartAndWait()



        """
        return _byteblower.ByteBlower_WirelessEndpointsStartAndWait(self, inWirelessEndpoints)


    def WirelessEndpointsPrepare(self, inWirelessEndpoints):
        """

        Prepares all the specified Wireless Endpoints.  

        If a wireless endpoint does not contain any
        streams or schedules, nothing happens for that
        Wireless Endpoint.  

        :param wirelessEndpoints: a :class:`.WirelessEndpointList` object with zero, one or more WirelessEndpoint objects on which  to start traffic streams and application schedules.  

        :raises: ByteBlower.Exception.InvalidValue.NotAnObject - When one of the items in *<wirelessEndpoints>* is no object identifier.  
        :raises: ByteBlower.Exception.InvalidValue.ObjectType - When one of the items in *<wirelessEndpoints>* is no WirelessEndpoint object.  
        :raises: :exc:`.TechnicalError` - When the items in  *<wirelessEndpoints>* are spread across multiple MeetingPoints.  


        """
        return _byteblower.ByteBlower_WirelessEndpointsPrepare(self, inWirelessEndpoints)


    def WirelessEndpointsPrepareAsync(self, inWirelessEndpoints):
        """

        Prepares all the specified Wireless Endpoints in an asynchronious way.  

        If a wireless endpoint does not contain any streams or schedules, nothing happens for that Wireless Endpoint.  

        :param wirelessEndpoints: a :class:`.WirelessEndpointList` object with zero, one or more ByteBlowerPort objects on which to start traffic streams and application schedules.  

        :raises: ByteBlower.Exception.InvalidValue.NotAnObject - When one of the items in *<wirelessEndpoints>* is no object identifier.  
        :raises: ByteBlower.Exception.InvalidValue.ObjectType - When one of the items in *<wirelessEndpoints>* is no WirelessEndpoint object.  
        :raises: :exc:`.TechnicalError` - When the items in *<wirelessEndpoints>* are spread across multiple MeetingPoints.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	bb.WirelessEndpointsPrepareAsync()



        """
        return _byteblower.ByteBlower_WirelessEndpointsPrepareAsync(self, inWirelessEndpoints)


    def ResultsRefresh(self, inResults):
        """

        Refreshes multiple result objects.  

        .. versionadded:: 2.2

        Sometimes you want to refresh a lot of results-objects at the same time. You can refresh all those objects in one API call. The results will be batched per server and then refreshed.  

        :return: nothing  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	bb.ResultsRefresh()



        """
        return _byteblower.ByteBlower_ResultsRefresh(self, inResults)


    def SchedulesStart(self, inSchedules):
        """

        Starts the specified schedulable objects.  

        More specifically, all specified schedulable objects have their *time to wait* period kick off simultaneously and when this time has passed the corresponding action is performed.  

        Typical actions include sending out a multicast join message or an HTTP request. All schedulable objects are listed below.  

        Schedulable objects that are already scheduled are ignored. Schedulable objects that are already finished or cancelled are scheduled again.  

        While re-scheduling them will always succeed (and this method will return without error), executing them multiple times may result in error states in other places. For example, a :class:`HttpClient` can only manage one HTTP session and will refuse to send out a second HTTP request.   

        Different kinds of schedulable objects exist throughout the API. They are returned by methods such as :meth:`Igmpv1MemberSession.ScheduleAdd`.   

        After creating and configuring such schedules, they can be scheduled by either passing them to this method or by passing the port(s) on which they were created to :meth:`PortsStart`.  

        The following schedulable object types are available in the API:

        - :class:`IgmpScheduleIpMulticastListen`
        - :class:`IgmpSchedule.Join`
        - :class:`IgmpSchedule.Leave`  

        .. note:: Bug 
                  HTTP requests are not yet available as a schedulable object and cannot be used with this method. 

        :param schedules: Zero, one or more schedulable objects to start.  

        :raises: ByteBlower.Exception.InvalidValue.NotAnObject - When one of the items in *<schedules>* is no object identifier.  
        :raises: ByteBlower.Exception.InvalidValue.ObjectType - When one of the items in *<schedules>* is no schedulable object.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	bb.SchedulesStart()



        """
        return _byteblower.ByteBlower_SchedulesStart(self, inSchedules)


    def SchedulesStop(self, inSchedules):
        """

        Stops the specified schedulable objects.  

        More specifically, all specified schedulable objects that are currently 
        scheduled are cancelled. Schedulable objects are only active for an instant, so
        actually aborting them is not possible.  

        For more information about schedulable objects, see :meth:`SchedulesStart`.  

        Schedules that are not running are ignored. This may be because they have not
        yet started or because they are already finished or cancelled.  

        :param inSchedules: Zero, one or more schedulable objects to abort.  

        :raises: ByteBlower.Exception.InvalidValue.NotAnObject - When one of the items
                 in *<schedules>* is no object identifier.  
        :raises: ByteBlower.Exception.InvalidValue.ObjectType - When one of the items 
                 in *<schedules>* is no schedulable object.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1
        	bb.SchedulesStop()



        """
        return _byteblower.ByteBlower_SchedulesStop(self, inSchedules)


    def ScheduleGroupCreate(self):
        """

        Create a ScheduleGroup.  

        :return: :class:`ScheduleGroup`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	bb.ScheduleGroupCreate()


        """
        return _byteblower.ByteBlower_ScheduleGroupCreate(self)


    def ScheduleGroupGet(self):
        """

        Returns all existing ScheduleGroup.  

        :return: :class:`ScheduleGroupList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	scheduleGroup = bb.ScheduleGroupGet('byteblower-1.lab.byteblower.com')

        """
        return _byteblower.ByteBlower_ScheduleGroupGet(self)

    if _newclass:
        DestroyInstance = staticmethod(_byteblower.ByteBlower_DestroyInstance)
    else:
        DestroyInstance = _byteblower.ByteBlower_DestroyInstance
ByteBlower_swigregister = _byteblower.ByteBlower_swigregister
ByteBlower_swigregister(ByteBlower)

def ByteBlower_InstanceGet():
    """

    Creates or returns the ByteBlower API singleton instance.  

    This object is the entry point to start working with the ByteBlower Python API.  

    If no ByteBlower instance is created yet, this method creates one and returns the object. If the instance exists already, it is simply returned.
    Any other static call will implicitly instantiate this singleton object.  

    :return:  ByteBlower singleton instance.  

    Example

    .. code-block:: python

       instance = bb.InstanceGet()


    """
    return _byteblower.ByteBlower_InstanceGet()

def ByteBlower_DestroyInstance():
    return _byteblower.ByteBlower_DestroyInstance()
ByteBlower_DestroyInstance = _byteblower.ByteBlower_DestroyInstance


def BB():
    return _byteblower.BB()
BB = _byteblower.BB
class User(AbstractObject):
    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, User, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, User, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NameGet(self):
        return _byteblower.User_NameGet(self)

    def InterfaceGet(self):
        return _byteblower.User_InterfaceGet(self)
User_swigregister = _byteblower.User_swigregister
User_swigregister(User)

class UserMobile(AbstractObject):
    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UserMobile, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UserMobile, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NameGet(self):
        return _byteblower.UserMobile_NameGet(self)

    def UUIDGet(self):
        return _byteblower.UserMobile_UUIDGet(self)
UserMobile_swigregister = _byteblower.UserMobile_swigregister
UserMobile_swigregister(UserMobile)

class StreamResultSnapshot(AbstractRefreshableResult):
    """


    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamResultSnapshot, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StreamResultSnapshot, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].  

        Example

        This example gets the snapshot timestamp [NS].  

        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_snapshot.TimestampGet())

        """
        return _byteblower.StreamResultSnapshot_TimestampGet(self)


    def TimestampFirstGet(self):
        """

        Gets the timestamp [NS] of the first packet in this snapshot.  

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable  

        Example

        This example gets the timestamp [NS] of the first transmitted packet in this snapshot  

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_snapshot.TimestampFirstGet())

        """
        return _byteblower.StreamResultSnapshot_TimestampFirstGet(self)


    def TimestampLastGet(self):
        """

        Gets the current timestamp [NS] of the last packet in this snapshot.  

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable  

        Example

        This example gets the timestamp [NS] of the last transmitted packet in this 
        snapshot  

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_snapshot.TimestampLastGet())

        """
        return _byteblower.StreamResultSnapshot_TimestampLastGet(self)


    def PacketCountGet(self):
        """

        Gets the transmitted packets.  

        Example

        This example gets the transmitted packets  

        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_snapshot.PacketCountGet())

        """
        return _byteblower.StreamResultSnapshot_PacketCountGet(self)


    def ByteCountGet(self):
        """

        Gets the current transmitted bytes.  

        Example
        This example gets the transmitted bytes  

        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_snapshot.ByteCountGet())

        """
        return _byteblower.StreamResultSnapshot_ByteCountGet(self)


    def FramesizeMaximumGet(self):
        """

        Gets the largest frame size transmitted in this snapshot.  

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable  

        .. versionadded:: 2.5.0  

        Example


        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_snapshot.FramesizeMaximumGet()) 


        """
        return _byteblower.StreamResultSnapshot_FramesizeMaximumGet(self)


    def FramesizeMinimumGet(self):
        """

        Gets the smallest frame size transmitted in this snapshot.  

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable  

        .. versionadded:: 2.5.0  

        Example

        This example gets the smallest frame size transmitted in this snapshot.  

        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_snapshot.FramesizeMinimumGet())

        """
        return _byteblower.StreamResultSnapshot_FramesizeMinimumGet(self)


    def IntervalDurationGet(self):
        """

        Gets the *configured* duration of this results snapshot [NS].  

        .. versionadded:: 2.3.0  

        Example

        This example gets interval duration of this result snapshot [NS]  

        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_snapshot.IntervalDurationGet())

        """
        return _byteblower.StreamResultSnapshot_IntervalDurationGet(self)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp when the counters of this object where last refreshed.  

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_snapshot.RefreshTimestampGet())

        """
        return _byteblower.StreamResultSnapshot_RefreshTimestampGet(self)

StreamResultSnapshot_swigregister = _byteblower.StreamResultSnapshot_swigregister
StreamResultSnapshot_swigregister(StreamResultSnapshot)

class StreamResultData(AbstractObject):
    """



    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamResultData, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StreamResultData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].  

        Example

        This example gets the snapshot timestamp [NS].  

        .. code-block:: python
           :emphasize-lines: 1

            print(streamData.TimestampGet())


        """
        return _byteblower.StreamResultData_TimestampGet(self)


    def TimestampFirstGet(self):
        """

        Gets the timestamp [NS] of the first packet in this snapshot.  

        :raises: CounterUnavailable - When no frames are received, this counter is 
                 unavailable  

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Gets the timestamp of the first transmitted packet in this snapshot

            print(streamData.TimestampLastGet())

        """
        return _byteblower.StreamResultData_TimestampFirstGet(self)


    def TimestampLastGet(self):
        """

        Gets the current timestamp [NS] of the last packet in this snapshot.  

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable  


        Example

        This example gets the timestamp [NS] of the last transmitted packet in this snapshot  

        .. code-block:: python
           :emphasize-lines: 1

            print(streamData.TimestampLastGet())

        """
        return _byteblower.StreamResultData_TimestampLastGet(self)


    def PacketCountGet(self):
        """

        Gets the transmitted packets.  

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Get the transmitted packets

            print(streamData.PacketCountGet())

        """
        return _byteblower.StreamResultData_PacketCountGet(self)


    def ByteCountGet(self):
        """

        Gets the current transmitted bytes.  

        Example

        This example gets the transmitted bytes  

        .. code-block:: python
           :emphasize-lines: 1

            print(streamData.ByteCountGet())


        """
        return _byteblower.StreamResultData_ByteCountGet(self)


    def FramesizeMaximumGet(self):
        """

        Gets the largest framesize transmitted in this snapshot.  

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable  

        .. versionadded:: 2.6.4  

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Get the largest framesize transmitted in this snapshot

            print(streamData.FramesizeMaximumGet())

        """
        return _byteblower.StreamResultData_FramesizeMaximumGet(self)


    def FramesizeMinimumGet(self):
        """

        Gets the smallest framesize transmitted in this snapshot  

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable  

        .. versionadded:: 2.6.4  


        Example 

        This example gets the smallest framesize transmitted in this snapshot.  

        .. code-block:: python
           :emphasize-lines: 1

            print(streamData.FramesizeMinimumGet())


        """
        return _byteblower.StreamResultData_FramesizeMinimumGet(self)


    def IntervalDurationGet(self):
        """

        Gets the *configured* duration of this results snapshot [NS].  

        .. versionadded:: 2.3.0  

        Example

        This example gets interval duration of this result snapshot [NS]  

        .. code-block:: python
           :emphasize-lines: 1

            print(streamData.IntervalDurationGet())


        """
        return _byteblower.StreamResultData_IntervalDurationGet(self)

StreamResultData_swigregister = _byteblower.StreamResultData_swigregister
StreamResultData_swigregister(StreamResultData)

class StreamResultList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamResultList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StreamResultList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.StreamResultList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.StreamResultList___nonzero__(self)

    def __bool__(self):
        return _byteblower.StreamResultList___bool__(self)

    def __len__(self):
        return _byteblower.StreamResultList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.StreamResultList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.StreamResultList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.StreamResultList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.StreamResultList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.StreamResultList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.StreamResultList___setitem__(self, *args)

    def pop(self):
        return _byteblower.StreamResultList_pop(self)

    def append(self, x):
        return _byteblower.StreamResultList_append(self, x)

    def empty(self):
        return _byteblower.StreamResultList_empty(self)

    def size(self):
        return _byteblower.StreamResultList_size(self)

    def swap(self, v):
        return _byteblower.StreamResultList_swap(self, v)

    def begin(self):
        return _byteblower.StreamResultList_begin(self)

    def end(self):
        return _byteblower.StreamResultList_end(self)

    def rbegin(self):
        return _byteblower.StreamResultList_rbegin(self)

    def rend(self):
        return _byteblower.StreamResultList_rend(self)

    def clear(self):
        return _byteblower.StreamResultList_clear(self)

    def get_allocator(self):
        return _byteblower.StreamResultList_get_allocator(self)

    def pop_back(self):
        return _byteblower.StreamResultList_pop_back(self)

    def erase(self, *args):
        return _byteblower.StreamResultList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_StreamResultList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.StreamResultList_push_back(self, x)

    def front(self):
        return _byteblower.StreamResultList_front(self)

    def back(self):
        return _byteblower.StreamResultList_back(self)

    def assign(self, n, x):
        return _byteblower.StreamResultList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.StreamResultList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.StreamResultList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.StreamResultList_reserve(self, n)

    def capacity(self):
        return _byteblower.StreamResultList_capacity(self)
    __swig_destroy__ = _byteblower.delete_StreamResultList
    __del__ = lambda self: None
StreamResultList_swigregister = _byteblower.StreamResultList_swigregister
StreamResultList_swigregister(StreamResultList)

class StreamResultHistory(AbstractRefreshableResult):
    """

    Sender-side transmit result history.  

    The history contains the sender information in time since the object is created
    or refreshed. 

    ..note :: The information is not updated until :meth:`Refresh` is called  

    A Stream history result object can be created via a :class:`Stream`, using
    :meth:`Stream.ResultHistoryGet`  

    .. note:: See History result for more information  

    .. versionadded:: 2.1.0  

    Example

    Get the counters per *sampling interval* for the stream result history.  

    .. code-block:: python
       :emphasize-lines: 3

    	stream_result_history = stream.ResultHistoryGet()
    	print(stream_snapshot.TimestampFirstGet())

    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamResultHistory, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StreamResultHistory, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SamplingIntervalDurationGet(self):
        """

        Duration of one sampling interval in nanoseconds.  

        :return: int Duration in nanoseconds  

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.SamplingIntervalDurationGet())

        """
        return _byteblower.StreamResultHistory_SamplingIntervalDurationGet(self)


    def SamplingBufferLengthGet(self):
        """

        Number of samples to keep in the buffer.  

        The ByteBlower server has a buffer to keep some samples before they are 
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a 
        sample is closed, the oldest sample in the buffer will be removed.  

        :return: The length of the server sample buffer  

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.SamplingBufferLengthGet())

        """
        return _byteblower.StreamResultHistory_SamplingBufferLengthGet(self)


    def SamplingIntervalDurationSet(self, inDuration):
        """

        Sets the duration of one sampling interval.  

        .. warning:: The previously collected history will be invalidated.  

        .. versionadded:: 2.3.0  

        Example

        .. code-block:: python
           :emphasize-lines: 1

            stream_result_history.SamplingIntervalDurationSet(3000000)

        """
        return _byteblower.StreamResultHistory_SamplingIntervalDurationSet(self, inDuration)


    def SamplingBufferLengthSet(self, inLength):
        """

        Sets the number of samples to keep in the buffer.  

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a 
        sample is closed, the oldest sample in the buffer will be removed.  

        .. versionadded:: 2.3.0  

        Example

        .. code-block:: python
           :emphasize-lines: 1

            stream_result_history.SamplingBufferLengthSet(5)

        """
        return _byteblower.StreamResultHistory_SamplingBufferLengthSet(self, inLength)


    def Clear(self):
        """

        Clear the history.  

        With each :meth:`Refresh` interval and cumulative counters are transferred from
        Server to the Client. To remove all counter-objects in this history, you can
        execute this method. Both Interval and Cumulative counter lists will be 
        cleared.

        Example

        Clear the History.  

        .. code-block:: python
           :emphasize-lines: 1

        	stream_result_history.Clear()

        """
        return _byteblower.StreamResultHistory_Clear(self)


    def CumulativeGet(self):
        """

        Returns a list of available cumulative counters.  

        Each result object contains cumulative counters at a certain point in time. 
        Snapshots are taken at fixed time intervals. The interval duration can be 
        obtained using :meth:`SamplingIntervalDurationGet`.  

        :return: :class:`.StreamResultDataList` containing the Cumulative counters  

        Example
        This example gets the available accumulated results  

        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_result_history.CumulativeGet()[0].DescriptionGet())  

        """
        return _byteblower.StreamResultHistory_CumulativeGet(self)


    def CumulativeGetByIndex(self, index):
        """

        Returns a single item of the cumulative list.  

        :param index: index

        :return: :class:`.StreamResultData` cumulative counter object at the specified
                 index  

        Example

        This example gets the available cumulative counters at index 1  

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           print(stream_snapshot.CumulativeGetByIndex(1).DescriptionGet())

        """
        return _byteblower.StreamResultHistory_CumulativeGetByIndex(self, index)


    def CumulativeGetByTime(self, timestamp):
        """

        Returns a single item of the cumulative list using a timestamp.  

        :param timestamp: int : timestamp in nanoseconds

        :return: :class:`.StreamResultData`  

        .. versionadded:: 2.2.0  

        Example

        This example gets the cumulative counter at timestamp 1432805398000000000 ns  

        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_result_history.CumulativeGetByTime(1432805398000000000))

        """
        return _byteblower.StreamResultHistory_CumulativeGetByTime(self, timestamp)


    def CumulativeLatestGet(self):
        """

        Returns latest closed item of the cumulative list.  

        :return: :class:`.StreamResultData`

        .. versionadded:: 2.2.0  

        Example

        This example gets the latest closed Cumulative counter object  

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.CumulativeLatestGet().DescriptionGet())

        """
        return _byteblower.StreamResultHistory_CumulativeLatestGet(self)


    def CumulativeLengthGet(self):
        """

        Returns the size of the cumulative list.  

        :return:  The length of the cumulative list  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(stream_result_history.CumulativeLengthGet())

        """
        return _byteblower.StreamResultHistory_CumulativeLengthGet(self)


    def IntervalGet(self):
        """

        Returns a list of available interval results.  

        Each result object contains interval counters at a certain point in time. 
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.  

        :return: :class:`.StreamResultDataList` containing the Interval counters  

        Example

        This example gets the available interval results  

        .. code-block:: python
           :emphasize-lines: 1

        	stream_result_history.IntervalGet()

        """
        return _byteblower.StreamResultHistory_IntervalGet(self)


    def IntervalGetByIndex(self, index):
        """

        Returns a single item of the interval list.  

        :param index: index

        :return: :class:`S.tream.ResultData` interval counter object at the specified
                 index  

        Example

        This example gets the available interval counters at index 1  

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.IntervalGetByIndex(1).DescriptionGet())

        """
        return _byteblower.StreamResultHistory_IntervalGetByIndex(self, index)


    def IntervalGetByTime(self, timestamp):
        """

        Returns a single item of the interval list using a timestamp in nanoseconds.  

        :param timestamp: int: timestamp in nanoseconds

        :return: :class:`.StreamResultData`  

        .. versionadded:: 2.2.0  

        Example

        This example gets the Interval counters at timestamp 1432805398000000000 ns   

        .. code-block:: python
           :emphasize-lines: 1

        	interval = stream_result_history.IntervalGetByTime(1432805398000000000)

        """
        return _byteblower.StreamResultHistory_IntervalGetByTime(self, timestamp)


    def IntervalLatestGet(self):
        """

        Returns the latest closed item of the interval list.  

        :return: :class:`.StreamResultData`

        .. versionadded:: 2.2.0  

        Example

        This example gets the latest closed Interval counter object  

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.IntervalLatestGet().DescriptionGet())

        """
        return _byteblower.StreamResultHistory_IntervalLatestGet(self)


    def IntervalLengthGet(self):
        """

        Returns the size of the interval list.  

        :return:  The length of the interval list  

        Example


        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.IntervalLengthGet())

        """
        return _byteblower.StreamResultHistory_IntervalLengthGet(self)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp on the server when the current history was refreshed.  

        This is the timestamp on the server when the last :meth:`Refresh` was called.  

        :return: Timestamp in nanoseconds since epoch  

        Example

        This example gets the Refresh timestamp  

        .. code-block:: python
           :emphasize-lines: 1

            print(stream_result_history.RefreshTimestampGet())

        """
        return _byteblower.StreamResultHistory_RefreshTimestampGet(self)

StreamResultHistory_swigregister = _byteblower.StreamResultHistory_swigregister
StreamResultHistory_swigregister(StreamResultHistory)

class StreamRuntimeStatus(AbstractRefreshableResult):
    """

    Status information about a Stream

    A stream has some runtime status information:

    Is the stream running (:meth:`StatusGet`)?

    If not, was there an error (:meth:`ErrorStatusGet`)?

    If so, where did the error came from (:meth:`ErrorSourceGet`)?

    Example

    .. code-block:: python

       # stream is configured to transmit for 1 second

       status = stream.StatusGet()
       print('Stream stopped?', status.StatusGet() == TransmitStatus.INACTIVE)

       stream.Start()

       status.Refresh()
       print('Stream started?', status.StatusGet() == TransmitStatus.ACTIVE)   

       time.sleep(1)

       status.Refresh()
       print('Stream stopped?', status.StatusGet() == TransmitStatus.INACTIVE)   


    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamRuntimeStatus, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StreamRuntimeStatus, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    transmit_error_status_UNKNOWN = _byteblower.StreamRuntimeStatus_transmit_error_status_UNKNOWN
    transmit_error_status_NONE = _byteblower.StreamRuntimeStatus_transmit_error_status_NONE
    transmit_error_status_OUT_OF_RESOURCES = _byteblower.StreamRuntimeStatus_transmit_error_status_OUT_OF_RESOURCES
    transmit_error_source_UNKNOWN = _byteblower.StreamRuntimeStatus_transmit_error_source_UNKNOWN
    transmit_error_source_NONE = _byteblower.StreamRuntimeStatus_transmit_error_source_NONE
    transmit_error_source_INTERFACE_HARDWARE = _byteblower.StreamRuntimeStatus_transmit_error_source_INTERFACE_HARDWARE
    transmit_error_source_SCHEDULING_CONFLICT = _byteblower.StreamRuntimeStatus_transmit_error_source_SCHEDULING_CONFLICT
    transmit_error_source_TXUSER = _byteblower.StreamRuntimeStatus_transmit_error_source_TXUSER
    transmit_status_UNKNOWN = _byteblower.StreamRuntimeStatus_transmit_status_UNKNOWN
    transmit_status_INACTIVE = _byteblower.StreamRuntimeStatus_transmit_status_INACTIVE
    transmit_status_ACTIVE = _byteblower.StreamRuntimeStatus_transmit_status_ACTIVE

    def StatusGet(self):
        """

        Returns the stream status.  

        This way one can determine if a stream is still running or whether the stream 
        finished

        :return: The current status of the stream.
        :rtype: :class:`TransmitStatus`  

        """
        return _byteblower.StreamRuntimeStatus_StatusGet(self)


    def ErrorStatusGet(self):
        """

        Returns error information.

        A stream can finish without issues, but can also run into error conditions.
        One of those error conditions is e.g. *Out-Of-Resources*.   This means that
        one tries to transmit e.g. more than 1Gbps over a 1Gbps link.

        :return: The error information of the stream if applicable.
        :rtype: :class:`TransmitErrorStatus`

        """
        return _byteblower.StreamRuntimeStatus_ErrorStatusGet(self)


    def ErrorSourceGet(self):
        """

        Returns error source information.  

        If :meth:`ErrorStatusGet` does not return :attr:`TransmitErrorStatus.NONE`, the
        returned value of this method will indicate a reason why the error state is 
        returned.

        :return: The source of the error.
        :rtype:  :class:`TransmitErrorSource`

        """
        return _byteblower.StreamRuntimeStatus_ErrorSourceGet(self)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp when the information was last queried on the server.

        :return: The timestamp since epoch in nanoseconds
        :rtype: int

        .. code-block:: python
           :emphasize-lines: 3, 8

           # ...
           status_object = stream.StatusGet()
           print(status_object.RefreshTimestampGet())
           # Prints: 1559736027345545000

           time.sleep(1)

           print(status_object.RefreshTimestampGet())
           # Prints: 1559736028345545000

        """
        return _byteblower.StreamRuntimeStatus_RefreshTimestampGet(self)

StreamRuntimeStatus_swigregister = _byteblower.StreamRuntimeStatus_swigregister
StreamRuntimeStatus_swigregister(StreamRuntimeStatus)


def ConvertRuntimeTransmitStatus(inStatus):
    return _byteblower.ConvertRuntimeTransmitStatus(inStatus)
ConvertRuntimeTransmitStatus = _byteblower.ConvertRuntimeTransmitStatus

def ConvertRuntimeTransmitErrorStatus(inStatus):
    return _byteblower.ConvertRuntimeTransmitErrorStatus(inStatus)
ConvertRuntimeTransmitErrorStatus = _byteblower.ConvertRuntimeTransmitErrorStatus

def ConvertRuntimeTransmitErrorSource(inSource):
    return _byteblower.ConvertRuntimeTransmitErrorSource(inSource)
ConvertRuntimeTransmitErrorSource = _byteblower.ConvertRuntimeTransmitErrorSource
class Stream(AbstractObject):
    """

    A ByteBlower stream is an object representing a stream of ByteBlower frames (Frame) used for transmission on a ByteBlower port.

    A ByteBlower stream contains the following data:

    Frames
        A list of Frame objects

    NumberOfFrames
        The number of frames the stream should  transmit

    InterFrameGap
        The inter frame gap between 2 transmitted frames

    InitialTimeToWait
        An initial time to wait, if needed

    TimingModifier
        A timing modifier

    Example

    .. code-block:: python
       :emphasize-lines: 1
       :caption: A typical stream usage flow

       stream = port.TxStreamAdd()
       stream.NumberOfFramesSet(1000)
       stream.InterFrameGapSet(1000000)

       frame = stream.FrameAdd()
       # Configure the frame ...

       stream.Start()


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Stream, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Stream, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PortGet(self):
        """

        Returns the parent ByteBlower Port on which the stream was created

        :return: The parent port
        :rtype: :class:`.ByteBlowerPort`

        .. todo:: Shouldn't we remove this function, it is not available in the TCL
                  API either

        """
        return _byteblower.Stream_PortGet(self)


    def NumberOfFramesGet(self):
        """

        Gets the configured number of frames the stream needs to transmit

        :return: The configured number of frames
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: prints the number of frames configured on the stram.

           print(stream.NumberOfFramesGet())


        """
        return _byteblower.Stream_NumberOfFramesGet(self)


    def NumberOfFramesSet(self, nof):
        """

        Sets the number of frames the stream needs to transmit.

        This defines the number of frames a stream will send. -1 means continues.

        :param count: The number of frames to set. Use -1 to send infinitely.
        :type count: int

        .. note:: when count is set -1, keep in mind to stop the stream using
                  :meth:`Stop`

        Example

        This example sets the frame count of the stream.

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Set the number frames to transmit to 1000

           stream.NumberOfFramesAdd(1000)

        """
        return _byteblower.Stream_NumberOfFramesSet(self, nof)


    def InterFrameGapGet(self):
        """

        Returns the inter-frame gap for the stream.

        :return: The inter-frame gap is returned in nanoseconds.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: print the inter frame gap of the stream

           print(stream.InterFrameGapGet())


        """
        return _byteblower.Stream_InterFrameGapGet(self)


    def InterFrameGapSet(self, interFrameGap):
        """

        Sets the inter-frame gap for the stream.

        :param duration: Duration in nanoseconds
        :type duration: int

        Example

        This example sets the inter-frame gap on a stream.

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Configure the stream to send 10 frames per second

           stream.InterFrameGapSet(inter_frame_gap)

        """
        return _byteblower.Stream_InterFrameGapSet(self, interFrameGap)


    def InitialTimeToWaitGet(self):
        """

        Returns the time to wait before the first frame will be sent.

        :return: The initial time to wait in nanoseconds.
        :rtype: int

        Example

        This example gets the current initial time to wait from a stream.

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Print the initial time to wait for a stream

           print(stream.InitialTimeToWaitGet())

        """
        return _byteblower.Stream_InitialTimeToWaitGet(self)


    def InitialTimeToWaitSet(self, initTimeToWait):
        """

        Sets a delay before sending the first frame.

        :param duration: The duration in nanoseconds
        :type duration: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: sets initial time to wait to 2 seconds

           stream.InitialTimeToWaitSet(wait)

        """
        return _byteblower.Stream_InitialTimeToWaitSet(self, initTimeToWait)


    def Start(self):
        """

        Starts the stream.

        The stream will be started when this method is called. This will also cause the
        results for the stream and attached frames to be cleared. The objects of the
        types below will thus be cleared.

        - :class:`.StreamResultSnapshot`
        - :class:`.StreamResultHistory`
        - :class:`.FrameResultSnapshot`
        - :class:`.FrameResultHistory`

        Example

        .. code-block:: python
           :emphasize-lines: 1


           stream.Start()

        """
        return _byteblower.Stream_Start(self)


    def Stop(self):
        """

        Stops the stream.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           stream.Stop()

        """
        return _byteblower.Stream_Stop(self)


    def ResultClear(self):
        """

        Resets the current result counters to zero and empties the ResultHistory.

        .. versionadded:: 2.1.0

        Calling this method causes the :class:`StreamResultSnapshot` and the
        :class:`.StreamResultHistory` to be reset.

        All counters will be set to zero and all historic data in the history will be
        removed.

        Example

        .. code-block:: python
           :emphasize-lines: 6
           :caption: shows how ResultClear() affects the results from ResultGet()

           stream.ResultClear()


        """
        return _byteblower.Stream_ResultClear(self)


    def ResultGet(self):
        """

        Returns the current result counters.

        :return: The current cumulative stream result counters
        :rtype: :class:`.StreamResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(stream.ResultGet().DescriptionGet())

        """
        return _byteblower.Stream_ResultGet(self)


    def ResultHistoryGet(self):
        """

        Returns the current History counters.

        :return: :class:`.StreamResultHistory`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(stream.ResultHistoryGet().DescriptionGet())

        """
        return _byteblower.Stream_ResultHistoryGet(self)


    def FrameAdd(self):
        """

        Adds a frame to the stream.

        :return: The freshly added frame
        :rtype: :class:`.Frame`

        Example

        This example adds a frame to a stream.

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Add a frame to the stream.

           frame = stream.FrameAdd()

        """
        return _byteblower.Stream_FrameAdd(self)


    def FrameGet(self):
        """

        Returns list of frames on this stream.

        :return: A list of added frames.
        :rtype: :class:`FrameList`

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Iterate over the added frames and print their description

           for frame in stream.FrameGet():
               print(frame.DescriptionGet())

        """
        return _byteblower.Stream_FrameGet(self)


    def FrameDestroy(self, inFrame):
        """

        Removes a frame from the stream

        :param frame: The frame object to remove
        :type frame: :class:`.Frame`

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Iterate over the added frames and print their description

           stream.FrameDestroy(frame1)



        """
        return _byteblower.Stream_FrameDestroy(self, inFrame)


    def RandomSizeModifierAdd(self):
        """

        Adds a Random Size modifier to the stream

        .. deprecated:: 2.3.0
           This is deprecated.  Please use :meth:`.Frame.ModifierSizeRandomSet`

        .. note:: The name for this function is actually wrong.  A new size modifier
                  will replace existing size modifiers

        :return: The freshly created random size modifier
        :rtype: :class:`.StreamRandomSizeModifier`

        """
        return _byteblower.Stream_RandomSizeModifierAdd(self)


    def GrowingSizeModifierAdd(self):
        """

        Adds a Growing Size modifier to the stream

        .. deprecated:: 2.3.0
           This is deprecated.  Please use :meth:`.Frame.ModifierSizeGrowingSet`

        .. note:: The name for this function is actually wrong.  A new size modifier
                  will replace existing size modifiers

        :return: The freshly created growing size modifier
        :rtype: :class:`.StreamGrowingSizeModifier`


        """
        return _byteblower.Stream_GrowingSizeModifierAdd(self)


    def MultipleBurstModifierAdd(self):
        """

        Sets a burst modifier on the stream.

        This timing modifier will cause the stream to send *bursty* traffic.
        See :class:`MultipleBurstModifier` for configurable parameters.

        .. note:: The actual name of this method is wrong, a new modifier will remove a previous one.

        :return: The freshly created modifier
        :rtype: :class:`.MultipleBurstModifier`

        """
        return _byteblower.Stream_MultipleBurstModifierAdd(self)


    def NormalDistributionTimingModifierAdd(self):
        """

        Sets a normal distribution modifier on the stream.

        See :class:`NormalDistributionTimingModifier` for configurable parameters.

        .. note:: The actual name of this method is wrong, a new modifier will remove a previous one.

        :return: The freshly created modifier
        :rtype: :class:`.NormalDistributionTimingModifier`

        Example

        .. code-block:: python
           :emphasize-lines: 2
           :caption: prints the number of frames configured on the stram.

           normalDistribution = port.NormalDistributionTimingModifierAdd()


        """
        return _byteblower.Stream_NormalDistributionTimingModifierAdd(self)


    def ModifierFrameGet(self):
        """

        Gets the configured frame modifiers

        .. deprecated: 2.3.0
           Instead of creating frame modifying objects on the stream, create them on
           the :class:`Frame` directly.
           See: :meth:`.Frame.ModifierSizeGrowingGet` and
           :meth:`Frame.ModifierSizeRandomGet`

        :return: The current frame modifier.
        :rtype: if 'growing', A :class:`StreamGrowingSizeModifier` object.
                If 'random',  A :class:`StreamRandomSizeModifier` object.

        :return: The configured modifiers

        """
        return _byteblower.Stream_ModifierFrameGet(self)


    def ModifierFrameDestroy(self):
        """

        Destroys a frame modifier (e.g. size-modfier).

        .. deprecated: 2.3.0
           Instead of creating frame modifying objects on the stream, create them on
           the :class:`Frame` directly

        :param modifier: Modifier to remove
        :type modifier: Modifier

        """
        return _byteblower.Stream_ModifierFrameDestroy(self)


    def ModifierTimingGet(self):
        """

        Gets the configured timing modifier

        :return: Configured timing modifier
        :rtype: :class:`NormalDistributionTimingModifier` or a :class:`MultipleBurstModifier`

        """
        return _byteblower.Stream_ModifierTimingGet(self)


    def ModifierTimingDestroy(self):
        """

        Removes a timing modifier

        :param modifier: Modifier to remove
        :type modifier: :class:`NormalDistributionTimingModifier` or a :class:`MultipleBurstModifier`

        """
        return _byteblower.Stream_ModifierTimingDestroy(self)


    def StatusGet(self):
        """

        Returns status information.

        :return: :class:`.StreamRuntimeStatus`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           stream.StatusGet()

        """
        return _byteblower.Stream_StatusGet(self)

Stream_swigregister = _byteblower.Stream_swigregister
Stream_swigregister(Stream)

class StreamMobile(AbstractObject):
    """

    A StreamMobile object configures a stream of frames that will be transmitted by a
    WirelessEndpoint.

    The StreamMobile object allows you to add frame objects (:class:`FrameMobile`)
    and configure parameters like the number of frames that will be transmitted,
    the inter-frame gap and the initial time to wait before transmission.

    .. versionadded:: 2.6.0

    Example

    .. code-block:: python
       :caption: Typical usage flow

       frame_size = 1000  # bytes

       stream = wirelessEndpoint.TxStreamAdd()
       stream.NumberOfFramesSet(100)

       # Transmit at 10 frames per second, which is 100 milliseconds per frame
       stream.InterFrameGapSet(10000000)

       stream.DestinationAddressSet('192.168.0.2')
       stream.DestinationPortSet(4000)
       stream.SourcePortSet(4001)

       # Add a frame
       frame = stream.FrameAdd()

       # ... configure the frame, see FrameMobile documentation for this.


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamMobile, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StreamMobile, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NumberOfFramesGet(self):
        """

        Returns the number of frames that will be transmitted by a stream.

        :return: the number of frames that will be transmitted by the stream
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: prints the number of frames to be transmitted by a stream

           print(stream.NumberOfFramesGet())


        """
        return _byteblower.StreamMobile_NumberOfFramesGet(self)


    def NumberOfFramesSet(self, nof):
        """

        Sets the number of frames sent by a stream.

        This method configures the number of frames a stream will transmit.

        :param count: The number of frames to send.
        :type count: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example sets the frame count of the stream.

           stream.NumberOfFramesSet(1000)

        """
        return _byteblower.StreamMobile_NumberOfFramesSet(self, nof)


    def InterFrameGapGet(self):
        """

        Returns the inter-frame gap for the stream.

        :return: The inter-frame gap is returned in nanoseconds.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: prints the inter-frame gap of a stream

           print(stream.InterFrameGapGet())


        """
        return _byteblower.StreamMobile_InterFrameGapGet(self)


    def InterFrameGapSet(self, interFrameGap):
        """

        Sets the inter-frame gap for the stream.

        :param duration: duration in nanoseconds
        :type duration: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Set the inter-frame gap to 100ms


           stream.InterFrameGapSet(gap)


        """
        return _byteblower.StreamMobile_InterFrameGapSet(self, interFrameGap)


    def InitialTimeToWaitGet(self):
        """

        Returns the time to wait before the first frame will be sent.

        :return: The initial time to wait in nanoseconds.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: get the current initial time to wait

           print(stream.InitialTimeToWaitGet())


        """
        return _byteblower.StreamMobile_InitialTimeToWaitGet(self)


    def InitialTimeToWaitSet(self, initTimeToWait):
        """

        Sets a delay before sending the first frame.

        :param duration: The amount of time to wait before sending the first frame
                         Unit is in nanoseconds
        :type duration: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: set the initial time to wait to 2 seconds

           stream.InitialTimeToWaitSet(wait)


        """
        return _byteblower.StreamMobile_InitialTimeToWaitSet(self, initTimeToWait)


    def ResultClear(self):
        """

        Clears the results.

        .. note:: This affects the all results for a stream.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Resets the current result counters to zero.

           stream.ResultClear()

        """
        return _byteblower.StreamMobile_ResultClear(self)


    def ResultGet(self):
        """

        Returns the current result counters.

        :return: The cumulative results for the stream
        :rtype: :class:`StreamResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(stream.ResultGet().DescriptionGet())


        """
        return _byteblower.StreamMobile_ResultGet(self)


    def ResultHistoryGet(self):
        """

        Returns the current History counters.

        :return: The history counters for the stream
        :rtype: :class:`StreamResultHistory`

        .. code-block:: python
           :emphasize-lines: 1

           history = stream.ResultHistoryGet()


        """
        return _byteblower.StreamMobile_ResultHistoryGet(self)


    def FrameAdd(self):
        """

        Adds a frame to the stream.

        :return: The newly created frame
        :rtype: :class:`.FrameMobile`

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example adds a frame to a stream.

           stream.FrameAdd()

        """
        return _byteblower.StreamMobile_FrameAdd(self)


    def FrameGet(self):
        """

        Returns list of frames on this stream.

        :return: A list of all configured frames on the stream
        :rtype: :class:`.FrameMobileList`

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: prints all configured frames on a stream

           for frame in stream.FrameGet():
               print(frame.DescriptionGet())


        """
        return _byteblower.StreamMobile_FrameGet(self)


    def FrameDestroy(self, inFrame):
        return _byteblower.StreamMobile_FrameDestroy(self, inFrame)

    def SourcePortSet(self, inPort):
        """

        Sets the source port in the UDP header of the frames that will be transmitted.

        :param port: The UDP source port number for the transmitted frames (1-65535)
        :type port: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           stream.SourcePortSet(8000)


        """
        return _byteblower.StreamMobile_SourcePortSet(self, inPort)


    def SourcePortGet(self):
        """

        Returns the source port in the UDP header of the frames that will be
        transmitted.

        :return: The UDP source port
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example gets the UDP source port of a stream

           print('UDP source:', stream.SourcePortGet())


        """
        return _byteblower.StreamMobile_SourcePortGet(self)


    def DestinationAddressSet(self, inAddress):
        """

        Sets the destination address in the IP header of the frames that will be
        transmitted.

        :param address: The destination IPv4 or IPv6 address to send the frames to.
        :type address: str

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: set an IPv4 destination

           stream.DestinationAddressSet('192.168.0.4')

        """
        return _byteblower.StreamMobile_DestinationAddressSet(self, inAddress)


    def DestinationAddressGet(self):
        """

        Returns the destination address in the IP header of the frames that will be
        transmitted.

        :return: the Destination IP address the frames will be sent to
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(stream.DestinationAddressGet())


        """
        return _byteblower.StreamMobile_DestinationAddressGet(self)


    def DestinationPortSet(self, inDestinationPort):
        """

        Sets the destination port in the UDP header of the frames that will be
        transmitted.

        :param portnumber: UDP destination port to send the frame to (1-65535)
        :type portnumber: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           stream.DestinationPortSet(4000)


        """
        return _byteblower.StreamMobile_DestinationPortSet(self, inDestinationPort)


    def DestinationPortGet(self):
        """

        Returns the destination port in the UDP header of the frames that will be
        transmitted.

        :return: The UDP destination port that will be used.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(stream.DestinationPortGet())


        """
        return _byteblower.StreamMobile_DestinationPortGet(self)


    def TypeOfServiceGet(self):
        """

        Returns the type-of-service field (or TOS bits) in the IP header of the frames
        that will be transmitted.

        :return: The contents of the Type-Of-Service field.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example gets the current TOS field.

           print('TOS set to:', stream.TypeOfServiceGet())


        """
        return _byteblower.StreamMobile_TypeOfServiceGet(self)


    def TypeOfServiceSet(self, inTos):
        """

        Sets the type-of-service field (or TOS bits) in the IP header of the frames
        that will be transmitted.

        :param tos: The contents of the type-of-service field in the IP header
        :type tos: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           stream.TypeOfServiceSet(2)


        """
        return _byteblower.StreamMobile_TypeOfServiceSet(self, inTos)

StreamMobile_swigregister = _byteblower.StreamMobile_swigregister
StreamMobile_swigregister(StreamMobile)

class Schedule(AbstractObject):
    """

    This class contains the base functionality to configure a scheduled action.

    Schedulable objects can be obtained, for example by calling
    HttpClient.ScheduleGet(). The returned object is schedulable.



    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Schedule, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Schedule, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ServerGet(self):
        return _byteblower.Schedule_ServerGet(self)

    def InitialTimeToWaitGet(self):
        """

        Returns the time when the action is scheduled. This time is set using
        :meth:`InitialTimeToWaitSet` At that time, the first frame will be sent.

        :return: The initial time to wait in nanoseconds.

        """
        return _byteblower.Schedule_InitialTimeToWaitGet(self)


    def InitialTimeToWaitSet(self, ns):
        """

        Sets the time when the action will be scheduled. That is, when the first frame
        will be sent.

        :param time: The time when the action will be scheduled.
                     Valid range: 0 to *max_uint64* [ns]
        :type time: int

            Where *<max_uint64>*    0xFFFFFFFFFFFFFFFF
            = 18446744073709551615
            ( = maximum unsigned 64bit integer)

        Sets the initial time to wait before the first frame will be sent. By default,
        the unit has a nanosecond resolution. But you can also provide a time unit.

        The schedule can be started using :meth:`Start`

        :raises: python_error: Failed to parse time string: When the value could not be
                 interpreted as a valid time string

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Set the initial time to wait to 9 nanoseconds

           schedule.InitialTimeToWaitSet(9)


        """
        return _byteblower.Schedule_InitialTimeToWaitSet(self, ns)


    def Prepare(self):
        return _byteblower.Schedule_Prepare(self)

    def Start(self):
        """

        Starts the scheduled action.

        The first packet will be sent after the initial time to wait.

        """
        return _byteblower.Schedule_Start(self)


    def Stop(self):
        """

        Stops the running scheduled action.

        If the action has not been started, nothing will happen.

        """
        return _byteblower.Schedule_Stop(self)


    def GetSchedulableObject(self):
        return _byteblower.Schedule_GetSchedulableObject(self)
Schedule_swigregister = _byteblower.Schedule_swigregister
Schedule_swigregister(Schedule)

class Rx(AbstractObject):
    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Rx, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Rx, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def FilterSet(self, inFilter):
        return _byteblower.Rx_FilterSet(self, inFilter)

    def FilterGet(self):
        return _byteblower.Rx_FilterGet(self)
Rx_swigregister = _byteblower.Rx_swigregister
Rx_swigregister(Rx)

class TaggedRx(Rx):
    __swig_setmethods__ = {}
    for _s in [Rx]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TaggedRx, name, value)
    __swig_getmethods__ = {}
    for _s in [Rx]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TaggedRx, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def FrameTagGet(self):
        return _byteblower.TaggedRx_FrameTagGet(self)

    def FrameTagSet(self, fromFrameTagTx):
        return _byteblower.TaggedRx_FrameTagSet(self, fromFrameTagTx)

    def FrameTagDefaultSet(self):
        return _byteblower.TaggedRx_FrameTagDefaultSet(self)
TaggedRx_swigregister = _byteblower.TaggedRx_swigregister
TaggedRx_swigregister(TaggedRx)

class Capture(Rx):
    __swig_setmethods__ = {}
    for _s in [Rx]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Capture, name, value)
    __swig_getmethods__ = {}
    for _s in [Rx]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Capture, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def FileNameRemoteGet(self):
        return _byteblower.Capture_FileNameRemoteGet(self)

    def Start(self):
        return _byteblower.Capture_Start(self)

    def Stop(self):
        return _byteblower.Capture_Stop(self)

    def ResultGet(self):
        return _byteblower.Capture_ResultGet(self)
Capture_swigregister = _byteblower.Capture_swigregister
Capture_swigregister(Capture)

class SchedulableObject(AbstractObject):
    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SchedulableObject, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SchedulableObject, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_SchedulableObject
    __del__ = lambda self: None

    def ScheduleStart(self):
        return _byteblower.SchedulableObject_ScheduleStart(self)

    def ScheduleStop(self):
        return _byteblower.SchedulableObject_ScheduleStop(self)

    def ScheduleRemove(self, inSchedule):
        return _byteblower.SchedulableObject_ScheduleRemove(self, inSchedule)

    def ScheduleRemoveAll(self):
        return _byteblower.SchedulableObject_ScheduleRemoveAll(self)

    def ScheduleGet(self):
        return _byteblower.SchedulableObject_ScheduleGet(self)

    def ServerGet(self):
        return _byteblower.SchedulableObject_ServerGet(self)
SchedulableObject_swigregister = _byteblower.SchedulableObject_swigregister
SchedulableObject_swigregister(SchedulableObject)

class Layer25Configuration(AbstractObject):
    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Layer25Configuration, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Layer25Configuration, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PortGet(self):
        return _byteblower.Layer25Configuration_PortGet(self)
Layer25Configuration_swigregister = _byteblower.Layer25Configuration_swigregister
Layer25Configuration_swigregister(Layer25Configuration)

class DHCPv4SessionInfo(AbstractObject):
    """

    Class containing the info about the DHCPSession.

    This class represents the session info gathered from a DHCPSession. It will
    contain counters of the amount of DHCPMessages transmitted and received. It
    also contains some values of the obtained lease ( leasetime, GiAddr, SiAddr,
    OptionValues )

    .. code-block:: python
       :emphasize-lines: 2

       session_info = protocol.DHCPv4SessionInfoGet()
       for option in info.DHCPOptionGet():
    		print(option)

    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DHCPv4SessionInfo, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DHCPv4SessionInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TxGet(self):
        """

        Returns the number of DHCPMessages transmitted.

        :return: Number of DHCP messages transmitted
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info)

        """
        return _byteblower.DHCPv4SessionInfo_TxGet(self)


    def RxGet(self):
        """

        Returns the number of DHCPMessages recieved.

        :return:  Number of DHCP messages received
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info)

        """
        return _byteblower.DHCPv4SessionInfo_RxGet(self)


    def DHCPOptionGet(self):
        """

        Returns a list if received DHCPOptions.

        :return: List of DHCPOptions in the form of OptionNumber-Value

        Example

        .. code-block:: python
           :emphasize-lines: 1

           for option in session_info.DHCPOptionGet:
        		print(option)

        """
        return _byteblower.DHCPv4SessionInfo_DHCPOptionGet(self)


    def SiAddrGet(self):
        """

        Returns the IP address of next server to use in bootstrap.

        :return: next server IP address
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(session_info.SiAddrGet())

        """
        return _byteblower.DHCPv4SessionInfo_SiAddrGet(self)


    def GiAddrGet(self):
        """

        Returns the ipAddress of the relay agent, used in booting via a relay agent.

        :return: Relay agent IP address
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.GiAddrGet())


        """
        return _byteblower.DHCPv4SessionInfo_GiAddrGet(self)


    def DHCPServerAddrGet(self):
        """

        Returns the ipAddress of the DHCPServer.

        This address is parsed out of DHCPServerIdentifier option ( Option 54 )

        :return: Address of the DHCP server
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.DHCPServerAddrGet())

        """
        return _byteblower.DHCPv4SessionInfo_DHCPServerAddrGet(self)


    def LeaseTimeGet(self):
        """

        Returns IP Address lease time.

        :return: The leasetime in NanoSeconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.LeaseTimeGet())

        """
        return _byteblower.DHCPv4SessionInfo_LeaseTimeGet(self)


    def TransactionIDGet(self):
        return _byteblower.DHCPv4SessionInfo_TransactionIDGet(self)

    def DiscoverTimestampLastGet(self):
        """

        Returns the timestamp when the last DHCP Discover message is sent.

        .. versionadded:: 2.11.2

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.DiscoverTimestampLastGet())

        """
        return _byteblower.DHCPv4SessionInfo_DiscoverTimestampLastGet(self)


    def OfferTimestampLastGet(self):
        """

        Returns the timestamp when the last DHCP Offer message is received.

        .. versionadded:: 2.11.2

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.OfferTimestampLastGet())

        """
        return _byteblower.DHCPv4SessionInfo_OfferTimestampLastGet(self)


    def RequestTimestampLastGet(self):
        """

        Returns the timestamp when the last DHCP Request message is sent.

        .. versionadded:: 2.11.2

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.RequestTimestampLastGet())

        """
        return _byteblower.DHCPv4SessionInfo_RequestTimestampLastGet(self)


    def AckTimestampLastGet(self):
        """

        Returns the timestamp when the last DHCP Ack message is received.

        .. versionadded:: 2.11.2

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.AckTimestampLastGet())

        """
        return _byteblower.DHCPv4SessionInfo_AckTimestampLastGet(self)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp when the counters of this object where last refreshed.

        :return: RefreshTimestamp in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.RefreshTimestampGet())


        """
        return _byteblower.DHCPv4SessionInfo_RefreshTimestampGet(self)

DHCPv4SessionInfo_swigregister = _byteblower.DHCPv4SessionInfo_swigregister
DHCPv4SessionInfo_swigregister(DHCPv4SessionInfo)

class DHCPv6SessionInfo(AbstractObject):
    """

    Class containing the info about the DHCPSession.

    This class represents the session info gathered from a DHCPv6Session. It will
    contain counters of the amount of DHCPMesseage transmitted and received.


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DHCPv6SessionInfo, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DHCPv6SessionInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TxGet(self):
        """

        Returns the number of DHCPMessages transmitted.

        :return:  Number of DHCP messages transmitted
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcpSessionInfo.TxGet())


        """
        return _byteblower.DHCPv6SessionInfo_TxGet(self)


    def RxGet(self):
        """

        Returns the number of DHCPMessages recieved.

        :return:  Number of DHCP messages received
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcpSessionInfo.RxGet())

        """
        return _byteblower.DHCPv6SessionInfo_RxGet(self)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp when the results are last retrieved from the server

        :return: The timestamp in nanoseconds since epoch
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(session_info.RefreshTimestampGet())

        """
        return _byteblower.DHCPv6SessionInfo_RefreshTimestampGet(self)


    def SolicitTimestampLastGet(self):
        return _byteblower.DHCPv6SessionInfo_SolicitTimestampLastGet(self)

    def AdvertiseTimestampLastGet(self):
        return _byteblower.DHCPv6SessionInfo_AdvertiseTimestampLastGet(self)

    def RequestTimestampLastGet(self):
        return _byteblower.DHCPv6SessionInfo_RequestTimestampLastGet(self)

    def ReplyTimestampLastGet(self):
        return _byteblower.DHCPv6SessionInfo_ReplyTimestampLastGet(self)
DHCPv6SessionInfo_swigregister = _byteblower.DHCPv6SessionInfo_swigregister
DHCPv6SessionInfo_swigregister(DHCPv6SessionInfo)

class DHCPv4Protocol(AbstractObject):
    """

    The :class:`.DHCPv4Protocol` is the entry point to configure the DHCP client
    behavior of a ByteBlowerPort.

    A ByteBlowerPort can perform DHCP the get an IP address, gateway and netmask.
    Currently, no other options are supported but this will change in the future.

    Users can configure the timing parameters used in the different stages of the
    DHCP protocol:
    - Discover

      During the discover stage the ByteBlower port will broadcast discover
      messages.

    - Request

      Once one or more offers are received the ByteBlower port will broadcast its
      request message. If acknowledge the ByteBlower port will start using this
      address.

    - Renew

      When half of the lease time received in the acknowledge message of the
      request has passed, a ByteBlowerPort will sent a renew message to the server
      to extend its lease.

    Although DHCP allows clients to use unicast messages in the Request stage,
    ByteBlower currently only supports broadcast messages in this stage.

    A :class:`.DHCPv4Protocol` object also supports different retransmission
    strategies:

    Fixed
        This policy will use the same timeout value for each timeout.
    RFCSuggested
        This policy implements the policy described in :rfc:2131.


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DHCPv4Protocol, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DHCPv4Protocol, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Perform(self):
        """

        Start DHCP and wait for the result.

        This method will force the DHCP client on the ByteBlower port to send a first
        DHCP discover message. It the client is already active, a new discover message
        will be sent. This is a synchronous call, so the full DHCPv6 solicit and
        request will be done once this call returns, or an error have occurred.

        :return: This method will return nothing, but will return after DHCP is
                 performed successfully. If DHCP fails, and exception is thrown.

        :raises: :exc:`.DHCPFailed` when no offer was received during the DHCP discover
                 stage or when no DHCPAck was received during DHCPRequest stage

        Example

        This example will perform DHCP on the specified ByteBlowerPort.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.Perform()

        """
        return _byteblower.DHCPv4Protocol_Perform(self)


    def PerformAsync(self):
        """

        Will start DHCP and return immediately.

        This method will force the DHCP client on the ByteBlower port to send a first
        DHCP discover message. If the client is already active, a new discover message
        will be sent. This is a asynchronous call, so it will return immediately. If
        you want to see if there an exception occurred during this async, call the
        :meth:`Perform` method.

        :return: This method will return nothing and return immediately

        .. versionadded:: 2.2

        Example

        This example will perform DHCP on the specified ByteBlowerPort.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.PerformAsync()


        """
        return _byteblower.DHCPv4Protocol_PerformAsync(self)


    def Release(self):
        """

        Release the DHCP lease.

        This method will release the address previously received using DHCP. After
        this, the address will not be used anymore by the ByteBlower port and the DHCP
        server can reuse the address for other DHCP clients. Of course, packets sent by
        the ByteBlower port as part of streams can still use the address.

        :return: This method will return nothing, but will return after DHCP Release is
                 performed

        Example

        This example will release the DHCP address.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.Release()

        """
        return _byteblower.DHCPv4Protocol_Release(self)


    def BroadcastFlagEnable(self, inValue):
        """

        Enables the DHCP broadcast flag

        .. versionadded:: 2.11.2

        When a ByteBlower port performs DHCP, the port will use the unicast DHCP method
        as described in the DHCP RFC.  Pre-2.11.2 ByteBlower servers used the legacy
        broadcast technique, which is sometimes detected by devices as a broadcast
        storm.

        :param enable: Whether or not to enable the Broadcast flag
        :type enable: bool

        Example

        This example will enable the Broadcast flag and thus the legacy behavour of the
        ByteBlower server

        .. code-block:: python
           :emphasize-lines: 2

        	dhcp_protocol = port_layer3_config.ProtocolDhcpGet()
        	dhcp_protocol.BroadcastFlagEnable(True)
        	print(dhcp_protocol.BroadcastFlagIsEnabled())

        """
        return _byteblower.DHCPv4Protocol_BroadcastFlagEnable(self, inValue)


    def BroadcastFlagIsEnabled(self):
        """

        Returns whether or not the broadcast flag is enabled.

        .. versionadded:: 2.11.2

        When a ByteBlower port performs DHCP, the port will use the unicast DHCP method
        as described in the DHCP RFC.  Pre-2.11.2 ByteBlower servers used the legacy
        broadcast technique, which is sometimes detected by devices as a broadcast
        storm.

        :return: Whether or not the flag is enabled
        :rtype: bool

        Example

        This example will enable the Broadcast flag and thus the legacy behavour of the
        ByteBlower server

        .. code-block:: python
           :emphasize-lines: 2

        	dhcp_protocol = port_layer3_config.ProtocolDhcpGet()
        	dhcp_protocol.BroadcastFlagEnable(True)
        	print(dhcp_protocol.BroadcastFlagIsEnabled())

        """
        return _byteblower.DHCPv4Protocol_BroadcastFlagIsEnabled(self)


    def ReleaseEnable(self, inValue):
        """

        Enable/disable sending DHCP release during destruction.

        When a ByteBlowerPort is destructed and this port has performed DHCP, such a
        port should release its address. If this behavior is prefered, then this should
        be done by using the Release.Enable method to indicate the ByteBlowerPort
        should release its address if possible. A ByteBlowerPort is able to release its
        address at destruction time if the destination mac address is in the
        ByteBlowerPort's ARP cache. If not, the DHCP release messages will not be sent
        out, because it could delay the whole cleanup.

        If you want to force the release of an address received through DHCP, use
        :meth:`Release`.

        :param enable: Boolean to enable or disable the release of the address at the
                       end of the test.
                       Default: **`True`**

        Example

        This example will disable the automatic release of the DHCP address at the end
        of the test.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.ReleaseEnable(False)

        """
        return _byteblower.DHCPv4Protocol_ReleaseEnable(self, inValue)


    def ReleaseIsEnabled(self):
        """

        Return whether sending DHCP release during destruction is enabled.

        When a ByteBlowerPort is destructed and this port has performed DHCP, it should
        release its address. If this behavior is prefered, then this should be done by
        using the :meth:`ReleaseEnable` method to inidicate the ByteBlowerPort should
        release its address if possible. A ByteBlowerPort is able to release its
        address at destruction time if the destination mac address is in the
        ByteBlowerPort's ARP cache. If not, the DHCP release messages will not be sent
        out, because it could delay the whole cleanup.

        If you want to force the release of an address received through DHCP, use
        :meth:`Release`.

        :return: If the port will release its IP at destruction

        Example

        This example will disable the automatic release of the DHCP address at the end
        of the test.

        .. code-block:: python
           :emphasize-lines: 2

        	dhcp_protocol = port_layer3_config.ProtocolDhcpGet()
        	print(dhcp_protocol.ReleaseIsEnabled())

        """
        return _byteblower.DHCPv4Protocol_ReleaseIsEnabled(self)


    def RetransmissionPolicyGet(self):
        """

        .. deprecated:: TODO
           This method has been renamed, use :meth:`RetransmissionPolicyStringGet`  now.

        """
        return _byteblower.DHCPv4Protocol_RetransmissionPolicyGet(self)


    def RetransmissionPolicySet(self, policy):
        """

        .. deprecated:: TODO
           This method has been renamed, use RetransmissionPolicy.Set.FromString now.

        """
        return _byteblower.DHCPv4Protocol_RetransmissionPolicySet(self, policy)


    def DiscoverInitialTimeoutGet(self):
        """

        Returns the current *<InitialTimeout>* for the DHCP discover stage.

        During the Discover stage, one ore more discover messages will be sent by the
        DHCP client to get an offer message from one or more DHCP servers. The
        *<InitialTimeout>* is the timeout used to decide if the discover message must
        be retransmitted or not. The next timeout value will be calculated using the
        configured retransmission policy.

        :return:  Current '*<InitialTimeout>* value for the discover stage.
                  The unit is nanosecond (ns).

        Example

        This example will get the current *<InitialTimeout>* for the discover stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.DiscoverInitialTimeoutGet())

        """
        return _byteblower.DHCPv4Protocol_DiscoverInitialTimeoutGet(self)


    def DiscoverInitialTimeoutSet(self, inValue):
        """

        Sets the *<InitialTimeout>* for the DHCP discover stage.

        During the Discover stage, one ore more discover messages will be sent by the
        DHCP client to get an offer message from one or more DHCP servers. The
        *<InitialTimeout>* is the timeout used to decide if the discover message must
        be retransmitted or not. The next timeout value will be calculated using the
        configured retransmission policy.

        :param InitialTimeout: New value for the initial timeout.
                               The unit is in nanosecond (ns), but the unit

        Example

        This example will set the *<InitialTimeout>* for the discover stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.DiscoverInitialTimeoutSet(2000000000)


        """
        return _byteblower.DHCPv4Protocol_DiscoverInitialTimeoutSet(self, inValue)


    def DiscoverMaxRetriesGet(self):
        """

        Returns the current maximum retries for the DHCP discover stage.

        During the Discover stage, one ore more discover messages will be sent by the
        DHCP client to get an offer message from one or more DHCP servers. The maximum
        number of times the DHCP client will retransmit the discover message is
        returned by this method.

        :return: Current value for the number of retries in the discover stage.

        Example

        This example will get the current maximum number of retries for the discover stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.DiscoverMaxRetriesGet())

        """
        return _byteblower.DHCPv4Protocol_DiscoverMaxRetriesGet(self)


    def DiscoverMaxRetriesSet(self, inValue):
        """

        Sets the maximum retries for the DHCP discover stage.

        During the Discover stage, one ore more discover messages will be sent by the
        DHCP client to get an offer message from one or more DHCP servers. The maximum
        number of times the DHCP client will retransmit the discover message is
        configured by this method.

        :param maxRetries: The new value for the maximum number of retransmission of
                           the discover message.

        Example

        This example will set the maximum number of retries for the discover stage to
        3 times.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.DiscoverMaxRetriesSet(3)

        """
        return _byteblower.DHCPv4Protocol_DiscoverMaxRetriesSet(self, inValue)


    def RequestInitialTimeoutGet(self):
        """

        Returns the current *<InitialTimeout>* for the DHCP request stage.

        During the Request stage, one ore more request messages will be sent by the
        DHCP client to get an ack message from the DHCP server. The *<InitialTimeout>*
        is the timeout used to decide if the request message must be retransmitted or
        not. The next timeout value will be calculated using the configured retransmission
        policy.

        :return: Current *<InitialTimeout>* value for the request stage.
                 The unit is nanosecond (ns).

        Example

        This example will get the current *<InitialTimeout>* for the request stage.


        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.RequestInitialTimeoutGet())

        """
        return _byteblower.DHCPv4Protocol_RequestInitialTimeoutGet(self)


    def RequestInitialTimeoutSet(self, inTime):
        """

        Sets the *<InitialTimeout>* for the DHCP request stage.

        During the Request stage, one ore more request messages will be sent by the
        DHCP client to get an ack message from the DHCP server. The *<InitialTimeout>*
        is the timeout used to decide if the request message must be retransmitted or
        not. The next timeout value will be calculated using the configured
        retransmission policy.

        :param InitialTimeout: New value for the initial timeout.
                               The unit is in nanosecond (ns).

        Example

        This example will set the *<InitialTimeout>* for the request stage.

        .. code-block:: python
           :emphasize-lines: 1


        	dhcp_protocol.RequestInitialTimeoutSet(3000000000)

        """
        return _byteblower.DHCPv4Protocol_RequestInitialTimeoutSet(self, inTime)


    def RequestMaxRetriesGet(self):
        """

        Returns the current maximum retries for the DHCP Request stage.

        During the Request stage, one ore more request messages will be sent by the
        DHCP client to get an ack message from the DHCP server. The maximum number of
        times the DHCP client will retransmit the request message is returned by this
        method.

        :return:  Current value for the number of retries in the request stage.

        Example

        This example will get the current maximum number of retries to 10 for the request stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.RequestMaxRetriesSet(10)

        """
        return _byteblower.DHCPv4Protocol_RequestMaxRetriesGet(self)


    def RequestMaxRetriesSet(self, inValue):
        """

        Sets the maximum retries for the DHCP Request stage.

        During the Request stage, one ore more request messages will be sent by the
        DHCP client to get an ack message from the DHCP server. The maximum number of
        times the DHCP client will retransmit the request message is configured by
        this method.

        :param maxRetries: The new value for the maximum number of retransmissions of
                           the request message.

        Default value is 5 times

        Example

        This example will set the current maximum number of retries to 10 for the request
        stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.RequestMaxRetriesSet(10)  

        """
        return _byteblower.DHCPv4Protocol_RequestMaxRetriesSet(self, inValue)


    def DHCPv4SessionInfoGet(self):
        """

        Returns the sessionInfo object for this DHCP Session.

        This object contains all the DHCP sessionInfo like Tx,Rx, current leaseTime,
        giaddr etc...

        :return: :class:`DHCPv4SessionInfo`

        Example

        This example will return the DHCPv4SessionInfo object for this DHCP session.

        .. code-block:: python
           :emphasize-lines: 1

           print(dhcpProtocol.DHCPv4SessionInfoGet().DescriptionGet())

        """
        return _byteblower.DHCPv4Protocol_DHCPv4SessionInfoGet(self)

DHCPv4Protocol_swigregister = _byteblower.DHCPv4Protocol_swigregister
DHCPv4Protocol_swigregister(DHCPv4Protocol)

class DHCPv6Protocol(AbstractObject):
    """

    The :class:`.DHCPv6Protocol` is the entry point to configure the DHCPv6 client
     behavior of a ByteBlowerPort.

    A ByteBlowerPort can perform DHCPv6 for configuring IP addresses, IP prefixes
    and/or other parameters required to operate on an IPv6 network.

    A ByteBlowerPort can acquire and combine IP addresses using stateless address
    autoconfiguration, or by using DHCPv6 or static configuration. DHCP tends to be
    preferred at sites where central management of hosts is valued; stateless
    autoconfiguration does not require any sort of central management, and is
    therefore preferable in networks where no management is readily available,
    such as a typical home network.

    IPv6 hosts that use stateless autoconfiguration may require information other
    than an IP address. DHCPv6 can be used to acquire this information, even though
    it is not being used to configure IP addresses.

    DHCPv6 can also be used to deligate prefix information to e.g. home gateways.
    Such gateways require not only an IPv6 address for use in communicating with
    upstream routers, but also an IPv6 prefix for use in configuring devices on the
    downstream side of the router. DHCPv6 Prefix delegation provides a mechanism
    for configuring such routers. ByteBlower currently doesn't support prefix
    delegation yet, but can only be used as a host.

    ByteBlower allows full control of the timing parameters of the DHCPv6 client
    side. The retransmission policy used for DHCPv6 is the one suggested in the
    rfc:`3315`.

    Configurable timing parameters are:

    - Initial Timeout
    - Maximum Duration
    - Maximum Retries
    - Maximum Timeout

    These timing parameters can be applied to the following stages of DHCPv6:

    - Solicit
    - Request
    - Renew
    - Inform
    - Confirm

    For each state the parameters do the following:
        ByteBlower will send up to *<MaxRetries>* messages. The total duration of
        the the state may take up the *<MaxDuration>*. For the first attempt, a
        ByteBlowerPort will wait up to  *<InitialTimeout>* nanoseconds before
        retrying. Each attempt will wait for  maximum '*<MaxTimeout>* nanoseconds
        before concluding that the messages has timed out.




    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DHCPv6Protocol, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DHCPv6Protocol, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PerformAsync(self):
        """

        This method will bootstrap the DHCPv6 process.

        The client will start with sending DHCPv6 solicit messages. This is a
        asynchronous call, so it will return immediately. If you want to see if there
        an exception occured during this async, call the perform method.

        :return: This method will return nothing and return immediately

        .. versionadded:: 2.2

        Example

        This example will start the DHCPv6 process.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.PerformAsync()

        """
        return _byteblower.DHCPv6Protocol_PerformAsync(self)


    def Perform(self):
        """

        This method will bootstrap the DHCPv6 process.

        The client will start with sending DHCPv6 solicit messages. This is a
        synchronous call, so the full DHCPv6 solicit and request will be done once this
        call returns, or an error have occurred.

        :return: This method will return nothing, but will return after DHCP is
                 performed successfully. If DHCP fails, and exception is thrown.

        :raises: :exc:`.DHCPFailed` Thrown if no offer was received during the DHCP
                 solicit stage or no DHCPReply during DHCPRequest stage

        Example

        This example will start the DHCPv6 process.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.Perform()

        """
        return _byteblower.DHCPv6Protocol_Perform(self)


    def Release(self):
        """

        Release the address previously received using DHCPv6

        This method will release the address previously received using DHCP. After
        this, the address will not be used anymore by the ByteBlower port and the DHCP
        server can reuse the address for other DHCP clients. Offcourse, packets sent by
        the ByteBlower port as part of streams can still use the address.

        :return: This method will return nothing, but will return after DHCP Release is
                 performed

        Example

        This example will release the DHCP address.

        .. code-block:: python
           :emphasize-lines: 1

           dhcp_protocol.Release()


        """
        return _byteblower.DHCPv6Protocol_Release(self)


    def ReleaseEnable(self, inValue):
        """

        Enable automatical release when the ByteBlower port is destroyed

        When a ByteBlowerPort is destructed and this port has performed DHCP, such a
        port should release its address. If this behavior is prefered, then this
        should be done by using the :meth:`ReleaseEnable` method to inidicate the
        ByteBlowerPort should release its address if possible. A ByteBlowerPort is able
        to release its address at destruction time if the destination mac address is in
        the ByteBlowerPort's ARP cache. If not, the DHCP release messages will not be
        sent out, because it could delay the whole cleanup.

        If you want to force the release of an address received through DHCP, use
        :meth:`Release`.

        :param enable: bool True to enable the automatic release of the address
                       Default: **`true`**

        Example

        This example will disable the automatic release of the DHCP address at the end
        of the test.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.ReleaseEnable()

        """
        return _byteblower.DHCPv6Protocol_ReleaseEnable(self, inValue)


    def ReleaseIsEnabled(self):
        """

        Returns True when automatic release is enabled

        When a ByteBlowerPort is destructed and this port has performed DHCP, it should
        release its address. If this behavior is prefered, then this should be done by
        using the Release.Enable method to inidicate the ByteBlowerPort should release
        its address if possible. A ByteBlowerPort is able to release its address at
        destruction time if the destination mac address is in the ByteBlowerPort's
        ARP cache. If not, the DHCP release messages will not be sent out, because it
        could delay the whole cleanup.

        If you want to force the release of an address received through DHCP, use
        :meth:`Release`

        :return: If the port will release its IP at destruction

        Example

        This example will disable the automatic release of the DHCP address at the end
        of the test.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.ReleaseIsEnabled())

        """
        return _byteblower.DHCPv6Protocol_ReleaseIsEnabled(self)


    def SolicitInitialTimeoutSet(self, arg2):
        """

        Setter for *<InitialTimeout>* when in the Solicit state.

        :param value: New value for *<InitialTimeout>* for stage Solicit.
                      This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<InitialTimeout>* in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.SolicitInitialTimeoutSet(100000)

        """
        return _byteblower.DHCPv6Protocol_SolicitInitialTimeoutSet(self, arg2)


    def SolicitInitialTimeoutGet(self):
        """

        Getter for *<InitialTimeout>* when in the Solicit state.

        :return: Current value for *<InitialTimeout>* for stage Solicit.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<InitialTimeout>* in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.SolicitInitialTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_SolicitInitialTimeoutGet(self)


    def SolicitMaxTimeoutSet(self, arg2):
        """

        Setter for *<MaxTimeout>* when in the Solicit state.

        :param value: New value for *<MaxTimeout>* for stage Solicit.
                      This is a time value, in nanosecond units.

        This example demonstrates how to set the value for *<MaxTimeout>* in the
        Solicit stage.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.SolicitMaxTimeoutSet(10000)


        """
        return _byteblower.DHCPv6Protocol_SolicitMaxTimeoutSet(self, arg2)


    def SolicitMaxTimeoutGet(self):
        """

        Getter for *<MaxTimeout>* when in the Solicit state.

        :return: Current value for *<MaxTimeout>* for stage Solicit.
                 This is a time value, in nanosecond units.

        Example
        This example demonstrates how to get the value for *<MaxTimeout>* in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.SolicitMaxTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_SolicitMaxTimeoutGet(self)


    def SolicitMaxRetriesSet(self, arg2):
        """

        Setter for *<MaxRetries>* when in the Solicit state.

        :param value: New value for *<MaxRetries>* for stage Solicit.
                      This must be a positive integer value, indicating the number of
                      times the ByteBlowerPort will resend its Solicit message.

        Example

        This example demonstrates how to set the value for *<MaxRetries>* in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.SolicitMaxRetriesGet())

        """
        return _byteblower.DHCPv6Protocol_SolicitMaxRetriesSet(self, arg2)


    def SolicitMaxRetriesGet(self):
        """

        Getter for *<MaxRetries>* when in the Solicit state.

        :return: Current value for *<MaxRetries>* for stage Solicit.
                 This is a positive integer value, indicating the number of times the
                 ByteBlowerPort will resend its Solicit message.

        Example

        This example demonstrates how to get the value for *<MaxRetries>* in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.SolicitMaxRetriesGet())

        """
        return _byteblower.DHCPv6Protocol_SolicitMaxRetriesGet(self)


    def SolicitMaxDurationSet(self, arg2):
        """

        Setter for *<MaxDuration>* when in the Solicit state.

        :param value: New value for *<MaxDuration>* for stage Solicit.
                      This is a time value, in nanosecond units.


        Example
        This example demonstrates how to set the value for *<MaxDuration>* to 1000000 in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.SolicitMaxDurationSet(1000000)

        """
        return _byteblower.DHCPv6Protocol_SolicitMaxDurationSet(self, arg2)


    def SolicitMaxDurationGet(self):
        """

        Getter for *<MaxDuration>* when in the Solicit state.

        :return: Current value for *<MaxDuration>* for stage Solicit.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<MaxDuration>* in the
        Solicit stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.SolicitMaxDurationGet())

        """
        return _byteblower.DHCPv6Protocol_SolicitMaxDurationGet(self)


    def RequestInitialTimeoutSet(self, arg2):
        """

        Setter for *<InitialTimeout>* when in the Request state.

        :param value: New value for *<InitialTimeout>* for stage Request.
                      This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<InitialTimeout>* in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.RequestInitialTimeoutSet(1000000)

        """
        return _byteblower.DHCPv6Protocol_RequestInitialTimeoutSet(self, arg2)


    def RequestInitialTimeoutGet(self):
        """

        Getter for *<InitialTimeout>* when in the Request state.

        :return:  Current value for *<InitialTimeout>* for stage Request.
                  This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<InitialTimeout>* in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.RequestInitialTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_RequestInitialTimeoutGet(self)


    def RequestMaxTimeoutSet(self, arg2):
        """

        Setter for *<MaxTimeout>* when in the Request state.

        :param value: New value for *<MaxTimeout>* for stage Request.
                      This is a time value, in nanosecond units

        Example

        This example demonstrates how to set the value for *<MaxTimeout>* in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.RequestMaxTimeoutSet(1000000)

        """
        return _byteblower.DHCPv6Protocol_RequestMaxTimeoutSet(self, arg2)


    def RequestMaxTimeoutGet(self):
        """

        Getter for *<MaxTimeout>* when in the Request state.

        :return: Current value for *<MaxTimeout>* for stage Request.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<MaxTimeout>* in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.RequestMaxTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_RequestMaxTimeoutGet(self)


    def RequestMaxRetriesSet(self, arg2):
        """

        Setter for *<MaxRetries>* when in the Request
        state.

        :param value: New value for *<MaxRetries>* for stage Request.
                      This must be a positive integer value, indicating the number of
                      times the ByteBlowerPort will resend its Request message.

        Example

        This example demonstrates how to set the value for *<MaxRetries>* to 10 in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.RequestMaxRetriesSet(10)


        """
        return _byteblower.DHCPv6Protocol_RequestMaxRetriesSet(self, arg2)


    def RequestMaxRetriesGet(self):
        """

        Getter for *<MaxRetries>* when in the Request state.

        :return: Current value for *<MaxRetries>* for stage Request.
                 This is a positive integer value, indicating the number of times the
                 ByteBlowerPort will resend its Request message.

        Example

        This example demonstrates how to get the value for *<MaxRetries>* in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.RequestMaxRetriesGet())

        """
        return _byteblower.DHCPv6Protocol_RequestMaxRetriesGet(self)


    def RequestMaxDurationSet(self, arg2):
        """

        Setter for *<MaxDuration>* when in the Request state.

        :param value: New value for *<MaxDuration>* for stage Request.
                      This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<MaxDuration>* to 10 in the
        Request stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.RequestMaxDurationSet(1000000)

        """
        return _byteblower.DHCPv6Protocol_RequestMaxDurationSet(self, arg2)


    def RequestMaxDurationGet(self):
        """

        Getter for *<MaxDuration>* when in the Request state.

        :return: Current value for *<MaxDuration>* for stage Request.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<MaxDuration>* in the Request stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.RequestMaxDurationGet())

        """
        return _byteblower.DHCPv6Protocol_RequestMaxDurationGet(self)


    def ConfirmInitialTimeoutSet(self, arg2):
        """

        Setter for *<InitialTimeout>* when in the Confirm state.

        :param value: New value for *<InitialTimeout>* for stage Confirm.
                      This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<InitialTimeout>* in the
        Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.ConfirmInitialTimeoutSet(100000)

        """
        return _byteblower.DHCPv6Protocol_ConfirmInitialTimeoutSet(self, arg2)


    def ConfirmInitialTimeoutGet(self):
        """

        Getter for *<InitialTimeout>* when in the Confirm state.

        :return: Current value for *<InitialTimeout>* for stage Confirm.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<InitialTimeout>* in the Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.ConfirmInitialTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_ConfirmInitialTimeoutGet(self)


    def ConfirmMaxTimeoutSet(self, arg2):
        """

        Setter for *<MaxTimeout>* when in the Confirm state.

        :param value: New value for *<MaxTimeout>* for stage Confirm.
                      This is a time value, in nanosecond inits.

        Example

        This example demonstrates how to set the value for *<MaxTimeout>* in the
        Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.ConfirmMaxTimeoutSet(5000000000)

        """
        return _byteblower.DHCPv6Protocol_ConfirmMaxTimeoutSet(self, arg2)


    def ConfirmMaxTimeoutGet(self):
        """

        Getter for *<MaxTimeout>* when in the Confirm state.

        :return: Current value for *<MaxTimeout>* for stage Confirm.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<MaxTimeout>* in the
        Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.ConfirmMaxTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_ConfirmMaxTimeoutGet(self)


    def ConfirmMaxRetriesSet(self, arg2):
        """

        Setter for *<MaxRetries>* when in the Confirm state.

        :param value: New value for *<MaxRetries>* for stage Confirm.
                      This must be a positive integer value, indicating the number of
                      times the ByteBlowerPort will resend its Confirmmessage.

        Example
        This example demonstrates how to set the value for *<MaxRetries>* to 12 in the Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.ConfirmMaxRetriesSet(12)

        """
        return _byteblower.DHCPv6Protocol_ConfirmMaxRetriesSet(self, arg2)


    def ConfirmMaxRetriesGet(self):
        """

        Getter for *<MaxRetries>* when in the Confirm state.

        :return:  Current value for *<MaxRetries>* for stage Confirm.
                  This is a positive integer value, indicating the number of times the
                  ByteBlowerPort will resend its Confirm message.

        Example

        This example demonstrates how to get the value for *<MaxRetries>* in the
        Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcpv6.ConfirmMaxRetriesGet())

        """
        return _byteblower.DHCPv6Protocol_ConfirmMaxRetriesGet(self)


    def ConfirmMaxDurationSet(self, arg2):
        """

        Setter for *<MaxDuration>* when in the Confirm state.

        :param value:  New value for *<MaxDuration>* for stage Confirm.
                       This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<MaxDuration>* in the
        Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.ConfirmMaxDurationSet(100000)

        """
        return _byteblower.DHCPv6Protocol_ConfirmMaxDurationSet(self, arg2)


    def ConfirmMaxDurationGet(self):
        """

        Getter for *<MaxDuration>* when in the Confirm state.

        :return: Current value for *<MaxDuration>* for stage Confirm.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<MaxDuration>* in the Confirm stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.ConfirmMaxDurationGet())

        """
        return _byteblower.DHCPv6Protocol_ConfirmMaxDurationGet(self)


    def RenewInitialTimeoutSet(self, arg2):
        """

        Setter for *<InitialTimeout>* when in the Renew state.

        :param value: New value for *<InitialTimeout>* for stage Renew.
                      This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<InitialTimeout>* to 10000 in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.RenewInitialTimeoutSet(10000)


        """
        return _byteblower.DHCPv6Protocol_RenewInitialTimeoutSet(self, arg2)


    def RenewInitialTimeoutGet(self):
        """

        Getter for *<InitialTimeout>* when in the Renew state.

        :return: Current value for *<InitialTimeout>* for stage Renew.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<InitialTimeout>* in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.RenewInitialTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_RenewInitialTimeoutGet(self)


    def RenewMaxTimeoutSet(self, arg2):
        """

        Setter for *<MaxTimeout>* when in the Renew state.

        :param value: New value for *<MaxTimeout>* for stage Renew.
                     This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<MaxTimeout>* in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcpv6.RenewMaxTimeoutSet(5000)


        """
        return _byteblower.DHCPv6Protocol_RenewMaxTimeoutSet(self, arg2)


    def RenewMaxTimeoutGet(self):
        """

        Getter for *<MaxTimeout>* when in the Renew state.

        :return:  Current value for *<MaxTimeout>* for stage Renew.
                  This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<MaxTimeout>* in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.RenewMaxTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_RenewMaxTimeoutGet(self)


    def RenewMaxRetriesSet(self, arg2):
        """

        Setter for *<MaxRetries>* when in the Renew state.

        :param value: New value for *<MaxRetries>* for stage Renew.
                      This must be a positive integer value, indicating the number of
                      times the ByteBlowerPort will resend its Renew message.

        Example

        This example demonstrates how to set the value for *<MaxRetries>* to 12in the Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.RenewMaxRetriesSet(12)


        """
        return _byteblower.DHCPv6Protocol_RenewMaxRetriesSet(self, arg2)


    def RenewMaxRetriesGet(self):
        """

        Getter for *<MaxRetries>* when in the Renew state.

        :return: Current value for *<MaxRetries>* for stage Renew.
                 This is a positive integer value, indicating the number of times the
                 ByteBlowerPort will resend its Renew message.

        Example

        This example demonstrates how to get the value for *<MaxRetries>* in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.RenewMaxRetriesGet())

        """
        return _byteblower.DHCPv6Protocol_RenewMaxRetriesGet(self)


    def RenewMaxDurationSet(self, arg2):
        """

        Setter for *<MaxDuration>* when in the Renew state.

        :param value: New value for *<MaxDuration>* for stage Renew.
                      This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<MaxDuration>* in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.RenewMaxDurationSet(100000)

        """
        return _byteblower.DHCPv6Protocol_RenewMaxDurationSet(self, arg2)


    def RenewMaxDurationGet(self):
        """

        Getter for *<MaxDuration>* when in the Renew state.

        :return: Current value for *<MaxDuration>* for stage Renew.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<MaxDuration>* in the
        Renew stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.RenewMaxDurationGet())

        """
        return _byteblower.DHCPv6Protocol_RenewMaxDurationGet(self)


    def InformInitialTimeoutSet(self, arg2):
        """

        Setter for *<InitialTimeout>* when in the Inform state.

        :param value: New value for *<InitialTimeout>* for stage Inform.
                     This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<InitialTimeout>* in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.InformInitialTimeoutSet()

        """
        return _byteblower.DHCPv6Protocol_InformInitialTimeoutSet(self, arg2)


    def InformInitialTimeoutGet(self):
        """

        Getter for *<InitialTimeout>* when in the Inform state.

        :return: Current value for *<InitialTimeout>* for stage Inform.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<InitialTimeout>* in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.InformInitialTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_InformInitialTimeoutGet(self)


    def InformMaxTimeoutSet(self, arg2):
        """

        Setter for *<MaxTimeout>* when in the Inform state.

        :param value: New value for *<MaxTimeout>* for stage Inform.
                      This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<MaxTimeout>* in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.InformMaxTimeoutSet(100000)

        """
        return _byteblower.DHCPv6Protocol_InformMaxTimeoutSet(self, arg2)


    def InformMaxTimeoutGet(self):
        """

        Getter for *<MaxTimeout>* when in the Inform state.

        :return: Current value for *<MaxTimeout>* for stage Inform.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<MaxTimeout>* in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.InformMaxTimeoutGet())

        """
        return _byteblower.DHCPv6Protocol_InformMaxTimeoutGet(self)


    def InformMaxRetriesSet(self, arg2):
        """

        Setter for *<MaxRetries>* when in the Inform state.

        :param value: New value for *<MaxRetries>* for stage Inform.
                      This must be a positive integer value, indicating the number of
                      times the ByteBlowerPort will resend its Inform message.

        Example

        This example demonstrates how to set the value for *<MaxRetries>* to 5 in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.InformMaxRetriesSet(5)


        """
        return _byteblower.DHCPv6Protocol_InformMaxRetriesSet(self, arg2)


    def InformMaxRetriesGet(self):
        """

        Getter for *<MaxRetries>* when in the Inform state.

        :return: Current value for *<MaxRetries>* for stage Inform.
                 This is a positive integer value, indicating the number of times the
                 ByteBlowerPort will resend its Inform message.

        Example

        This example demonstrates how to get the value for *<MaxRetries>* in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.InformMaxRetriesGet())

        """
        return _byteblower.DHCPv6Protocol_InformMaxRetriesGet(self)


    def InformMaxDurationSet(self, arg2):
        """

        Setter for *<MaxDuration>* when in the Inform state.

        :param value: New value for *<MaxDuration>* for stage Inform.
                      This is a time value, in nanosecond units.

        Example

        This example demonstrates how to set the value for *<MaxDuration>* to 100000 in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

        	dhcp_protocol.InformMaxDurationSet(100000)

        """
        return _byteblower.DHCPv6Protocol_InformMaxDurationSet(self, arg2)


    def InformMaxDurationGet(self):
        """

        Getter for *<MaxDuration>* when in the Inform state.

        :return: Current value for *<MaxDuration>* for stage Inform.
                 This is a time value, in nanosecond units.

        Example

        This example demonstrates how to get the value for *<MaxDuration>* in the
        Inform stage.

        .. code-block:: python
           :emphasize-lines: 1

        	print(dhcp_protocol.InformMaxDurationGet())

        """
        return _byteblower.DHCPv6Protocol_InformMaxDurationGet(self)


    def RetransmissionPolicyGet(self):
        return _byteblower.DHCPv6Protocol_RetransmissionPolicyGet(self)

    def RetransmissionPolicySet(self, policy):
        return _byteblower.DHCPv6Protocol_RetransmissionPolicySet(self, policy)

    def DHCPv6SessionInfoGet(self):
        """

        Returns the sessionInfo object for this DHCP Session.

        This object contains all the DHCP sessionInfo like Tx,Rx

        :return: The :class:`DHCPv6SessionInfo` object for this DHCP session

        Example

        This example will return the :class:`DHCPv6SessionInfo` object for this DHCP
        session.

        .. code-block:: python
           :emphasize-lines: 1


        	print(dhcp_protocol.DHCPv6SessionInfoGet().DescriptionGet())

        """
        return _byteblower.DHCPv6Protocol_DHCPv6SessionInfoGet(self)

DHCPv6Protocol_swigregister = _byteblower.DHCPv6Protocol_swigregister
DHCPv6Protocol_swigregister(DHCPv6Protocol)

TCPConnectionState_CLOSED = _byteblower.TCPConnectionState_CLOSED
TCPConnectionState_LISTEN = _byteblower.TCPConnectionState_LISTEN
TCPConnectionState_SYN_RECEIVED = _byteblower.TCPConnectionState_SYN_RECEIVED
TCPConnectionState_SYN_SENT = _byteblower.TCPConnectionState_SYN_SENT
TCPConnectionState_ESTABLISHED = _byteblower.TCPConnectionState_ESTABLISHED
TCPConnectionState_FIN_WAIT_1 = _byteblower.TCPConnectionState_FIN_WAIT_1
TCPConnectionState_FIN_WAIT_2 = _byteblower.TCPConnectionState_FIN_WAIT_2
TCPConnectionState_CLOSING = _byteblower.TCPConnectionState_CLOSING
TCPConnectionState_CLOSE_WAIT = _byteblower.TCPConnectionState_CLOSE_WAIT
TCPConnectionState_LAST_ACK = _byteblower.TCPConnectionState_LAST_ACK
TCPConnectionState_TIME_WAIT = _byteblower.TCPConnectionState_TIME_WAIT

def ConvertTCPConnectionStateToString(inState):
    return _byteblower.ConvertTCPConnectionStateToString(inState)
ConvertTCPConnectionStateToString = _byteblower.ConvertTCPConnectionStateToString

def ParseTCPConnectionStateFromString(inState):
    return _byteblower.ParseTCPConnectionStateFromString(inState)
ParseTCPConnectionStateFromString = _byteblower.ParseTCPConnectionStateFromString
TCPCongestionAvoidanceAlgorithm__None = _byteblower.TCPCongestionAvoidanceAlgorithm__None
TCPCongestionAvoidanceAlgorithm_NewReno = _byteblower.TCPCongestionAvoidanceAlgorithm_NewReno
TCPCongestionAvoidanceAlgorithm_NewRenoWithCubic = _byteblower.TCPCongestionAvoidanceAlgorithm_NewRenoWithCubic
TCPCongestionAvoidanceAlgorithm_Sack = _byteblower.TCPCongestionAvoidanceAlgorithm_Sack
TCPCongestionAvoidanceAlgorithm_SackWithCubic = _byteblower.TCPCongestionAvoidanceAlgorithm_SackWithCubic

def ConvertTCPCongestionAvoidanceAlgorithmToString(inTCAA):
    return _byteblower.ConvertTCPCongestionAvoidanceAlgorithmToString(inTCAA)
ConvertTCPCongestionAvoidanceAlgorithmToString = _byteblower.ConvertTCPCongestionAvoidanceAlgorithmToString

def ParseTCPCongestionAvoidanceAlgorithmFromString(inValue):
    return _byteblower.ParseTCPCongestionAvoidanceAlgorithmFromString(inValue)
ParseTCPCongestionAvoidanceAlgorithmFromString = _byteblower.ParseTCPCongestionAvoidanceAlgorithmFromString
HTTPRequestMethod_Undefined = _byteblower.HTTPRequestMethod_Undefined
HTTPRequestMethod_Options = _byteblower.HTTPRequestMethod_Options
HTTPRequestMethod_Get = _byteblower.HTTPRequestMethod_Get
HTTPRequestMethod_Head = _byteblower.HTTPRequestMethod_Head
HTTPRequestMethod_Post = _byteblower.HTTPRequestMethod_Post
HTTPRequestMethod_Put = _byteblower.HTTPRequestMethod_Put
HTTPRequestMethod_Delete = _byteblower.HTTPRequestMethod_Delete
HTTPRequestMethod_Trace = _byteblower.HTTPRequestMethod_Trace

def ConvertHTTPRequestMethodToString(inHTTPRequestMethod):
    return _byteblower.ConvertHTTPRequestMethodToString(inHTTPRequestMethod)
ConvertHTTPRequestMethodToString = _byteblower.ConvertHTTPRequestMethodToString

def ParseHTTPRequestMethodFromString(inHTTPRequestMethod):
    return _byteblower.ParseHTTPRequestMethodFromString(inHTTPRequestMethod)
ParseHTTPRequestMethodFromString = _byteblower.ParseHTTPRequestMethodFromString
HTTPRequestStatus_Configuration = _byteblower.HTTPRequestStatus_Configuration
HTTPRequestStatus_Scheduled = _byteblower.HTTPRequestStatus_Scheduled
HTTPRequestStatus_Connecting = _byteblower.HTTPRequestStatus_Connecting
HTTPRequestStatus_Running = _byteblower.HTTPRequestStatus_Running
HTTPRequestStatus_Finished = _byteblower.HTTPRequestStatus_Finished
HTTPRequestStatus_Stopped = _byteblower.HTTPRequestStatus_Stopped
HTTPRequestStatus_Error = _byteblower.HTTPRequestStatus_Error

def ConvertHTTPRequestStatusToString(inHTTPRequestStatus):
    return _byteblower.ConvertHTTPRequestStatusToString(inHTTPRequestStatus)
ConvertHTTPRequestStatusToString = _byteblower.ConvertHTTPRequestStatusToString

def ParseHTTPRequestStatusFromString(inStr):
    return _byteblower.ParseHTTPRequestStatusFromString(inStr)
ParseHTTPRequestStatusFromString = _byteblower.ParseHTTPRequestStatusFromString
HTTPMultiClientStatus_Configuration = _byteblower.HTTPMultiClientStatus_Configuration
HTTPMultiClientStatus_Scheduled = _byteblower.HTTPMultiClientStatus_Scheduled
HTTPMultiClientStatus_Running = _byteblower.HTTPMultiClientStatus_Running
HTTPMultiClientStatus_Finished = _byteblower.HTTPMultiClientStatus_Finished
HTTPMultiClientStatus_Stopped = _byteblower.HTTPMultiClientStatus_Stopped

def ConvertHTTPMultiClientStatusToString(inHTTPRequestStatus):
    return _byteblower.ConvertHTTPMultiClientStatusToString(inHTTPRequestStatus)
ConvertHTTPMultiClientStatusToString = _byteblower.ConvertHTTPMultiClientStatusToString
HTTPRequestType_Size = _byteblower.HTTPRequestType_Size
HTTPRequestType_Duration = _byteblower.HTTPRequestType_Duration

def ConvertHTTPRequestTypeToString(inHTTPRequestType):
    return _byteblower.ConvertHTTPRequestTypeToString(inHTTPRequestType)
ConvertHTTPRequestTypeToString = _byteblower.ConvertHTTPRequestTypeToString

def ParseHTTPRequestTypeFromString(s):
    return _byteblower.ParseHTTPRequestTypeFromString(s)
ParseHTTPRequestTypeFromString = _byteblower.ParseHTTPRequestTypeFromString
class CapturedFrame(AbstractObject):
    """

    A representation of a Captured Frame captured using a :class:`CaptureRawPacket`.

    Example

    .. code-block:: python

    	result = captureRaw.ResultGet()
        frame = result.FramesGetByIndex(0)
        print(frame.LengthGet())

    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CapturedFrame, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CapturedFrame, name)
    __repr__ = _swig_repr

    def __init__(self, inAbstractObject, inTimestamp, bytes):
        this = _byteblower.new_CapturedFrame(inAbstractObject, inTimestamp, bytes)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def BufferGet(self):
        return _byteblower.CapturedFrame_BufferGet(self)

    def LengthGet(self):
        """

        Gets the packet length of this CapturedFrame. This is the length without CRC.

        :return: Lenght of the packet without CRC

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(frame.LengthGet())

        """
        return _byteblower.CapturedFrame_LengthGet(self)


    def TimestampGet(self):
        """

        Gets timestamp [NS] of this CapturedFrame.

        :return: Timestamp in nanoseconds

        Example

        This example gets the timestamp of the captured frame

        .. code-block:: python
           :emphasize-lines: 1

            print(frame.TimestampGet())

        """
        return _byteblower.CapturedFrame_TimestampGet(self)


    def BytesGet(self):
        """

        Gets the bytes in HEX format of this CapturedFrame.

        :return:  hex representation of the content of the captured frame

        Example

        This example gets the bytes in HEX

        .. code-block:: python
           :emphasize-lines: 1

        	print(frame.BytesGet())

        """
        return _byteblower.CapturedFrame_BytesGet(self)

CapturedFrame_swigregister = _byteblower.CapturedFrame_swigregister
CapturedFrame_swigregister(CapturedFrame)

class CapturedHTTPData(AbstractObject):
    """

    This class represents captured HTTP data.

    The HTTP data is a local snapshot of the HTTP data received in a HTTP session
    at the ByteBlower Server.

    HTTP data capture is currently supported on HTTP Client objects.
    .. code-block:: python
       :emphasize-lines: 2

    	captureData = httpClient.CaptureGet()
    	print(captureData.HttpSizeGet())



    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CapturedHTTPData, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CapturedHTTPData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def HttpSizeGet(self):
        """

        Returns the number of captured bytes of HTTP data.

        The value includes the size of both HTTP header and payload.

        .. note:: This only outputs the local cached HTTP data. The local cached
                  HTTP data is a snapshot of the HTTP data received at the ByteBlower
                  server. If no local snapshot was available yet, an initial one will
                  be obtained from the server. You may want to synchronize the local
                  cached data using the ::Refresh method.

        :return: Size of captured HTTP data in Bytes.

        :raises: ByteBlower.Protocol.NotSupported - When the ByteBlower Server does
                 not support HTTP Client captures

        Example

        Suppose we sent a HTTP GET request for an index.html test page

        .. code-block:: python
           :emphasize-lines: 1

        	print(captureData.HttpSizeGet())


        """
        return _byteblower.CapturedHTTPData_HttpSizeGet(self)


    def HttpBytesGet(self):
        """

        Returns the captured HTTP data.

        The data includes both HTTP header and payload.

        .. note:: This only outputs the local cached HTTP data. The local cached
                  HTTP data is a snapshot of the HTTP data received at the ByteBlower
                  server. If no local snapshot was available yet, an initial one will
                  be obtained from the server. You may want to synchronize the local
                  cached data using the :meth:`Refresh` method.

        :return: Captured HTTP data as string.

        :raises: ByteBlower.Protocol.NotSupported - When the ByteBlower Server does not
                 support HTTP Client captures

        Example

        Suppose we sent a HTTP GET request for an 'index.html' test page


        .. code-block:: python
        	:emphasize-lines: 1

        	print(captureData.HttpBytesGet())


        .. code-block:: http

            HTTP/1.1 200 OK
            Date: Wed, 12 Feb 2014 13:23:32 GMT
            Server: Apache/2.2.22 (Debian)
            Last-Modified: Thu, 10 Feb 2011 11:32:16 GMT
            ETag: "27c083-b1-49bebeefcb000"
            Accept-Ranges: bytes
            Content-Length: 177
            Vary: Accept-Encoding
            Content-Type: text/html
            X-Pad: avoid browser bug
            <html><body><h1>It works!</h1>
            <p>This is the default web page for this server.</p>
            <p>The web server software is running but no content has been added,
            yet.</p>
            </body></html>

        """
        return _byteblower.CapturedHTTPData_HttpBytesGet(self)


    def HttpBytesSave(self, inFileName):
        """

        Saves the captured HTTP data to file.

        .. note:: This only outputs the local cached HTTP data. The local cached HTTP
                  data is a snapshot of the HTTP data received at the ByteBlower
                  server. If no local snapshot was available yet, an initial one will
                  be obtained from the server. You may want to synchronize the local
                  cached data using the :meth:`Refresh` method.

        :param fileName: Destination filename for the captured HTTP data.

        :raises: ByteBlower.Protocol.NotSupported - When the ByteBlower Server does not
                 support HTTP Client captures

        Example

        Stores all HTTP data captured to `c:.txt`

        .. code-block:: python
        	:emphasize-lines: 1

        	captureData.HttpBytesSave('httpResults.txt')


        """
        return _byteblower.CapturedHTTPData_HttpBytesSave(self, inFileName)

CapturedHTTPData_swigregister = _byteblower.CapturedHTTPData_swigregister
CapturedHTTPData_swigregister(CapturedHTTPData)

class CaptureRawPacket(Capture):
    """

    This class is used to capture the raw packet data that is received on the
    Physical interface that is associated with a ByteBlowerPort.

    With an :class:`.CaptureRawpacket` you can capture the data that is received by the
    ByteBlower Port and save this to a pcap file on your pc. You can also apply a
    filter (BPF-style) to only capture the packets of your interest.

    Example

    .. code-block:: python

    	captureRaw = bbPort2.RxCaptureBasicAdd()
        captureRaw.FilterSet('ip dst 1.1.1.2')
        captureRaw.Start()
    	#...
    	captureRaw.Stop()
    	result = captureRaw.ResultGet()
    	print(result.DescriptionGet())



    """

    __swig_setmethods__ = {}
    for _s in [Capture]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CaptureRawPacket, name, value)
    __swig_getmethods__ = {}
    for _s in [Capture]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CaptureRawPacket, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def FilterSet(self, inFilter):
        """

        Sets a BPF filter on a RX object.

        .. note:: Configuring a new filter string does not reset the counter values
                  which were triggered by a previous filter string.

        :param bpfString: Valid BPF filter string. For creating valid BPF filter
                          strings, please have a look at
                          http://www.tcpdump.org/#documentation for more information.

        :raises: ByteBlower.Rx.Filter.CompilationFailed - When an invalid BPF filter
                 string is given.

        :raises: ByteBlower.InvalidFilter - When an invalid BPF filter string is given.

        Example

        This will filter only UDP traffic.  Set the filter on packets that match:

        - source and destination IPv4 address
        - UDP traffic with given destination and source UDP port
        - (layer2) frame length (without CRC!)

        .. code-block:: python
           :emphasize-lines: 1

            captureRaw.FilterSet('ip dst 1.1.1.2')
        -

        """
        return _byteblower.CaptureRawPacket_FilterSet(self, inFilter)


    def FilterGet(self):
        """

        Returns the current installed BPF filter string.

        The filter string can be configured using :meth:`FilterSet`

        :return: The current BPF filter string

        Example

        Suppose we configured the trigger with filter string:
        where `ipv4_1` and `ipv4_2` are :class:`.IPv4Configuration` objects and
        `frameSize` is the (layer2) size of the frames (without CRC!). The BPF
        filter string would then become for example:

        .. code-block:: python
           :emphasize-lines: 1

            print(captureRaw.FilterGet())

        """
        return _byteblower.CaptureRawPacket_FilterGet(self)


    def FileNameRemoteGet(self):
        return _byteblower.CaptureRawPacket_FileNameRemoteGet(self)

    def Start(self):
        """

        Start capturing.

        .. note:: Calling Start while already running does not throw an exception.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            captureRaw.Start()

        """
        return _byteblower.CaptureRawPacket_Start(self)


    def Stop(self):
        """

        Stop capturing.

        .. note:: Calling Stop while not running does not throw an exception.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	captureRaw.Stop()


        """
        return _byteblower.CaptureRawPacket_Stop(self)


    def ResultGet(self):
        """

        Returns the capture result.

        :return: :class:`.CaptureResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	result = captureRaw.ResultGet()


        """
        return _byteblower.CaptureRawPacket_ResultGet(self)

CaptureRawPacket_swigregister = _byteblower.CaptureRawPacket_swigregister
CaptureRawPacket_swigregister(CaptureRawPacket)

class CaptureResultSnapshot(AbstractRefreshableResult):
    """

    This class represents the result of a :class:`.CaptureRawpacket`.

    It contains the metrics and the frames that are captured.
    To get an update of the values use ::Refresh.

    Example

    .. code-block:: python

    	captureRaw = bbPort2.RxCaptureBasicAdd()
        captureRaw.FilterSet('ip dst 1.1.1.2')
        captureRaw.Start()
    	...
    	captureRaw.Stop()
        resultSnapshot = captureRaw.ResultGet()

    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CaptureResultSnapshot, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CaptureResultSnapshot, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        """

        Clears the counters and deletes the captured packets from the capture.

        Example

        This example returns the captured frames

        .. code-block:: python
           :emphasize-lines: 1

            resultSnapshot.Clear()

        """
        return _byteblower.CaptureResultSnapshot_Clear(self)


    def PacketCountGet(self):
        """

        Returns the number of packets captured.

        :return:  The number of packets this capture captured

        Example

        This example returns the number of packets captured

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultSnapshot.PacketCountGet())

        """
        return _byteblower.CaptureResultSnapshot_PacketCountGet(self)


    def ByteCountGet(self):
        """

        Returns the number of bytes captured.

        :return: The number of bytes captured

        Example

        This example returns the number of bytes captured

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnapshot.ByteCountGet())

        """
        return _byteblower.CaptureResultSnapshot_ByteCountGet(self)


    def ErrorCountGet(self):
        """

        Returns Error count.

        :return: Returns the number of packets with incorrect CRC

        Example

        This example returns the number of corrupt frames

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnapshot.ErrorCountGet())

        """
        return _byteblower.CaptureResultSnapshot_ErrorCountGet(self)


    def CaptureDurationGet(self):
        """

        Returns the duration of the capture.

        :return:  The duration of the capture in nanoseconds

        Example

        This example returns the duration of the capture

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultSnapshot.CaptureDurationGet())

        """
        return _byteblower.CaptureResultSnapshot_CaptureDurationGet(self)


    def StateNameGet(self):
        """

        Returns the status of the current capture.

        :return:  Returns current state of this capture.

        Possible values are:
        - unknown
        - unavailable
        - inactive
        - active}

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnapshot.StateNameGet())

        """
        return _byteblower.CaptureResultSnapshot_StateNameGet(self)


    def FramesGet(self):
        """

        Returns a list of :class:`CapturedFrameList`.

        :return: :class:`CapturedFrameList`

        Example

        This example returns the captured frames

        .. code-block:: python
           :emphasize-lines: 1

        	framesResult = resultSnapshot.FramesGet()
            for frame in framesResult:
        		print(frame.DescriptionGet())

        """
        return _byteblower.CaptureResultSnapshot_FramesGet(self)


    def FramesGetByIndex(self, index):
        """

        Returns a Rx.Capture.Frame at the provided index.

        :return:  a :class:`CapturedFrame`

        Example

        This example returns the captured frame given by the index

        .. code-block:: python
           :emphasize-lines: 1

            frame = resultSnapshot.FramesGetByIndex(0)

        """
        return _byteblower.CaptureResultSnapshot_FramesGetByIndex(self, index)


    def PcapLastFileNameGet(self):
        """

        The fileName where the last pcap was saved to.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnapshot.PcapLastFileNameGet())
        	# prints: pcapResult.pcap

        """
        return _byteblower.CaptureResultSnapshot_PcapLastFileNameGet(self)


    def PcapSave(self, filename):
        """

        Stores the captured frames into a `pcap` file.

        The stored capture file can be opened by e.g. `wireshark`.

        :param fileName: - Destination filename for the capture file.

        :raises: <python_error> - No pcap support found: When the pcap library is not
                 installed on the ByteBlower client PC.

        :raises: ByteBlower.Rx.Capture.GetFailed - When no results are available or
                 when an exception occurred while obtaining the results.

        :raises: ByteBlower.Rx.Capture.GetFramesFailed - Invalid captured packet offset.

        Example

        Stores all packets captured by filter to `c:\pcap`

        .. code-block:: python
           :emphasize-lines: 1

        	resultSnapshot.PcapSave('resultPcap.pcap')



        """
        return _byteblower.CaptureResultSnapshot_PcapSave(self, filename)


    def PcapNanoSave(self, filename):
        """

        Stores the captured frames into a `pcap` file.

        The stored capture file can be opened by e.g. `wireshark`.

        :param: - Destination filename for the capture file.

        :raises: <python_error> - No pcap support found: When the pcap library is not
                 installed on the ByteBlower client PC.
        :raises: ByteBlower.Rx.Capture.GetFailed - When no results are available or
                 when an exception occurred while obtaining the results.
        :raises: ByteBlower.Rx.Capture.GetFramesFailed - Invalid captured packet offset.

        Example

        Stores all packets captured by filter to `c:\pcap` which is in PcapNano format

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           server.PortCreate('trunk-1-1')
           # TODO??

        """
        return _byteblower.CaptureResultSnapshot_PcapNanoSave(self, filename)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp when the counters of this object where last refreshed.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultSnapshot.RefreshTimestampGet())

        """
        return _byteblower.CaptureResultSnapshot_RefreshTimestampGet(self)

CaptureResultSnapshot_swigregister = _byteblower.CaptureResultSnapshot_swigregister
CaptureResultSnapshot_swigregister(CaptureResultSnapshot)

class TCPSessionInfo(AbstractObject):
    """

    Class containing info about the TCP session.
    Example

    .. code-block:: python

    	tcpSessionInfo = httpSessionInfo.TcpSessionInfoGet()
        # print an integer which indicates a certain State
        print(tcpSessionInfo.ConnectionStateGet())



    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TCPSessionInfo, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TCPSessionInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ConnectionStateGet(self):
        """

        Returns the current TCP connection state.

        :return: :class:`TCPConnectionState`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(tcpSessionInfo.ConnectionStateGet())


        """
        return _byteblower.TCPSessionInfo_ConnectionStateGet(self)


    def CongestionAvoidanceAlgorithmGet(self):
        """

        Returns the congestion avoidance algorithm used in this TCP session.

        :return: CongestionAvoidanceAlgorithm

        Possible values are:

        - Sack
        - None
        - NewReno
        - ServerDefault

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpSessionInfo.CongestionAvoidanceAlgorithmGet() == TCPCongestionAvoidanceAlgorithm.NewReno)


        """
        return _byteblower.TCPSessionInfo_CongestionAvoidanceAlgorithmGet(self)


    def MaximumSegmentSizeGet(self):
        """

        Returns the maximum segment size this TCP connection is allowed to use when
        transmitting data..

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(tcpSessionInfo.MaximumSegmentSizeGet())


        """
        return _byteblower.TCPSessionInfo_MaximumSegmentSizeGet(self)


    def ResultGet(self):
        """

        Returns the Layer4.Tcp.ResultSnapshot for this session containing the current
        result counters.

        The snapshot contains byte counters and time values.

        :return: :class:`.TCPResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(tcpSessionInfo.ResultGet().DescriptionGet())


        """
        return _byteblower.TCPSessionInfo_ResultGet(self)


    def ResultHistoryGet(self):
        """

        Returns the Layer4.Tcp.ResultHistory for this session.

        :return: :class:`.TCPResultHistory`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(tcpSessionInfo.ResultHistoryGet().DescriptionGet())


        """
        return _byteblower.TCPSessionInfo_ResultHistoryGet(self)

TCPSessionInfo_swigregister = _byteblower.TCPSessionInfo_swigregister
TCPSessionInfo_swigregister(TCPSessionInfo)

class TCPTunnel(AbstractObject):
    """

    Creates a TCP port forwarding configuration between a local host and a remote
    server.

    Traffic is forwarded between localhost and the remote endpoint.

    .. versionadded:: 2.7.0

    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TCPTunnel, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TCPTunnel, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PortGet(self):
        return _byteblower.TCPTunnel_PortGet(self)

    def LocalPortSet(self, inLocalPort):
        """

        Configures the local port number of the port mapping configuration.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	tcpTunnel.LocalPortSet(12345)



        """
        return _byteblower.TCPTunnel_LocalPortSet(self, inLocalPort)


    def RemotePortSet(self, inLocalPort):
        """

        Configures the remote port to which data will be forwarded.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	tcpTunnel.LocalPortSet(80)



        """
        return _byteblower.TCPTunnel_RemotePortSet(self, inLocalPort)


    def RemoteAddressSet(self, remote_address):
        """

        Configures the IP of the remote endpoint.

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	tcpTunnel.RemoteAddressSet('192.168.1.10')



        """
        return _byteblower.TCPTunnel_RemoteAddressSet(self, remote_address)


    def Start(self):
        """

        Activates the port mapping configuration.

        Once the port mapping is activated it becomes possible to access the remote
        endpoint through external applications like curl, wget, ssh or the a web
        browser.

        For example:

            curl --insecure https://localhost:123435

            wget --no-check-certificate https://localhost:12345

        Of course, you can also use Tcl's networking packages like http.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	tcpTunnel.Start()


        """
        return _byteblower.TCPTunnel_Start(self)


    def Stop(self):
        """

        Stops the port mapping configuration.

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	tcpTunnel.Stop()



        """
        return _byteblower.TCPTunnel_Stop(self)

TCPTunnel_swigregister = _byteblower.TCPTunnel_swigregister
TCPTunnel_swigregister(TCPTunnel)

class TCPResultData(AbstractObject):
    """

    Contains static TCP result counters.  

    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TCPResultData, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TCPResultData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ConnectionStateGet(self):
        return _byteblower.TCPResultData_ConnectionStateGet(self)

    def TxSegmentCountTotalGet(self):
        """

        Returns the total number of transmitted segments.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RxSegmentCountTotalGet())



        """
        return _byteblower.TCPResultData_TxSegmentCountTotalGet(self)


    def RxSegmentCountTotalGet(self):
        """

        Returns the total number of received segments.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(tcpResultData.RxSegmentCountTotalGet())



        """
        return _byteblower.TCPResultData_RxSegmentCountTotalGet(self)


    def RxSegmentCountOutOfOrderGet(self):
        """

        Returns the number of segments that were received out of order.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RxSegmentCountOutOfOrderGet())



        """
        return _byteblower.TCPResultData_RxSegmentCountOutOfOrderGet(self)


    def TxByteCountHeaderGet(self):
        """

        Returns the number of transmitted TCP header bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TxByteCountHeaderGet())



        """
        return _byteblower.TCPResultData_TxByteCountHeaderGet(self)


    def TxByteCountPayloadGet(self):
        """

        Returns the number of transmitted TCP payload bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TxByteCountPayloadGet())




        """
        return _byteblower.TCPResultData_TxByteCountPayloadGet(self)


    def TxByteCountTotalGet(self):
        """

        Returns the total number of bytes transmitted on the current TCP connection.  

        This is the sum of the tranmitted TCP header and payload bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TxByteCountTotalGet())



        """
        return _byteblower.TCPResultData_TxByteCountTotalGet(self)


    def RxByteCountHeaderGet(self):
        """

        Returns the number of received TCP header bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RxByteCountHeaderGet())



        """
        return _byteblower.TCPResultData_RxByteCountHeaderGet(self)


    def RxByteCountPayloadGet(self):
        """

        Returns the number of received TCP payload bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RxByteCountPayloadGet())



        """
        return _byteblower.TCPResultData_RxByteCountPayloadGet(self)


    def RxByteCountTotalGet(self):
        """

        Returns the total number of bytes received on the current TCP connection.  

        This is the sum of the received TCP header and payload bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RxByteCountTotalGet())



        """
        return _byteblower.TCPResultData_RxByteCountTotalGet(self)


    def ReceiverWindowCurrentGet(self):
        """

        Returns the current TCP receiver window (RWND).  

        The receiver window is the maximum number of bytes that the remote connection 
        is currently able to receive.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(tcpResultData.ReceiverWindowCurrentGet())



        """
        return _byteblower.TCPResultData_ReceiverWindowCurrentGet(self)


    def ReceiverWindowMinimumGet(self):
        """

        Returns the smallest recorded TCP receiver window (RWND).  

        The receiver window is the maximum number of bytes that the remote connection 
        is currently able to receive.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.ReceiverWindowMinimumGet())



        """
        return _byteblower.TCPResultData_ReceiverWindowMinimumGet(self)


    def ReceiverWindowMaximumGet(self):
        """

        Returns the largest recorded TCP receiver window (RWND).  

        The receiver window is the maximum number of bytes that the remote connection 
        is currently able to receive.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.ReceiverWindowMaximumGet())



        """
        return _byteblower.TCPResultData_ReceiverWindowMaximumGet(self)


    def CongestionWindowCurrentGet(self):
        """

        Returns the current TCP congestion window (CWND).  

        The congestion window is the maximum number of bytes that we are allowed to
        send before receiving a new TCP ACK.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.CongestionWindowCurrentGet())



        """
        return _byteblower.TCPResultData_CongestionWindowCurrentGet(self)


    def CongestionWindowMinimumGet(self):
        """

        Returns the smallest recorded TCP congestion window (CWND).  

        The congestion window is the maximum number of bytes that we are allowed to
        send before receiving a new TCP ACK.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(tcpResultData.CongestionWindowMinimumGet())



        """
        return _byteblower.TCPResultData_CongestionWindowMinimumGet(self)


    def CongestionWindowMaximumGet(self):
        """

        Returns the largest recorded TCP congestion window (CWND).  

        The congestion window is the maximum number of bytes that we are allowed to
        send before receiving a new TCP ACK.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.CongestionWindowMaximumGet())



        """
        return _byteblower.TCPResultData_CongestionWindowMaximumGet(self)


    def FlightSizeCurrentGet(self):
        """

        Returns the number of bytes that are currently in-flight.  

        The flight size is the number of bytes that has been transmitted but not yet
        acknowledged.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.FlightSizeCurrentGet())O


        """
        return _byteblower.TCPResultData_FlightSizeCurrentGet(self)


    def FlightSizeMinimumGet(self):
        """

        Returns the smallest recorded flight-size.  

        The flight size is the number of bytes that has been transmitted but not yet 
        acknowledged.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.FlightSizeMinimumGet())



        """
        return _byteblower.TCPResultData_FlightSizeMinimumGet(self)


    def FlightSizeMaximumGet(self):
        """

        Returns the largest recorded flight-size.  

        The flight size is the number of bytes that has been transmitted but not yet
        acknowledged.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.FlightSizeMaximumGet())



        """
        return _byteblower.TCPResultData_FlightSizeMaximumGet(self)


    def SlowStartThresholdCurrentGet(self):
        """

        Returns the current TCP slow-start threshold (SSTHRESH).  

        The slow-start threshold indicates the congestion window value where the 
        congestion avoidance algorithm switches from "slow-start"-mode to
        "congestion-avoidance"-mode.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.SlowStartThresholdCurrentGet())



        """
        return _byteblower.TCPResultData_SlowStartThresholdCurrentGet(self)


    def SlowStartThresholdMinimumGet(self):
        """

        Returns the smallest recorded TCP slow-start threshold (SSTHRESH).  

        The slow-start threshold indicates the congestion window value where the 
        congestion avoidance algorithm switches from "slow-start"-mode to
        "congestion-avoidance"-mode.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.SlowStartThresholdMinimumGet())



        """
        return _byteblower.TCPResultData_SlowStartThresholdMinimumGet(self)


    def SlowStartThresholdMaximumGet(self):
        """

        Returns the largest recorded TCP slow-start threshold (SSTHRESH).  

        The slow-start threshold indicates the congestion window value where the 
        congestion avoidance algorithm switches from "slow-start"-mode to
        "congestion-avoidance"-mode.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.SlowStartThresholdMaximumGet())



        """
        return _byteblower.TCPResultData_SlowStartThresholdMaximumGet(self)


    def RoundTripTimeMinimumGet(self):
        """

        Returns the smallest recorded round-trip time (RTT) in nanoseconds.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RoundTripTimeMinimumGet())



        """
        return _byteblower.TCPResultData_RoundTripTimeMinimumGet(self)


    def RoundTripTimeMaximumGet(self):
        """

        Returns the largest recorded round-trip time (RTT) in nanoseconds.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RoundTripTimeMaximumGet())



        """
        return _byteblower.TCPResultData_RoundTripTimeMaximumGet(self)


    def RoundTripTimeCurrentGet(self):
        """

        Returns the current round-trip time (RTT) in nanoseconds.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RoundTripTimeCurrentGet())



        """
        return _byteblower.TCPResultData_RoundTripTimeCurrentGet(self)


    def RoundTripTimeAverageGet(self):
        return _byteblower.TCPResultData_RoundTripTimeAverageGet(self)

    def RetransmissionCountTotalGet(self):
        """

        Returns the total number of retranmissions.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RetransmissionCountTotalGet())



        """
        return _byteblower.TCPResultData_RetransmissionCountTotalGet(self)


    def RetransmissionCountFastGet(self):
        """

        Returns the total number of fast retranmissions.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RetransmissionCountFastGet())



        """
        return _byteblower.TCPResultData_RetransmissionCountFastGet(self)


    def RetransmissionCountSlowGet(self):
        """

        Returns the total number of timeout retranmissions.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RetransmissionCountSlowGet())



        """
        return _byteblower.TCPResultData_RetransmissionCountSlowGet(self)


    def TimestampSynSentGet(self):
        """

        Returns a nanosecond timestamp for when this TCP connection sent the TCP-SYN 
        segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TimestampSynSentGet())



        """
        return _byteblower.TCPResultData_TimestampSynSentGet(self)


    def TimestampSynReceivedGet(self):
        """

        Returns a nanosecond timestamp for when this TCP connection received the 
        TCP-SYN segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TimestampSynReceivedGet())



        """
        return _byteblower.TCPResultData_TimestampSynReceivedGet(self)


    def TimestampEstablishedGet(self):
        """

        Returns a nanosecond timestamp for when this TCP connection entered the 
        established state.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TimestampEstablishedGet())



        """
        return _byteblower.TCPResultData_TimestampEstablishedGet(self)


    def TimestampFinSentGet(self):
        """

        Returns a nanosecond timestamp for when this TCP connection sent the TCP-FIN 
        segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TimestampFinSentGet())



        """
        return _byteblower.TCPResultData_TimestampFinSentGet(self)


    def TimestampFinReceivedGet(self):
        """

        Returns a nanosecond timestamp for when this TCP connection received the 
        TCP-FIN segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TimestampFinReceivedGet())


        """
        return _byteblower.TCPResultData_TimestampFinReceivedGet(self)


    def NumberOfSynSentGet(self):
        """

        Returns the number of TCP SYN segments that have been sent.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.NumberOfSynSentGet())



        """
        return _byteblower.TCPResultData_NumberOfSynSentGet(self)


    def NumberOfSynReceivedGet(self):
        """

        Returns the number of TCP SYN segments that have been received.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.NumberOfSynReceivedGet())


        """
        return _byteblower.TCPResultData_NumberOfSynReceivedGet(self)


    def NumberOfFinSentGet(self):
        """

        Returns the number of TCP FIN segments that have been sent.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.NumberOfFinSentGet())



        """
        return _byteblower.TCPResultData_NumberOfFinSentGet(self)


    def NumberOfFinReceivedGet(self):
        """

        Returns the number of TCP FIN segments that have been received.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.NumberOfFinReceivedGet())



        """
        return _byteblower.TCPResultData_NumberOfFinReceivedGet(self)


    def TxTimestampLastGet(self):
        """

        Returns a nanosecond timestamp for when this TCP connection sent its last TCP 
        segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TxTimestampLastGet())



        """
        return _byteblower.TCPResultData_TxTimestampLastGet(self)


    def RxTimestampLastGet(self):
        """

        Returns a nanosecond timestamp for when this TCP connection received its last
        TCP segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.RxTimestampLastGet())



        """
        return _byteblower.TCPResultData_RxTimestampLastGet(self)


    def IntervalDurationGet(self):
        """

        Returns nanosecond duration between when result objects are created.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.IntervalDurationGet())



        """
        return _byteblower.TCPResultData_IntervalDurationGet(self)


    def TimestampGet(self):
        """

        Returns the nanosecond timestamp for when this result object was created.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultData.TimestampGet())



        """
        return _byteblower.TCPResultData_TimestampGet(self)

TCPResultData_swigregister = _byteblower.TCPResultData_swigregister
TCPResultData_swigregister(TCPResultData)

class TCPResultDataList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TCPResultDataList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TCPResultDataList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TCPResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TCPResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TCPResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.TCPResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TCPResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TCPResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TCPResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TCPResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TCPResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TCPResultDataList___setitem__(self, *args)

    def pop(self):
        return _byteblower.TCPResultDataList_pop(self)

    def append(self, x):
        return _byteblower.TCPResultDataList_append(self, x)

    def empty(self):
        return _byteblower.TCPResultDataList_empty(self)

    def size(self):
        return _byteblower.TCPResultDataList_size(self)

    def swap(self, v):
        return _byteblower.TCPResultDataList_swap(self, v)

    def begin(self):
        return _byteblower.TCPResultDataList_begin(self)

    def end(self):
        return _byteblower.TCPResultDataList_end(self)

    def rbegin(self):
        return _byteblower.TCPResultDataList_rbegin(self)

    def rend(self):
        return _byteblower.TCPResultDataList_rend(self)

    def clear(self):
        return _byteblower.TCPResultDataList_clear(self)

    def get_allocator(self):
        return _byteblower.TCPResultDataList_get_allocator(self)

    def pop_back(self):
        return _byteblower.TCPResultDataList_pop_back(self)

    def erase(self, *args):
        return _byteblower.TCPResultDataList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_TCPResultDataList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.TCPResultDataList_push_back(self, x)

    def front(self):
        return _byteblower.TCPResultDataList_front(self)

    def back(self):
        return _byteblower.TCPResultDataList_back(self)

    def assign(self, n, x):
        return _byteblower.TCPResultDataList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.TCPResultDataList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.TCPResultDataList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.TCPResultDataList_reserve(self, n)

    def capacity(self):
        return _byteblower.TCPResultDataList_capacity(self)
    __swig_destroy__ = _byteblower.delete_TCPResultDataList
    __del__ = lambda self: None
TCPResultDataList_swigregister = _byteblower.TCPResultDataList_swigregister
TCPResultDataList_swigregister(TCPResultDataList)

class TCPResultSnapshot(AbstractRefreshableResult):
    """

    Contains TCP result counters.  

    You can refresh the counters by calling the 
    :meth:`.TCPResultSnapshot.Refresh` method.  


    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TCPResultSnapshot, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TCPResultSnapshot, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ConnectionStateGet(self):
        return _byteblower.TCPResultSnapshot_ConnectionStateGet(self)

    def TxSegmentCountTotalGet(self):
        """

        Returns the total number of transmitted segments.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TxSegmentCountTotalGet())



        """
        return _byteblower.TCPResultSnapshot_TxSegmentCountTotalGet(self)


    def RxSegmentCountTotalGet(self):
        """

        Returns the total number of received segments.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RxSegmentCountTotalGet())



        """
        return _byteblower.TCPResultSnapshot_RxSegmentCountTotalGet(self)


    def RxSegmentCountOutOfOrderGet(self):
        """

        Returns the number of segments that were received out of order.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RxSegmentCountOutOfOrderGet())



        """
        return _byteblower.TCPResultSnapshot_RxSegmentCountOutOfOrderGet(self)


    def TxByteCountHeaderGet(self):
        """

        Returns the number of transmitted TCP header bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TxByteCountHeaderGet())



        """
        return _byteblower.TCPResultSnapshot_TxByteCountHeaderGet(self)


    def TxByteCountPayloadGet(self):
        """

        Returns the number of transmitted TCP payload bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TxByteCountPayloadGet())



        """
        return _byteblower.TCPResultSnapshot_TxByteCountPayloadGet(self)


    def TxByteCountTotalGet(self):
        """

        Returns the total number of bytes transmitted on the current TCP connection.  

        This is the sum of the tranmitted TCP header and payload bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TxByteCountTotalGet())



        """
        return _byteblower.TCPResultSnapshot_TxByteCountTotalGet(self)


    def RxByteCountHeaderGet(self):
        """

        Returns the number of received TCP header bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RxByteCountHeaderGet())



        """
        return _byteblower.TCPResultSnapshot_RxByteCountHeaderGet(self)


    def RxByteCountPayloadGet(self):
        """

        Returns the number of received TCP payload bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RxByteCountPayloadGet())



        """
        return _byteblower.TCPResultSnapshot_RxByteCountPayloadGet(self)


    def RxByteCountTotalGet(self):
        """

        Returns the total number of bytes received on the current TCP connection.  

        This is the sum of the received TCP header and payload bytes.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RxByteCountTotalGet())



        """
        return _byteblower.TCPResultSnapshot_RxByteCountTotalGet(self)


    def ReceiverWindowCurrentGet(self):
        """

        Returns the current TCP receiver window (RWND).  

        The receiver window is the maximum number of bytes that the remote connection
        is currently able to receive.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.ReceiverWindowCurrentGet())



        """
        return _byteblower.TCPResultSnapshot_ReceiverWindowCurrentGet(self)


    def ReceiverWindowMinimumGet(self):
        """

        Returns the smallest recorded TCP receiver window (RWND).  

        The receiver window is the maximum number of bytes that the remote connection
        is currently able to receive.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.ReceiverWindowMinimumGet())



        """
        return _byteblower.TCPResultSnapshot_ReceiverWindowMinimumGet(self)


    def ReceiverWindowMaximumGet(self):
        """

        Returns the largest recorded TCP receiver window (RWND).  

        The receiver window is the maximum number of bytes that the remote connection
        is currently able to receive.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.ReceiverWindowMaximumGet())



        """
        return _byteblower.TCPResultSnapshot_ReceiverWindowMaximumGet(self)


    def CongestionWindowCurrentGet(self):
        """

        Returns the current TCP congestion window (CWND).  

        The congestion window is the maximum number of bytes that we are allowed to 
        send before receiving a new TCP ACK.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.CongestionWindowCurrentGet())



        """
        return _byteblower.TCPResultSnapshot_CongestionWindowCurrentGet(self)


    def CongestionWindowMinimumGet(self):
        """

        Returns the smallest recorded TCP congestion window (CWND).  

        The congestion window is the maximum number of bytes that we are allowed to
        send before receiving a new TCP ACK.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.CongestionWindowMinimumGet())



        """
        return _byteblower.TCPResultSnapshot_CongestionWindowMinimumGet(self)


    def CongestionWindowMaximumGet(self):
        """

        Returns the largest recorded TCP congestion window (CWND).  

        The congestion window is the maximum number of bytes that we are allowed to 
        send before receiving a new TCP ACK.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.CongestionWindowMaximumGet())



        """
        return _byteblower.TCPResultSnapshot_CongestionWindowMaximumGet(self)


    def FlightSizeCurrentGet(self):
        """

        Returns the number of bytes that are currently in-flight.  

        The flight size is the number of bytes that has been transmitted but not yet
        acknowledged.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.FlightSizeCurrentGet())



        """
        return _byteblower.TCPResultSnapshot_FlightSizeCurrentGet(self)


    def FlightSizeMinimumGet(self):
        """

        Returns the smallest recorded flight-size.  

        The flight size is the number of bytes that has been transmitted but not 
        yet acknowledged.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.FlightSizeMinimumGet())



        """
        return _byteblower.TCPResultSnapshot_FlightSizeMinimumGet(self)


    def FlightSizeMaximumGet(self):
        """

        Returns the largest recorded flight-size.  

        The flight size is the number of bytes that has been transmitted but not yet 
        acknowledged.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.FlightSizeMaximumGet())



        """
        return _byteblower.TCPResultSnapshot_FlightSizeMaximumGet(self)


    def SlowStartThresholdCurrentGet(self):
        """

        Returns the current TCP slow-start threshold (SSTHRESH).  

        The slow-start threshold indicates the congestion window value where the 
        congestion avoidance algorithm switches from "slow-start"-mode to 
        "congestion-avoidance"-mode.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.SlowStartThresholdCurrentGet())



        """
        return _byteblower.TCPResultSnapshot_SlowStartThresholdCurrentGet(self)


    def SlowStartThresholdMinimumGet(self):
        """

        Returns the smallest recorded TCP slow-start threshold (SSTHRESH).  

        The slow-start threshold indicates the congestion window value where the 
        congestion avoidance algorithm switches from "slow-start"-mode to 
        "congestion-avoidance"-mode.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.SlowStartThresholdMinimumGet())



        """
        return _byteblower.TCPResultSnapshot_SlowStartThresholdMinimumGet(self)


    def SlowStartThresholdMaximumGet(self):
        """

        Returns the largest recorded TCP slow-start threshold (SSTHRESH).  

        The slow-start threshold indicates the congestion window value where the 
        congestion avoidance algorithm switches from "slow-start"-mode to
        "congestion-avoidance"-mode.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.SlowStartThresholdMaximumGet())



        """
        return _byteblower.TCPResultSnapshot_SlowStartThresholdMaximumGet(self)


    def RoundTripTimeMinimumGet(self):
        """

        Returns the smallest recorded round-trip time (RTT) in nanoseconds.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RoundTripTimeMinimumGet())



        """
        return _byteblower.TCPResultSnapshot_RoundTripTimeMinimumGet(self)


    def RoundTripTimeMaximumGet(self):
        """

        Returns the largest recorded round-trip time (RTT) in nanoseconds.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RoundTripTimeMaximumGet())



        """
        return _byteblower.TCPResultSnapshot_RoundTripTimeMaximumGet(self)


    def RoundTripTimeCurrentGet(self):
        """

        Returns the current round-trip time (RTT) in nanoseconds.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RoundTripTimeCurrentGet())



        """
        return _byteblower.TCPResultSnapshot_RoundTripTimeCurrentGet(self)


    def RoundTripTimeAverageGet(self):
        return _byteblower.TCPResultSnapshot_RoundTripTimeAverageGet(self)

    def RetransmissionCountTotalGet(self):
        """

        Returns the total number of retranmissions.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RetransmissionCountTotalGet())



        """
        return _byteblower.TCPResultSnapshot_RetransmissionCountTotalGet(self)


    def RetransmissionCountFastGet(self):
        """

        Returns the total number of fast retranmissions.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RetransmissionCountFastGet())



        """
        return _byteblower.TCPResultSnapshot_RetransmissionCountFastGet(self)


    def RetransmissionCountSlowGet(self):
        """

        Returns the total number of timeout retranmissions.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RetransmissionCountSlowGet())



        """
        return _byteblower.TCPResultSnapshot_RetransmissionCountSlowGet(self)


    def TimestampSynSentGet(self):
        """

        Returns a nanosecond timestamp for when this TCP connection sent the TCP-SYN
        segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TimestampSynSentGet())



        """
        return _byteblower.TCPResultSnapshot_TimestampSynSentGet(self)


    def TimestampSynReceivedGet(self):
        """

        Returns a nanosecond timestamp for when this TCP connection received the 
        TCP-SYN segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TimestampSynReceivedGet())



        """
        return _byteblower.TCPResultSnapshot_TimestampSynReceivedGet(self)


    def TimestampEstablishedGet(self):
        """

        Returns a nanosecond timestamp for when this TCP connection entered the 
        established state.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TimestampEstablishedGet())



        """
        return _byteblower.TCPResultSnapshot_TimestampEstablishedGet(self)


    def TimestampFinSentGet(self):
        """

        Returns a nanosecond timestamp for when this TCP connection sent the TCP-FIN segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TimestampFinSentGet())



        """
        return _byteblower.TCPResultSnapshot_TimestampFinSentGet(self)


    def TimestampFinReceivedGet(self):
        """

        Returns a nanosecond timestamp for when this TCP connection received the 
        TCP-FIN segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TimestampFinReceivedGet())



        """
        return _byteblower.TCPResultSnapshot_TimestampFinReceivedGet(self)


    def NumberOfSynSentGet(self):
        """

        Returns the number of TCP SYN segments that have been sent.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.NumberOfSynSentGet())



        """
        return _byteblower.TCPResultSnapshot_NumberOfSynSentGet(self)


    def NumberOfSynReceivedGet(self):
        """

        Returns the number of TCP SYN segments that have been received.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(tcpResultSnapshot.NumberOfSynReceivedGet())



        """
        return _byteblower.TCPResultSnapshot_NumberOfSynReceivedGet(self)


    def NumberOfFinSentGet(self):
        """

        Returns the number of TCP FIN segments that have been sent.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.NumberOfFinSentGet())



        """
        return _byteblower.TCPResultSnapshot_NumberOfFinSentGet(self)


    def NumberOfFinReceivedGet(self):
        """

        Returns the number of TCP FIN segments that have been received.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.NumberOfFinReceivedGet())



        """
        return _byteblower.TCPResultSnapshot_NumberOfFinReceivedGet(self)


    def TxTimestampLastGet(self):
        """

        Returns a nanosecond timestamp for when this TCP connection sent its last TCP 
        segment. 

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TxTimestampLastGet())



        """
        return _byteblower.TCPResultSnapshot_TxTimestampLastGet(self)


    def RxTimestampLastGet(self):
        """

        Returns a nanosecond timestamp for when this TCP connection received its last 
        TCP segment.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RxTimestampLastGet())



        """
        return _byteblower.TCPResultSnapshot_RxTimestampLastGet(self)


    def IntervalDurationGet(self):
        """

        Returns nanosecond duration between when result objects are created.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.IntervalDurationGet())



        """
        return _byteblower.TCPResultSnapshot_IntervalDurationGet(self)


    def TimestampGet(self):
        """

        Returns the nanosecond timestamp for when this result object was created.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.TimestampGet())



        """
        return _byteblower.TCPResultSnapshot_TimestampGet(self)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp when the counters of this object where last refreshed.  

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultSnapshot.RefreshTimestampGet())



        """
        return _byteblower.TCPResultSnapshot_RefreshTimestampGet(self)

TCPResultSnapshot_swigregister = _byteblower.TCPResultSnapshot_swigregister
TCPResultSnapshot_swigregister(TCPResultSnapshot)

class TCPResultSnapshotList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TCPResultSnapshotList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TCPResultSnapshotList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TCPResultSnapshotList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TCPResultSnapshotList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TCPResultSnapshotList___bool__(self)

    def __len__(self):
        return _byteblower.TCPResultSnapshotList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TCPResultSnapshotList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TCPResultSnapshotList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TCPResultSnapshotList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TCPResultSnapshotList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TCPResultSnapshotList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TCPResultSnapshotList___setitem__(self, *args)

    def pop(self):
        return _byteblower.TCPResultSnapshotList_pop(self)

    def append(self, x):
        return _byteblower.TCPResultSnapshotList_append(self, x)

    def empty(self):
        return _byteblower.TCPResultSnapshotList_empty(self)

    def size(self):
        return _byteblower.TCPResultSnapshotList_size(self)

    def swap(self, v):
        return _byteblower.TCPResultSnapshotList_swap(self, v)

    def begin(self):
        return _byteblower.TCPResultSnapshotList_begin(self)

    def end(self):
        return _byteblower.TCPResultSnapshotList_end(self)

    def rbegin(self):
        return _byteblower.TCPResultSnapshotList_rbegin(self)

    def rend(self):
        return _byteblower.TCPResultSnapshotList_rend(self)

    def clear(self):
        return _byteblower.TCPResultSnapshotList_clear(self)

    def get_allocator(self):
        return _byteblower.TCPResultSnapshotList_get_allocator(self)

    def pop_back(self):
        return _byteblower.TCPResultSnapshotList_pop_back(self)

    def erase(self, *args):
        return _byteblower.TCPResultSnapshotList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_TCPResultSnapshotList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.TCPResultSnapshotList_push_back(self, x)

    def front(self):
        return _byteblower.TCPResultSnapshotList_front(self)

    def back(self):
        return _byteblower.TCPResultSnapshotList_back(self)

    def assign(self, n, x):
        return _byteblower.TCPResultSnapshotList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.TCPResultSnapshotList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.TCPResultSnapshotList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.TCPResultSnapshotList_reserve(self, n)

    def capacity(self):
        return _byteblower.TCPResultSnapshotList_capacity(self)
    __swig_destroy__ = _byteblower.delete_TCPResultSnapshotList
    __del__ = lambda self: None
TCPResultSnapshotList_swigregister = _byteblower.TCPResultSnapshotList_swigregister
TCPResultSnapshotList_swigregister(TCPResultSnapshotList)

class TCPResultHistory(AbstractRefreshableResult):
    """

    Interface that allows you to obtain the cumulative and interval result data 
    objects regarding TCP stats.  

    At fixed time intervals, ByteBlower takes Interval and Cumulative stats of the
    TCP session. Only a fixed number of stats ( use :meth:`SamplingBufferLengthGet`
    to know how many ) are kept in memory at the ByteBlower server. Using the
    :meth:`Refresh` method those stats are transfered to the client pc where they
    are stored until you clear them ( :meth:`Clear` ).  

    The interval duration of such a historyObject can be obtained using 
    :meth:`SamplingIntervalDurationGet`  


    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TCPResultHistory, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TCPResultHistory, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def CumulativeGet(self):
        """

        Returns a list of recent TCP result objects containing cumulative counters.  

        Each result object contains cumulative counters at a certain point in time. 
        Snapshots are taken at fixed time intervals. The interval duration can be 
        obtained using :meth:`SamplingIntervalDurationGet`.  

        :return: :class:`.TCPResultDataList` containing the Cumulative counters  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	resultList = tcpResultHistory.CumulativeGet()



        """
        return _byteblower.TCPResultHistory_CumulativeGet(self)


    def CumulativeGetByIndex(self, index):
        """

        Returns a list of recent TCP result objects containing cumulative counters.  

        Each result object contains cumulative counters at a certain point in time. 
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.  

        :param index: index

        :return: :class:`.TCPResultData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.CumulativeGetByIndex(0).DescriptionGet())



        """
        return _byteblower.TCPResultHistory_CumulativeGetByIndex(self, index)


    def CumulativeLengthGet(self):
        """

        Returns a list of recent TCP result objects containing cumulative counters.  

        Each result object contains cumulative counters at a certain point in time. 
        Snapshots are taken at fixed time intervals. The interval duration can be 
        obtained using :meth:`SamplingIntervalDurationGet`.  

        :return:  The length of the cumulative list  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.CumulativeLengthGet())



        """
        return _byteblower.TCPResultHistory_CumulativeLengthGet(self)


    def IntervalGet(self):
        """

        Returns a list of recent TCP result objects containing interval counters.  

        Each result object contains cumulative counters at a certain point in time. 
        Snapshots are taken at fixed time intervals. The duration of the interval can 
        be obtained using :meth:`SamplingIntervalDurationGet`.  

        :return: :class:`.TCPResultDataList` containing the Interval counters  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           intervalCounterList = tcpResultHistory.IntervalGetByTime(time).Intervalget()


        """
        return _byteblower.TCPResultHistory_IntervalGet(self)


    def IntervalGetByIndex(self, index):
        """

        Returns a list of recent TCP result objects containing interval counters.  

        Each result object contains the counters only for a specific time interval. The
        duration of the interval can be obtained using 
        :meth:`SamplingIntervalDurationGet`.  

        :return: :class:`.TCPResultData`

        :param index: index

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(tcpResultHistory.IntervalGetByIndex(0).DescriptionGet())



        """
        return _byteblower.TCPResultHistory_IntervalGetByIndex(self, index)


    def IntervalLengthGet(self):
        """

        Returns a list of recent TCP result objects containing interval counters.  

        Each result object contains the counters only for a specific time interval. The
        duration of the interval can be obtained using 
        :meth:`SamplingIntervalDurationGet`.  

        :return: The length of the Interval list  

        Example 

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.IntervalLengthGet())



        """
        return _byteblower.TCPResultHistory_IntervalLengthGet(self)


    def CumulativeGetByTime(self, timestamp):
        """

        Returns a single item of the cumulative list using a timestamp nanoseconds.  

        :return: :class:`.TCPResultData`

        .. versionadded:: 2.2.0  

        Example

        This example gets the available cumulative counters  

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.CumulativeGetByTime(timestamp).DescriptionGet())



        """
        return _byteblower.TCPResultHistory_CumulativeGetByTime(self, timestamp)


    def IntervalGetByTime(self, timestamp):
        """

        Returns a single item of the interval list using a timestamp in nanoseconds.  

        :return: :class:`.TCPResultData`

        .. versionadded:: 2.2.0  

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.IntervalGetByTime(timestamp).DescriptionGet())


        """
        return _byteblower.TCPResultHistory_IntervalGetByTime(self, timestamp)


    def CumulativeLatestGet(self):
        """

        Returns latest closed item of the cumulative list.  

        :return: :class:`.TCPResultData`

        .. versionadded:: 2.2.0  

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.CumulativeLatestGet())



        """
        return _byteblower.TCPResultHistory_CumulativeLatestGet(self)


    def IntervalLatestGet(self):
        """

        Returns the latest closed item of the interval list.  

        :return: :class:`.TCPResultData`

        .. versionadded:: 2.2.0  

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.IntervalLatestGet().DescriptionGet())



        """
        return _byteblower.TCPResultHistory_IntervalLatestGet(self)


    def SamplingIntervalDurationGet(self):
        """

        Duration of one sampling interval in nanoseconds..  

        :return:  Duration in nanoseconds  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.SamplingIntervalDurationGet())



        """
        return _byteblower.TCPResultHistory_SamplingIntervalDurationGet(self)


    def SamplingBufferLengthGet(self):
        """

        Number of samples to keep in the buffer at server-side.  

        The ByteBlower server has a buffer to keep some samples before they are 
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a 
        sample is closed, the oldest sample in the buffer will be removed.  

        :return: The length of the server sample buffer  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.SamplingBufferLengthGet())



        """
        return _byteblower.TCPResultHistory_SamplingBufferLengthGet(self)


    def SamplingIntervalDurationSet(self, inDuration):
        """

        Sets the duration of one sampling interval.  

        .. versionadded:: 2.3.0  

        .. warning: The previously collected history will be invalidated.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	tcpResultHistory.SamplingIntervalDurationSet(1000000000)



        """
        return _byteblower.TCPResultHistory_SamplingIntervalDurationSet(self, inDuration)


    def SamplingBufferLengthSet(self, inLength):
        """

        Sets the number of samples to keep in the buffer.  

        .. versionadded:: 2.3.0  

        The ByteBlower server has a buffer to keep some samples before they are 
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a 
        sample is closed, the oldest sample in the buffer will be removed.  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	tcpResultHistory.SamplingBufferLengthSet(6)



        """
        return _byteblower.TCPResultHistory_SamplingBufferLengthSet(self, inLength)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp on the server when the current history is requested.  

        This is the timestamp on the server when the last :meth:`Refresh` was called.  

        :return: Timestamp in nanoseconds since epoch  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(tcpResultHistory.RefreshTimestampGet())



        """
        return _byteblower.TCPResultHistory_RefreshTimestampGet(self)


    def Clear(self):
        """

        Clears the history.  

        With each :meth:`Refresh` interval and cumulative counters are transferred from
        Server to the Client. To remove all counter-objects in this history, you can 
        execute this method. Both Interval and Cumulative counter lists will be cleared
        .

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	tcpResultHistory.Clear()



        """
        return _byteblower.TCPResultHistory_Clear(self)

TCPResultHistory_swigregister = _byteblower.TCPResultHistory_swigregister
TCPResultHistory_swigregister(TCPResultHistory)

class HTTPResultData(AbstractObject):
    """

    Contains the HTTP result counters.

    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPResultData, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPResultData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AverageDataSpeedGet(self):
        """

        Rate in bytes per seconds of the data transferred.

        This method determines the direction of the traffic based on the HTTP method
        and whether the parent is an HTTPServer or HTTPClient.

        - A "GET" request on an HTTPServer : TX traffic.
        - A "GET" request on an HTTPClient : RX traffic.
        - A "PUT" request on an HTTPServer : RX traffic.
        - A "PUT" request on an HTTPClient : TX traffic.

        :return: Rate in bytes per second

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.AverageDataSpeedGet().BitRateGet())



        """
        return _byteblower.HTTPResultData_AverageDataSpeedGet(self)


    def RxByteCountHeaderGet(self):
        """

        The size of the received HTTPheader in bytes.

        HTTP header contains the HTTP header fields. These fields define the operating
        parameters of an HTTP transaction (e.g. :
        User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0
        )

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.RxByteCountHeaderGet())



        """
        return _byteblower.HTTPResultData_RxByteCountHeaderGet(self)


    def RxByteCountPayloadGet(self):
        """

        The size of the received HTTP Payload in bytes.

        The size of the actual content of the HTTP transaction

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultData.RxByteCountPayloadGet())



        """
        return _byteblower.HTTPResultData_RxByteCountPayloadGet(self)


    def RxByteCountRateGet(self):
        """

        Rate in bytes per seconds of the data received.

        :return:  Rate in bytes per second

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultData.RxByteCountRateGet())



        """
        return _byteblower.HTTPResultData_RxByteCountRateGet(self)


    def RxByteCountTotalGet(self):
        """

        Total of bytes received.

        The total is the sum of :meth:`RxByteCountHeaderGet` and
        :meth:`RxByteCountPayloadGet`

        :return: Total received bytes

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultData.RxByteCountTotalGet())


        """
        return _byteblower.HTTPResultData_RxByteCountTotalGet(self)


    def TxByteCountHeaderGet(self):
        """

        The size of the transmitted HTTPHeader in bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.TxByteCountHeaderGet())



        """
        return _byteblower.HTTPResultData_TxByteCountHeaderGet(self)


    def TxByteCountRateGet(self):
        """

        Rate in bytes per seconds of the data sent.

        :return: Rate in bytes per second

        Example

        .. code-block:: python
           :emphasize-lines: 2

            print(resultData.TxByteCountRateGet().BitRateGet())



        """
        return _byteblower.HTTPResultData_TxByteCountRateGet(self)


    def TxByteCountPayloadGet(self):
        """

        The size of the transmitted HTTPPayload in bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultData.TxByteCountPayloadGet())


        """
        return _byteblower.HTTPResultData_TxByteCountPayloadGet(self)


    def TxByteCountTotalGet(self):
        """

        Total of transmitted bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultData.TxByteCountTotalGet())


        """
        return _byteblower.HTTPResultData_TxByteCountTotalGet(self)


    def TxTimestampFirstGet(self):
        """

        Timestamp (in nanoseconds) of first transmitted packet.

        :return: Timestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.TxTimestampFirstGet())



        """
        return _byteblower.HTTPResultData_TxTimestampFirstGet(self)


    def TxTimestampLastGet(self):
        """

        Timestamp (in nanoseconds) of last transmitted packet.

        :return: Timestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.TxTimestampLastGet())



        """
        return _byteblower.HTTPResultData_TxTimestampLastGet(self)


    def RxTimestampFirstGet(self):
        """

        Timestamp (in nanoseconds) of first received packet.

        :return: Timestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(resultData.RxTimestampFirstGet())


        """
        return _byteblower.HTTPResultData_RxTimestampFirstGet(self)


    def RxTimestampLastGet(self):
        """

        Timestamp (in nanoseconds) of last received packet.

        :return: Timestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.RxTimestampLastGet())



        """
        return _byteblower.HTTPResultData_RxTimestampLastGet(self)


    def LatencyMinimumGet(self, default_value):
        return _byteblower.HTTPResultData_LatencyMinimumGet(self, default_value)

    def LatencyMaximumGet(self, default_value):
        return _byteblower.HTTPResultData_LatencyMaximumGet(self, default_value)

    def LatencyAverageGet(self, default_value):
        return _byteblower.HTTPResultData_LatencyAverageGet(self, default_value)

    def JitterGet(self, default_value):
        return _byteblower.HTTPResultData_JitterGet(self, default_value)

    def IntervalDurationGet(self):
        """

        Returns the duration of this interval in nanoseconds.

        :return: intervalduration in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultData.IntervalDurationGet())



        """
        return _byteblower.HTTPResultData_IntervalDurationGet(self)


    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].

        :return: Timestamp of snapshot in nanoseconds

        Example
        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.TimestampGet())



        """
        return _byteblower.HTTPResultData_TimestampGet(self)

HTTPResultData_swigregister = _byteblower.HTTPResultData_swigregister
HTTPResultData_swigregister(HTTPResultData)

class HTTPResultDataList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPResultDataList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPResultDataList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPResultDataList___setitem__(self, *args)

    def pop(self):
        return _byteblower.HTTPResultDataList_pop(self)

    def append(self, x):
        return _byteblower.HTTPResultDataList_append(self, x)

    def empty(self):
        return _byteblower.HTTPResultDataList_empty(self)

    def size(self):
        return _byteblower.HTTPResultDataList_size(self)

    def swap(self, v):
        return _byteblower.HTTPResultDataList_swap(self, v)

    def begin(self):
        return _byteblower.HTTPResultDataList_begin(self)

    def end(self):
        return _byteblower.HTTPResultDataList_end(self)

    def rbegin(self):
        return _byteblower.HTTPResultDataList_rbegin(self)

    def rend(self):
        return _byteblower.HTTPResultDataList_rend(self)

    def clear(self):
        return _byteblower.HTTPResultDataList_clear(self)

    def get_allocator(self):
        return _byteblower.HTTPResultDataList_get_allocator(self)

    def pop_back(self):
        return _byteblower.HTTPResultDataList_pop_back(self)

    def erase(self, *args):
        return _byteblower.HTTPResultDataList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_HTTPResultDataList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.HTTPResultDataList_push_back(self, x)

    def front(self):
        return _byteblower.HTTPResultDataList_front(self)

    def back(self):
        return _byteblower.HTTPResultDataList_back(self)

    def assign(self, n, x):
        return _byteblower.HTTPResultDataList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.HTTPResultDataList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.HTTPResultDataList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.HTTPResultDataList_reserve(self, n)

    def capacity(self):
        return _byteblower.HTTPResultDataList_capacity(self)
    __swig_destroy__ = _byteblower.delete_HTTPResultDataList
    __del__ = lambda self: None
HTTPResultDataList_swigregister = _byteblower.HTTPResultDataList_swigregister
HTTPResultDataList_swigregister(HTTPResultDataList)

class HTTPResultSnapshot(AbstractRefreshableResult):
    """

    Contains HTTP result counters.

    You can refresh the counters by calling the :meth:`Refresh` method.

    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPResultSnapshot, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPResultSnapshot, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AverageDataSpeedGet(self):
        """

        Rate in bytes per seconds of the data transferred.

        Depending on the HTTP method or if the parent of this object is an
        :class:`HTTPServer` or :class:`HTTPClient`, the rate of the traffic sent or
        received will be returned

        :return: Rate in bytes per second

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(resultSnaphot.AverageDataSpeedGet())


        """
        return _byteblower.HTTPResultSnapshot_AverageDataSpeedGet(self)


    def RxByteCountHeaderGet(self):
        """

        The size of the received HTTPheader in bytes.

        HTTP header contains the HTTP header fields. These fields define the operating
        parameters of an HTTP transaction (e.g. : User-Agent: Mozilla/5.0 (X11;
        Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 )

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	result = httP
            print(resultSnapshot.RxByteCountHeaderGet())



        """
        return _byteblower.HTTPResultSnapshot_RxByteCountHeaderGet(self)


    def RxByteCountPayloadGet(self):
        """

        The size of the received HTTP Payload in bytes.

        The size of the actual content of the HTTP transaction

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultSnaphot.RxByteCountPayloadGet())



        """
        return _byteblower.HTTPResultSnapshot_RxByteCountPayloadGet(self)


    def RxByteCountRateGet(self):
        """

        Rate in bytes per seconds of the data received.

        :return:  Rate in bytes per second

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(resultSnaphot.RxByteCountRateGet())


        """
        return _byteblower.HTTPResultSnapshot_RxByteCountRateGet(self)


    def RxByteCountTotalGet(self):
        """

        Total number of bytes received.

        The total is the sum of :meth:`RxByteCountHeaderGet` and
        :meth:`RxByteCountPayloadGet`

        :return: Total received bytes

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(resultSnaphot.RxByteCountTotalGet())


        """
        return _byteblower.HTTPResultSnapshot_RxByteCountTotalGet(self)


    def TxByteCountHeaderGet(self):
        """

        The size of the transmitted HTTPHeader in bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultSnaphot.TxByteCountHeaderGet())


        """
        return _byteblower.HTTPResultSnapshot_TxByteCountHeaderGet(self)


    def TxByteCountPayloadGet(self):
        """

        The size of the transmitted HTTPPayload in bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(resultSnaphot.TxByteCountPayloadGet())

        """
        return _byteblower.HTTPResultSnapshot_TxByteCountPayloadGet(self)


    def TxByteCountRateGet(self):
        """

        Rate in bytes per seconds of the data sent.

        :return: Rate in bytes per second

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnaphot.TxByteCountPayloadGet())



        """
        return _byteblower.HTTPResultSnapshot_TxByteCountRateGet(self)


    def TxByteCountTotalGet(self):
        """

        Total of transmitted bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultSnaphot.TxByteCountTotalGet())



        """
        return _byteblower.HTTPResultSnapshot_TxByteCountTotalGet(self)


    def TxTimestampFirstGet(self):
        """

        Timestamp (in nanoseconds) of first transmitted packet.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnapshot.TxTimestampFirstGet())



        """
        return _byteblower.HTTPResultSnapshot_TxTimestampFirstGet(self)


    def TxTimestampLastGet(self):
        """

        Timestamp (in nanoseconds) of last transmitted packet.

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(resultSnapshot.TxTimestampLastGet())



        """
        return _byteblower.HTTPResultSnapshot_TxTimestampLastGet(self)


    def RxTimestampFirstGet(self):
        """

        Timestamp (in nanoseconds) of first received packet.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnapshot.RxTimestampFirstGet())



        """
        return _byteblower.HTTPResultSnapshot_RxTimestampFirstGet(self)


    def RxTimestampLastGet(self):
        """

        Timestamp (in nanoseconds) of last received packet.

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(resultSnapshot.RxTimestampLastGet())



        """
        return _byteblower.HTTPResultSnapshot_RxTimestampLastGet(self)


    def LatencyMinimumGet(self, default_value):
        return _byteblower.HTTPResultSnapshot_LatencyMinimumGet(self, default_value)

    def LatencyMaximumGet(self, default_value):
        return _byteblower.HTTPResultSnapshot_LatencyMaximumGet(self, default_value)

    def LatencyAverageGet(self, default_value):
        return _byteblower.HTTPResultSnapshot_LatencyAverageGet(self, default_value)

    def JitterGet(self, default_value):
        return _byteblower.HTTPResultSnapshot_JitterGet(self, default_value)

    def IntervalDurationGet(self):
        """

        Returns the duration (in nanoseconds) between snapshot objects.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultSnaphot.IntervalDurationGet())

        """
        return _byteblower.HTTPResultSnapshot_IntervalDurationGet(self)


    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].

        :return: Timestamp of snapshot in nanoseconds

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(resultSnaphot.TimestampGet())



        """
        return _byteblower.HTTPResultSnapshot_TimestampGet(self)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp when the counters of this object where last refreshed.

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultSnaphot.RefreshTimestampGet())



        """
        return _byteblower.HTTPResultSnapshot_RefreshTimestampGet(self)

HTTPResultSnapshot_swigregister = _byteblower.HTTPResultSnapshot_swigregister
HTTPResultSnapshot_swigregister(HTTPResultSnapshot)

class HTTPResultSnapshotList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPResultSnapshotList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPResultSnapshotList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPResultSnapshotList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPResultSnapshotList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPResultSnapshotList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPResultSnapshotList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPResultSnapshotList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPResultSnapshotList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPResultSnapshotList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPResultSnapshotList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPResultSnapshotList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPResultSnapshotList___setitem__(self, *args)

    def pop(self):
        return _byteblower.HTTPResultSnapshotList_pop(self)

    def append(self, x):
        return _byteblower.HTTPResultSnapshotList_append(self, x)

    def empty(self):
        return _byteblower.HTTPResultSnapshotList_empty(self)

    def size(self):
        return _byteblower.HTTPResultSnapshotList_size(self)

    def swap(self, v):
        return _byteblower.HTTPResultSnapshotList_swap(self, v)

    def begin(self):
        return _byteblower.HTTPResultSnapshotList_begin(self)

    def end(self):
        return _byteblower.HTTPResultSnapshotList_end(self)

    def rbegin(self):
        return _byteblower.HTTPResultSnapshotList_rbegin(self)

    def rend(self):
        return _byteblower.HTTPResultSnapshotList_rend(self)

    def clear(self):
        return _byteblower.HTTPResultSnapshotList_clear(self)

    def get_allocator(self):
        return _byteblower.HTTPResultSnapshotList_get_allocator(self)

    def pop_back(self):
        return _byteblower.HTTPResultSnapshotList_pop_back(self)

    def erase(self, *args):
        return _byteblower.HTTPResultSnapshotList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_HTTPResultSnapshotList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.HTTPResultSnapshotList_push_back(self, x)

    def front(self):
        return _byteblower.HTTPResultSnapshotList_front(self)

    def back(self):
        return _byteblower.HTTPResultSnapshotList_back(self)

    def assign(self, n, x):
        return _byteblower.HTTPResultSnapshotList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.HTTPResultSnapshotList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.HTTPResultSnapshotList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.HTTPResultSnapshotList_reserve(self, n)

    def capacity(self):
        return _byteblower.HTTPResultSnapshotList_capacity(self)
    __swig_destroy__ = _byteblower.delete_HTTPResultSnapshotList
    __del__ = lambda self: None
HTTPResultSnapshotList_swigregister = _byteblower.HTTPResultSnapshotList_swigregister
HTTPResultSnapshotList_swigregister(HTTPResultSnapshotList)

class HTTPResultHistory(AbstractRefreshableResult):
    """

    General interface for getting cumulative or interval results.

    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPResultHistory, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPResultHistory, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def CumulativeGet(self):
        """

        Returns a list of available cumulative results.

        :return: :class:`HTTPResultDataList` containing the Cumulative counters

        Example

        This example gets the available cumulative results

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultHistory.CumulativeGet()[0].DescriptionGet())



        """
        return _byteblower.HTTPResultHistory_CumulativeGet(self)


    def CumulativeGetByIndex(self, index):
        """

        Returns a single item of the cumulative list.

        :param index: index

        :return: :class:`.HTTPResultData` cumulative counter object at the specified
                 index

        Example

        This example gets the available cumulative counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

           httpResultData = resultHistory.CumulativeGetByIndex(0)


        """
        return _byteblower.HTTPResultHistory_CumulativeGetByIndex(self, index)


    def CumulativeLengthGet(self):
        """

        Returns the size of the cumulative list.

        :return:  The length of the cumulative list

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(resultHistory.CumulativeLengthGet())


        """
        return _byteblower.HTTPResultHistory_CumulativeLengthGet(self)


    def IntervalGet(self):
        """

        Returns a list of available interval results.

        :return: :class:`HTTPResultDataList` containing the Interval counters

        Example

        This example gets the available interval results

        .. code-block:: python
           :emphasize-lines: 1

        	httpResultData = resultHistory.IntervalGet()[0]

        """
        return _byteblower.HTTPResultHistory_IntervalGet(self)


    def IntervalGetByIndex(self, index):
        """

        Returns a single item of the interval list.

        :param index: index

        :return: :class:`.HTTPResultData` interval counter object at the specified
                 index

        Example

        This example gets the available interval counters at index 1

        .. code-block:: python
           :emphasize-lines: 3

           httpResultData = resultHistory.IntervalGetByIndex(0)


        """
        return _byteblower.HTTPResultHistory_IntervalGetByIndex(self, index)


    def IntervalLengthGet(self):
        """

        Returns the size of the interval list.

        :return:  The length of the interval list

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultHistory.IntervalLengthGet())


        """
        return _byteblower.HTTPResultHistory_IntervalLengthGet(self)


    def CumulativeGetByTime(self, timestamp):
        """

        Returns a single item of the cumulative list using a timestamp nanoseconds.

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

        	httpResultData = resultHistory.CumulativeGetByTime(timestamp)



        """
        return _byteblower.HTTPResultHistory_CumulativeGetByTime(self, timestamp)


    def IntervalGetByTime(self, timestamp):
        """

        Returns a single item of the interval list using a timestamp in nanoseconds.

        :return: :class:`HTTPResultData`

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           interval = resultHistory.IntervalGetByTime(timestamp)


        """
        return _byteblower.HTTPResultHistory_IntervalGetByTime(self, timestamp)


    def CumulativeLatestGet(self):
        """

        Returns latest closed item of the cumulative list.

        :return: :class:`HTTPResultData`

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

            print(resultHistory.CumulativeLatestGet())



        """
        return _byteblower.HTTPResultHistory_CumulativeLatestGet(self)


    def IntervalLatestGet(self):
        """

        Returns the latest closed item of the interval list.

        :return: :class:`.HTTPResultData`

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           httpResultData = resultHistory.IntervalLatestGet(0)



        """
        return _byteblower.HTTPResultHistory_IntervalLatestGet(self)


    def SamplingIntervalDurationGet(self):
        """

        Duration of one sampling interval in nanoseconds.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultHistory.SamplingIntervalDurationGet())



        """
        return _byteblower.HTTPResultHistory_SamplingIntervalDurationGet(self)


    def SamplingIntervalDurationSet(self, inDuration):
        """

        Sets the duration of one sampling interval.

        .. warning:: The previously collected history will be invalidated.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

            resultHistory.SamplingIntervalDurationSet(1000000000)


        """
        return _byteblower.HTTPResultHistory_SamplingIntervalDurationSet(self, inDuration)


    def SamplingBufferLengthGet(self):
        """

        Number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        :return: The length of the server sample buffer

        """
        return _byteblower.HTTPResultHistory_SamplingBufferLengthGet(self)


    def SamplingBufferLengthSet(self, inLength):
        """

        Sets the number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultHistory.SamplingBufferLengthSet(6))



        """
        return _byteblower.HTTPResultHistory_SamplingBufferLengthSet(self, inLength)


    def RefreshTimestampGet(self):
        """

        RefreshTimestampGet.

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultHistory.RefreshTimestampGet())



        """
        return _byteblower.HTTPResultHistory_RefreshTimestampGet(self)


    def Clear(self):
        """

        Clears the history.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	resultHistory.Clear()



        """
        return _byteblower.HTTPResultHistory_Clear(self)

HTTPResultHistory_swigregister = _byteblower.HTTPResultHistory_swigregister
HTTPResultHistory_swigregister(HTTPResultHistory)

class HTTPSessionInfo(AbstractObject):
    """

    Class containing the info about the HTTPSession.

    This class represents the session info gather from a HTTP session. It will
    contain states of the TCP session, Timestamp of received requests average
    throughputs etc..

    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPSessionInfo, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPSessionInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Role_Client = _byteblower.HTTPSessionInfo_Role_Client
    Role_Server = _byteblower.HTTPSessionInfo_Role_Server
    if _newclass:
        ConvertRoleToString = staticmethod(_byteblower.HTTPSessionInfo_ConvertRoleToString)
    else:
        ConvertRoleToString = _byteblower.HTTPSessionInfo_ConvertRoleToString

    def RoleGet(self):
        """

        Returns the role of the session.

        Possible values are:

        - Client
        - Server}

        :return: The role the session was/is playing

        Example

        retrieve the httpsession info from the httpClient

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO???


        """
        return _byteblower.HTTPSessionInfo_RoleGet(self)


    def TcpSessionInfoGet(self):
        """

        Returns the TCPSessionInfo from this session.

        The :class:`.TCPSessionInfo` contains information about the TCP underlying
        session.

        :return: :class:`.TCPSessionInfo`

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpSessionInfo.TcpSessionInfoGet().DescriptionGet())



        """
        return _byteblower.HTTPSessionInfo_TcpSessionInfoGet(self)


    def RequestMethodGet(self):
        """

        Returns the http request method of the session.

        Possible values are:

        - GET
        - PUT

        :return: The request method used in this session

        Example

        retrieve the httpsession info from the httpClient

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpSessionInfo.RequestMethodGet() == HTTPRequestMethod.Get)



        """
        return _byteblower.HTTPSessionInfo_RequestMethodGet(self)


    def RequestTypeGet(self):
        """

        Returns the request type ( Duration or Size )

        Possible values are:

        - Duration
        - Size

        :return: request Type

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpSessionInfo.RequestTypeGet() == HTTPRequestType.Duration)



        """
        return _byteblower.HTTPSessionInfo_RequestTypeGet(self)


    def RequestStatusGet(self):
        """

        Returns the status of the HTTP request.

        :return: :class:`.HTTPRequestStatus`

        Example

        .. code-block:: python
           :emphasize-lines: 1


        	print(httpSessionInfo.RequestStatusGet() == HTTPRequestStatus.Running)



        """
        return _byteblower.HTTPSessionInfo_RequestStatusGet(self)


    def ErrorMessageGet(self):
        """

        Returns the error message.

        When the request status is "Error" then extra information can be obtained
        with this method.

        :return: The error message string

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpSessionInfo.ErrorMessageGet())



        """
        return _byteblower.HTTPSessionInfo_ErrorMessageGet(self)


    def RequestValueGet(self):
        """

        Returns the request value.

        In case of duration based session it returns the duration that was requested by
        the httpClient. For Size it returns the requested payload size

        :return: Request Value

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpSessionInfo.RequestValueGet())



        """
        return _byteblower.HTTPSessionInfo_RequestValueGet(self)


    def RequestDurationGet(self):
        return _byteblower.HTTPSessionInfo_RequestDurationGet(self)

    def RequestSizeGet(self):
        return _byteblower.HTTPSessionInfo_RequestSizeGet(self)

    def ServerClientIdGet(self):
        return _byteblower.HTTPSessionInfo_ServerClientIdGet(self)

    def ResultGet(self):
        """

        Returns the HTTPResultSnapshot for this session.

        The snapshot contains byte counters and time values.

        :return: :class:`.HTTPResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpSessionInfo.ResultGet().DescriptionGet())



        """
        return _byteblower.HTTPSessionInfo_ResultGet(self)


    def ResultHistoryGet(self):
        """

        Returns the HTTPResultHistory for this session.

        The history contains a list of snapshots taken at one second intervals.
        To update the history use the :meth:`Refresh` function.

        :return: :class:`.HTTPResultHistory`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpSessionInfo.ResultHistoryGet().DescriptionGet())


        """
        return _byteblower.HTTPSessionInfo_ResultHistoryGet(self)


    def Destroy(self):
        return _byteblower.HTTPSessionInfo_Destroy(self)
HTTPSessionInfo_swigregister = _byteblower.HTTPSessionInfo_swigregister
HTTPSessionInfo_swigregister(HTTPSessionInfo)

def HTTPSessionInfo_ConvertRoleToString(inRole):
    return _byteblower.HTTPSessionInfo_ConvertRoleToString(inRole)
HTTPSessionInfo_ConvertRoleToString = _byteblower.HTTPSessionInfo_ConvertRoleToString

class HTTPMultiResultData(AbstractObject):
    """

    Contains the result counters for :class:`HTTPMultiClient` or
    :class:`HTTPMultiServer`.

    .. code-block:: python
       :emphasize-lines: 2

    	http_multi_data = http_client.ResultHistoryGet().CumulativeGetByIndex(0)
    	print(http_multi_data.TxTimestampLastGet(10000000000))


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPMultiResultData, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPMultiResultData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def FinishedGet(self):
        """

        Indicates whether the flow has finished.

        :return: bool: indicates if the flow has finished.

        For the :class:`HTTPMultiClient` this means that client state is Finished or
        Stopped. For the :class:`HTTPMultiServer` this means the server state is
        Stopped.

        """
        return _byteblower.HTTPMultiResultData_FinishedGet(self)


    def RxByteCountGet(self):
        """

        Returns number of received bytes.

        """
        return _byteblower.HTTPMultiResultData_RxByteCountGet(self)


    def TxByteCountGet(self):
        """

        Returns number of sent bytes.

        """
        return _byteblower.HTTPMultiResultData_TxByteCountGet(self)


    def RxSpeedGet(self):
        return _byteblower.HTTPMultiResultData_RxSpeedGet(self)

    def TxSpeedGet(self):
        return _byteblower.HTTPMultiResultData_TxSpeedGet(self)

    def TxTimestampFirstGet(self, default_value):
        """

        Returns the timestamp (in nanoseconds) of the first transmitted packet or a
        default value in case no packets were transmitted.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.TxTimestampFirstGet(10000))


        """
        return _byteblower.HTTPMultiResultData_TxTimestampFirstGet(self, default_value)


    def TxTimestampLastGet(self, default_value):
        """

        Returns the timestamp (in nanoseconds) of the last transmitted packet or a
        default value in case no packets were transmitted.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 2

        	print(http_multi_data.TxTimestampLastGet(10000000000))


        """
        return _byteblower.HTTPMultiResultData_TxTimestampLastGet(self, default_value)


    def RxTimestampFirstGet(self, default_value):
        """

        Returns the timestamp (in nanoseconds) of the first receieved packet or a
        default value in case no packets were received.

        :return: Timestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.RxTimestampFirstGet(10000))


        """
        return _byteblower.HTTPMultiResultData_RxTimestampFirstGet(self, default_value)


    def RxTimestampLastGet(self, default_value):
        """

        Returns the timestamp (in nanoseconds) of the last receieved packet or a
        default value in case no packets were received.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.RxTimestampLastGet(10000))


        """
        return _byteblower.HTTPMultiResultData_RxTimestampLastGet(self, default_value)


    def TcpRxByteCountGet(self):
        """

        Returns number of bytes received by the TCP protocol. This includes the TCP
        header.

        """
        return _byteblower.HTTPMultiResultData_TcpRxByteCountGet(self)


    def TcpTxByteCountGet(self):
        """

        Returns number of bytes sent by the TCP protocol. This includes the TCP header
        and TCP retransmissions.

        """
        return _byteblower.HTTPMultiResultData_TcpTxByteCountGet(self)


    def TcpRxSpeedGet(self):
        return _byteblower.HTTPMultiResultData_TcpRxSpeedGet(self)

    def TcpTxSpeedGet(self):
        return _byteblower.HTTPMultiResultData_TcpTxSpeedGet(self)

    def TcpRxSegmentCountGet(self):
        """

        Returns number of packets received by the TCP protocol.

        """
        return _byteblower.HTTPMultiResultData_TcpRxSegmentCountGet(self)


    def TcpTxSegmentCountGet(self):
        """

        Returns number of packets sent by the TCP protocol.

        """
        return _byteblower.HTTPMultiResultData_TcpTxSegmentCountGet(self)


    def TcpTxTimestampFirstGet(self, default_value):
        """

        Returns the timestamp (in nanoseconds) of the first transmitted TCP segment or
        a default value in case no packets were transmitted.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.TcpTxTimestampFirstGet(10000))


        """
        return _byteblower.HTTPMultiResultData_TcpTxTimestampFirstGet(self, default_value)


    def TcpTxTimestampLastGet(self, default_value):
        """

        Returns the timestamp (in nanoseconds) of the last transmitted TCP segment or a
        default value in case no packets were transmitted.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available.

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.TcpTxTimestampLastGet(10000))


        """
        return _byteblower.HTTPMultiResultData_TcpTxTimestampLastGet(self, default_value)


    def TcpRxTimestampFirstGet(self, default_value):
        """

        Returns the timestamp (in nanoseconds) of the first receieved TCP segment or a
        default value in case no packets were received.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.TcpRxTimestampFirstGet(100000))

        """
        return _byteblower.HTTPMultiResultData_TcpRxTimestampFirstGet(self, default_value)


    def TcpRxTimestampLastGet(self, default_value):
        """

        Returns the timestamp (in nanoseconds) of the last receieved TCP segment or a
        default value in case no packets were received.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.TcpRxTimestampLastGet(10000))


        """
        return _byteblower.HTTPMultiResultData_TcpRxTimestampLastGet(self, default_value)


    def RoundTripTimeAverageGet(self, default_value):
        """

        Returns average TCP round-trip time or a default value in case no round-trip
        samples are available.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.RoundTripTimeAverageGet(10000))


        """
        return _byteblower.HTTPMultiResultData_RoundTripTimeAverageGet(self, default_value)


    def RoundTripTimeMinimumGet(self, default_value):
        """

        Returns minimum TCP round-trip time or a default value in case no round-trip
        samples are available.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.RoundTripTimeMinimumGet(10000))



        """
        return _byteblower.HTTPMultiResultData_RoundTripTimeMinimumGet(self, default_value)


    def RoundTripTimeMaximumGet(self, default_value):
        """

        Returns maximum TCP round-trip time or a default value in case no round-trip
        samples are available.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.RoundTripTimeMaximumGet)

        """
        return _byteblower.HTTPMultiResultData_RoundTripTimeMaximumGet(self, default_value)


    def RetransmissionsGet(self):
        """

        Returns number of TCP retransmissions.

        """
        return _byteblower.HTTPMultiResultData_RetransmissionsGet(self)


    def IntervalDurationGet(self):
        """

        Returns the snapshot duration interval in nanoseconds.

        :return: intervalduration in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

           	print(http_multi_data.IntervalDurationGet())


        """
        return _byteblower.HTTPMultiResultData_IntervalDurationGet(self)


    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].

        :return: Timestamp of snapshot in nanoseconds

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.TimestampGet())


        """
        return _byteblower.HTTPMultiResultData_TimestampGet(self)


    def ConnectionsAttemptedGet(self):
        """

        Returns the number of TCP connection attempts that were initiated.

        For the :class:`HTTPMultiClient` this means the number of active TCP connection
        attempts initiated. For the :class:`HTTPMultiServer` this means the number of
        passive TCP connection requests received.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(http_multi_data.ConnectionsAttemptedGet())


        """
        return _byteblower.HTTPMultiResultData_ConnectionsAttemptedGet(self)


    def ConnectionsEstablishedGet(self):
        """

        Returns the number of succesful TCP connection attempts that reached ESTABLISHED state.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.ConnectionsEstablishedGet())

        """
        return _byteblower.HTTPMultiResultData_ConnectionsEstablishedGet(self)


    def ConnectionsAbortedGet(self):
        """

        Returns the number of aborted TCP connection attempts.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.ConnectionsAbortedGet())


        """
        return _byteblower.HTTPMultiResultData_ConnectionsAbortedGet(self)


    def ConnectionsRefusedGet(self):
        """

        Returns the number of TCP connection attempts that were refused by the other side.

        For the :class:`HTTPMultiServer` this value is always zero.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.ConnectionsRefusedGet())

        """
        return _byteblower.HTTPMultiResultData_ConnectionsRefusedGet(self)


    def SessionsFinishedGet(self):
        """

        Returns the number HTTP requests that finished succesfully.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.SessionsFinishedGet())

        """
        return _byteblower.HTTPMultiResultData_SessionsFinishedGet(self)


    def SessionsAbortedGet(self):
        """

        Returns the number HTTP requests that failed because they were aborted locally.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.SessionsAbortedGet())


        """
        return _byteblower.HTTPMultiResultData_SessionsAbortedGet(self)


    def SessionsResetByPeerGet(self):
        """

        Returns the number HTTP requests that failed because a TCP RESET message was
        received.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.SessionsResetByPeerGet())


        """
        return _byteblower.HTTPMultiResultData_SessionsResetByPeerGet(self)


    def DebugCountersNamesGet(self):
        """

        Returns a list of debug counter names.

        .. note:: The list of names is not backwards compatible.

        """
        return _byteblower.HTTPMultiResultData_DebugCountersNamesGet(self)


    def DebugCountersGetByName(self, name):
        """

        Returns a list of debug counter values.

        :param name: The name of the debug counter (obtained from
                     :meth:`DebugCountersNamesGet`).

        .. note:: The list of debug values is not backwards compatible.

        Example
        .. code-block:: python
           :emphasize-lines: 1

        	print(http_multi_data.DebugCountersGetByName('State_Closing'))


        """
        return _byteblower.HTTPMultiResultData_DebugCountersGetByName(self, name)

HTTPMultiResultData_swigregister = _byteblower.HTTPMultiResultData_swigregister
HTTPMultiResultData_swigregister(HTTPMultiResultData)

class HTTPMultiResultSnapshot(AbstractRefreshableResult):
    """

    Refreshable snapshot that contains the result counters for HTTPMultiClient or
    HTTPMultiServer.

    You can refresh the counters by calling the
    :meth:`HTTPMultiResultSnapshot.Refresh` method.

    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPMultiResultSnapshot, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPMultiResultSnapshot, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def FinishedGet(self):
        """

        Indicates whether the flow has finished.

        :return:  bool indiciating if the flow has finished.

        For the :class:`HTTPMultiClient` this means that client state is Finished or
        Stopped. For the :class:`HTTPMultiServer` this means the server state is
        Stopped.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.FinishedGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_FinishedGet(self)


    def RxByteCountGet(self):
        """

        Returns number of received bytes.

        """
        return _byteblower.HTTPMultiResultSnapshot_RxByteCountGet(self)


    def TxByteCountGet(self):
        """

        Returns number of sent bytes.

        """
        return _byteblower.HTTPMultiResultSnapshot_TxByteCountGet(self)


    def RxSpeedGet(self):
        return _byteblower.HTTPMultiResultSnapshot_RxSpeedGet(self)

    def TxSpeedGet(self):
        return _byteblower.HTTPMultiResultSnapshot_TxSpeedGet(self)

    def TxTimestampFirstGet(self, default_value):
        """

        Returns the timestamp (in nanoseconds) of the first transmitted packet or a
        default value in case no packets were transmitted.

        :return: Timestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.TxTimestampFirstGet(1000))


        """
        return _byteblower.HTTPMultiResultSnapshot_TxTimestampFirstGet(self, default_value)


    def TxTimestampLastGet(self, default_value):
        """

        Returns the timestamp (in nanoseconds) of the last transmitted packet or a
        default value in case no packets were transmitted.

        :return:

        Timestamp in nanoseconds

        Example
        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.TxTimestampLastGet(1000))


        """
        return _byteblower.HTTPMultiResultSnapshot_TxTimestampLastGet(self, default_value)


    def RxTimestampFirstGet(self, default_value):
        """

        Returns the timestamp (in nanoseconds) of the first receieved packet or a
        default value in case no packets were received.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.RxTimestampFirstGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_RxTimestampFirstGet(self, default_value)


    def RxTimestampLastGet(self, default_value):
        """

        Returns the timestamp (in nanoseconds) of the last receieved packet or a
        default value in case no packets were received.

        :return:

        Timestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.RxTimestampLastGet(1000))


        """
        return _byteblower.HTTPMultiResultSnapshot_RxTimestampLastGet(self, default_value)


    def TcpRxByteCountGet(self):
        """

        Returns number of bytes received by the TCP protocol. This includes the TCP
        header.

        """
        return _byteblower.HTTPMultiResultSnapshot_TcpRxByteCountGet(self)


    def TcpTxByteCountGet(self):
        """

        Returns number of bytes sent by the TCP protocol. This includes the TCP header
        and TCP retransmissions.

        """
        return _byteblower.HTTPMultiResultSnapshot_TcpTxByteCountGet(self)


    def TcpRxSpeedGet(self):
        return _byteblower.HTTPMultiResultSnapshot_TcpRxSpeedGet(self)

    def TcpTxSpeedGet(self):
        return _byteblower.HTTPMultiResultSnapshot_TcpTxSpeedGet(self)

    def TcpRxSegmentCountGet(self):
        """

        Returns number of packets received by the TCP protocol.

        """
        return _byteblower.HTTPMultiResultSnapshot_TcpRxSegmentCountGet(self)


    def TcpTxSegmentCountGet(self):
        """

        Returns number of packets sent by the TCP protocol.

        """
        return _byteblower.HTTPMultiResultSnapshot_TcpTxSegmentCountGet(self)


    def TcpTxTimestampFirstGet(self, default_value):
        """

        Returns the timestamp (in nanoseconds) of the first transmitted TCP segment or
        a default value in case no packets were transmitted.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.TcpTxTimestampFirstGet(1000))


        """
        return _byteblower.HTTPMultiResultSnapshot_TcpTxTimestampFirstGet(self, default_value)


    def TcpTxTimestampLastGet(self, default_value):
        """

        Returns the timestamp (in nanoseconds) of the last transmitted TCP segment or a
        default value in case no packets were transmitted.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.TcpTxTimestampLastGet(10000))

        """
        return _byteblower.HTTPMultiResultSnapshot_TcpTxTimestampLastGet(self, default_value)


    def TcpRxTimestampFirstGet(self, default_value):
        """

        Returns the timestamp (in nanoseconds) of the first receieved TCP segment or a
        default value in case no packets were received.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.TcpRxTimestampFirstGet(1000))


        """
        return _byteblower.HTTPMultiResultSnapshot_TcpRxTimestampFirstGet(self, default_value)


    def TcpRxTimestampLastGet(self, default_value):
        """

        Returns the timestamp (in nanoseconds) of the last receieved TCP segment or a
        default value in case no packets were received.

        :return: Timestamp in nanoseconds

        Example

        Prints -1 if the counter is not available

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.TcpRxTimestampLastGet(10000))

        """
        return _byteblower.HTTPMultiResultSnapshot_TcpRxTimestampLastGet(self, default_value)


    def RoundTripTimeAverageGet(self, default_value):
        """

        Returns average TCP round-trip time or a default value in case no round-trip
        samples are available.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.RoundTripTimeAverageGet(10000))


        """
        return _byteblower.HTTPMultiResultSnapshot_RoundTripTimeAverageGet(self, default_value)


    def RoundTripTimeMinimumGet(self, default_value):
        """

        Returns minimum TCP round-trip time or a default value in case no round-trip
        samples are available.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.RoundTripTimeMinimumGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_RoundTripTimeMinimumGet(self, default_value)


    def RoundTripTimeMaximumGet(self, default_value):
        """

        Returns maximum TCP round-trip time or a default value in case no round-trip
        samples are available.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.RoundTripTimeMaximumGet(1000))


        """
        return _byteblower.HTTPMultiResultSnapshot_RoundTripTimeMaximumGet(self, default_value)


    def RetransmissionsGet(self):
        """

        Returns number of TCP retransmissions.

        """
        return _byteblower.HTTPMultiResultSnapshot_RetransmissionsGet(self)


    def IntervalDurationGet(self):
        """

        Returns the duration (in nanoseconds) between snapshot objects.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.IntervalDurationGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_IntervalDurationGet(self)


    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].

        :return: Timestamp of snapshot in nanoseconds

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.TimestampGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_TimestampGet(self)


    def ConnectionsAttemptedGet(self):
        """

        Returns the number of TCP connection attempts that were initiated.

        For the :class:`HTTPMultiClient` this means the number of active TCP connection
        attempts initiated. For the :class:`HTTPMultiServer` this means the number of
        passive TCP connection requests received.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.ConnectionsAttemptedGet())

        """
        return _byteblower.HTTPMultiResultSnapshot_ConnectionsAttemptedGet(self)


    def ConnectionsEstablishedGet(self):
        """

        Returns the number of succesful TCP connection attempts that reached ESTABLISHED state.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.ConnectionsEstablishedGet())



        """
        return _byteblower.HTTPMultiResultSnapshot_ConnectionsEstablishedGet(self)


    def ConnectionsAbortedGet(self):
        """

        Returns the number of aborted TCP connection attempts.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.RetransmissionsGet())



        """
        return _byteblower.HTTPMultiResultSnapshot_ConnectionsAbortedGet(self)


    def ConnectionsRefusedGet(self):
        """

        Returns the number of TCP connection attempts that were refused by the other side
        .

        For the :class:`HTTPMultiServer` this value is always zero.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(multiSnapshot.ConnectionsRefusedGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_ConnectionsRefusedGet(self)


    def SessionsFinishedGet(self):
        """

        Returns the number HTTP requests that finished succesfully.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.SessionsFinishedGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_SessionsFinishedGet(self)


    def SessionsAbortedGet(self):
        """

        Returns the number HTTP requests that failed because they were aborted locally.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.SessionsAbortedGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_SessionsAbortedGet(self)


    def SessionsResetByPeerGet(self):
        """

        Returns the number HTTP requests that failed because a TCP RESET message was
        received.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.SessionsResetByPeerGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_SessionsResetByPeerGet(self)


    def DebugCountersNamesGet(self):
        """

        Returns a list of debug counter names.

        .. note:: The list of names is not backwards compatible.

        """
        return _byteblower.HTTPMultiResultSnapshot_DebugCountersNamesGet(self)


    def DebugCountersGetByName(self, name):
        """

        Returns a list of debug counter values.

        .. note: : The list of debug values is not backwards compatible.

        :param name: The name of the debug counter (obtained from
                     :meth:`DebugCountersNamesGet`).

        """
        return _byteblower.HTTPMultiResultSnapshot_DebugCountersGetByName(self, name)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp when the counters of this object where last refreshed.

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(multiSnapshot.RefreshTimestampGet())


        """
        return _byteblower.HTTPMultiResultSnapshot_RefreshTimestampGet(self)

HTTPMultiResultSnapshot_swigregister = _byteblower.HTTPMultiResultSnapshot_swigregister
HTTPMultiResultSnapshot_swigregister(HTTPMultiResultSnapshot)

class HTTPMultiResultHistory(AbstractRefreshableResult):
    """

    General interface for getting cumulative or interval results.

    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPMultiResultHistory, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPMultiResultHistory, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def CumulativeGet(self):
        """

        Returns a list of available cumulative results.

        :return: :class:`HTTPMultiResultDataList` containing the Cumulative counters

        Example

        This example gets the available cumulative results

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.CumulativeGet())

        """
        return _byteblower.HTTPMultiResultHistory_CumulativeGet(self)


    def CumulativeGetByIndex(self, index):
        """

        Returns a single item of the cumulative list.

        :param index: number of the snapshot to get

        :return: :class:`HTTPMultiResultData` cumulative counter object at the
                 specified index

        Example

        This example gets the available cumulative counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.CumulativeGetByIndex(0))

        """
        return _byteblower.HTTPMultiResultHistory_CumulativeGetByIndex(self, index)


    def CumulativeLengthGet(self):
        """

        Returns the size of the cumulative list.

        :return: The length of the cumulative list

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.CumulativeLengthGet())

        """
        return _byteblower.HTTPMultiResultHistory_CumulativeLengthGet(self)


    def IntervalGet(self):
        """

        Returns a list of available interval results.

        :return: :class:`.HTTPMultiResultDataList` containing the Interval counters

        Example

        This example gets the available interval results

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.IntervalGet()[0].DescriptionGet())


        """
        return _byteblower.HTTPMultiResultHistory_IntervalGet(self)


    def IntervalGetByIndex(self, index):
        """

        Returns a single item of the interval list.

        :param index: The interval counter to fetch

        :return: :class:`HTTPMultiResultData` interval counter object at the specified
                 index

        Example

        This example gets the available interval counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.IntervalGetByIndex(0).DescriptionGet())

        """
        return _byteblower.HTTPMultiResultHistory_IntervalGetByIndex(self, index)


    def IntervalLengthGet(self):
        """

        Returns the size of the interval list.

        :return:  The length of the interval list

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.IntervalLengthGet())


        """
        return _byteblower.HTTPMultiResultHistory_IntervalLengthGet(self)


    def CumulativeGetByTime(self, timestamp):
        """

        Returns a single item of the cumulative list using a timestamp nanoseconds.

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.CumulativeGetByTime(timestamp))


        """
        return _byteblower.HTTPMultiResultHistory_CumulativeGetByTime(self, timestamp)


    def IntervalGetByTime(self, timestamp):
        """

        Returns a single item of the interval list using a timestamp in nanoseconds.

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.IntervalGetByTime(timestamp).DescriptionGet())

        """
        return _byteblower.HTTPMultiResultHistory_IntervalGetByTime(self, timestamp)


    def CumulativeLatestGet(self):
        """

        Returns latest closed item of the cumulative list.

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.CumulativeLatestGet())

        """
        return _byteblower.HTTPMultiResultHistory_CumulativeLatestGet(self)


    def IntervalLatestGet(self):
        """

        Returns the latest closed item of the interval list.

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_result_history.IntervalLatestGet().DescriptionGet())

        """
        return _byteblower.HTTPMultiResultHistory_IntervalLatestGet(self)


    def RefreshTimestampGet(self):
        """

        RefreshTimestampGet.

        :return: Timestamp in nanoseconds since epoch

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_result_history.RefreshTimestampGet())

        """
        return _byteblower.HTTPMultiResultHistory_RefreshTimestampGet(self)


    def Clear(self):
        """

        Clears the history.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	http_result_history.Clear()



        """
        return _byteblower.HTTPMultiResultHistory_Clear(self)

HTTPMultiResultHistory_swigregister = _byteblower.HTTPMultiResultHistory_swigregister
HTTPMultiResultHistory_swigregister(HTTPMultiResultHistory)

class HTTPMultiClient(AbstractObject):
    """

    HTTPMultiClient can be used in combination with MultiServer to start multiple
    concurrent HTTP requests.

    When starting the flow, the configured number of HTTP requests will be started.
    Each time a request is finished (succesfully or unsuccesfully) it will be
    replaced by a new request. This is repeated until one of the configured stop
    conditions is reached. Possible stop conditions are: total duration, total size
    or number of connections created. If no stop conditions are configured then the
    flow continues indefinitely.

    Main parameters:

    MaximumConcurrentRequests
        Number of HTTP requests to run concurrently

    Duration
        Total duration of the flow

    Size
        Total number of bytes that may transmitted

    SessionDuration
        Duration of individual requests

    SessionSize
        Number of bytes transmitted by individual requests

    CumulativeConnectionLimit
        Maximum number of connections that may be created during the whole flow

    .. versionadded:: 2.10.0

    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPMultiClient, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPMultiClient, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def StatusGet(self):
        """

        Returns the status of the flow.

        :return: :class:`.HTTPMultiClientStatus`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.StatusGet()

        """
        return _byteblower.HTTPMultiClient_StatusGet(self)


    def FinishedGet(self):
        """

        Returns true if the flow has finished or was stopped explicitly.

        Example

        Check if the multi-session is finished

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.FinishedGet())


        """
        return _byteblower.HTTPMultiClient_FinishedGet(self)


    def DurationSet(self, value):
        """

        Sets the maximum total duration of the flow.

        A value of zero indicates unlimited duration.

        Default value: 0

        :param requestDuration: The total duration of the flow.

        Example

        Configure the flow to run for 15 minutes

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.DurationSet(15*60*1000000000)

        """
        return _byteblower.HTTPMultiClient_DurationSet(self, value)


    def DurationGet(self):
        """

        Returns the flow duration.

        A value of zero indicates unlimited duration.

        :return:  The configured request duration in nanoseconds.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.DurationGet())

        """
        return _byteblower.HTTPMultiClient_DurationGet(self)


    def SizeSet(self, value):
        """

        Puts a size limit on the total number of bytes that can be sent.

        A value of zero indicates unlimited size.

        Default value: 0

        :param requestsize: The maximum cumulative payload size of all flows.

        Example

        Allow a global payload of 1 GB

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.SizeSet(1000000000)

        """
        return _byteblower.HTTPMultiClient_SizeSet(self, value)


    def SizeGet(self):
        """

        Returns the size limit.

        A value of zero indicates unlimited size.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.SizeGet())


        """
        return _byteblower.HTTPMultiClient_SizeGet(self)


    def SessionDurationSet(self, value):
        """

        Sets the duration for the individual HTTP requests.

        Each request will run for the configured duration. This duration will
        automatically be reduced near the end of the flow so that the global time limit
        (see :meth:`DurationSet`) is not exceeded.

        A value of zero indicates unlimited duration.

        Default value: 0

        :param requestDuration: The duration of each HTTP request.

        Example

        Configure each request to run for 10 seconds

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.SessionDurationSet(10000000000))


        """
        return _byteblower.HTTPMultiClient_SessionDurationSet(self, value)


    def SessionDurationGet(self):
        """

        Returns the session duration expressed in nanoseconds.

        A value of zero indicates unlimited duration.

        Example

        .. code-block:: python
           :emphasize-lines: 1


           print(httpMultiClient.SessionDurationGet())

        """
        return _byteblower.HTTPMultiClient_SessionDurationGet(self)


    def SessionSizeSet(self, value):
        """

        Sets the size for the individual HTTP requests.

        Each new started request will send or receive the configured size in bytes.

        A value of zero indicates unlimited size.

        Default value: 0

        :param requestSize: The payload size in bytes of each HTTP request.

        Example

        Configure each request to send 15000 bytes:

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.SessionSizeSet(1500)


        """
        return _byteblower.HTTPMultiClient_SessionSizeSet(self, value)


    def SessionSizeGet(self):
        """

        Returns the session size.

        A value of zero indicates unlimited size.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.SessionSizeGet())

        """
        return _byteblower.HTTPMultiClient_SessionSizeGet(self)


    def SessionRateLimitSet(self, bytes_per_second):
        """

        Sets a rate limit for the individual HTTP requests.

        A value of zero indicates no rate limit.

        Default value: 0

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.SessionRateLimitSet(1500)

        """
        return _byteblower.HTTPMultiClient_SessionRateLimitSet(self, bytes_per_second)


    def SessionRateLimitGet(self):
        """

        Returns the rate limit for the individual HTTP requests.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.SessionRateLimitGet())

        """
        return _byteblower.HTTPMultiClient_SessionRateLimitGet(self)


    def MaximumConcurrentRequestsGet(self):
        """

        Returns the maximum number of concurrent requests.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.MaximumConcurrentRequestsGet())


        """
        return _byteblower.HTTPMultiClient_MaximumConcurrentRequestsGet(self)


    def MaximumConcurrentRequestsSet(self, value):
        """

        Sets the maximum number of concurrent requests.

        The flow will start the requested number of HTTP requests and then maintain
        this number by starting a new request every time a request has finished or
        failed.

        Default value: 1

        :param numberOfRequests: Maximum number of concurrent requests.

        Example

        Allow 100 concurrent HTTP requests:

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.MaximumConcurrentRequestsSet(100)

        """
        return _byteblower.HTTPMultiClient_MaximumConcurrentRequestsSet(self, value)


    def CumulativeConnectionLimitGet(self):
        """

        Returns the limit on the total number of connections that may be created.

        A value of zero indicates no limit (infinite number of connections may be
        created).

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.CumulativeConnectionLimitGet())

        """
        return _byteblower.HTTPMultiClient_CumulativeConnectionLimitGet(self)


    def CumulativeConnectionLimitSet(self, value):
        """

        Sets a limit on the total number of connections that may be created.

        Once the total number of connection attempts has reached the configured limit
        no new connections will be created. If there are no active connections at that
        time then flow immediately enters Finished state. Otherwise the flow remains in
        Running state until all remaining requests have finished.

        A value of zero indicates no limit (infinite number of connections may be
        created).

        Default value: 0

        Example

        Allow 100 connection attempts in total

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.CumulativeConnectionLimitSet(100)

        """
        return _byteblower.HTTPMultiClient_CumulativeConnectionLimitSet(self, value)


    def MaximumConcurrentConnectionAttemptsGet(self):
        """

        Returns the maximum number of concurrent connection attempts.

        """
        return _byteblower.HTTPMultiClient_MaximumConcurrentConnectionAttemptsGet(self)


    def MaximumConcurrentConnectionAttemptsSet(self, value):
        """

        Sets the maximum number of concurrent connection attempts.

        This method limits maximum number of requests that can be in the TCP SYN-SENT
        state.

        Default value: 1

        Example

        Allow 100 concurrent connection attempts:

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.MaximumConcurrentConnectionAttemptsSet(100)


        """
        return _byteblower.HTTPMultiClient_MaximumConcurrentConnectionAttemptsSet(self, value)


    def RemoteAddressSet(self, value):
        """

        Sets the remote address for the HTTP requests.

        :param address: The destination address for the HTTP requests.

        This should be the address of the :class:`HTTPMultiServer`.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.RemoteAddressSet('1.1.1.1')

        """
        return _byteblower.HTTPMultiClient_RemoteAddressSet(self, value)


    def RemoteAddressGet(self):
        """

        Returns the remote address.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.RemoteAddressGet())


        """
        return _byteblower.HTTPMultiClient_RemoteAddressGet(self)


    def RemotePortSet(self, value):
        """

        Sets the remote port for the HTTP requests.

        :param portNumber: The destination port for the HTTP requests.

        This should be the port that the :class:`HTTPMultiServer` is listening to.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.RemotePortSet(80)


        """
        return _byteblower.HTTPMultiClient_RemotePortSet(self, value)


    def RemotePortGet(self):
        """

        Returns the remote port.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.RemotePortGet())

        """
        return _byteblower.HTTPMultiClient_RemotePortGet(self)


    def LocalPortRangeSet(self, arg2, to):
        """

        Sets the local port range for the TCP connections.

        :param min: The minimum value of the port range.

        :param max: The maximum value of the port range.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.LocalPortRangeSet(20000,30000)


        """
        return _byteblower.HTTPMultiClient_LocalPortRangeSet(self, arg2, to)


    def LocalPortRangeGet(self):
        """

        Returns the port range.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.LocalPortRangeGet())


        """
        return _byteblower.HTTPMultiClient_LocalPortRangeGet(self)


    def MaximumSegmentSizeSet(self, value):
        """

        Sets the TCP maximum segment size.

        This option specifies an upper bound on the TCP segment size.

        :param size: Maximum segment size. Should be between 1 and 65535.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.MaximumSegmentSizeSet(65535)

        """
        return _byteblower.HTTPMultiClient_MaximumSegmentSizeSet(self, value)


    def MaximumSegmentSizeGet(self):
        """

        Returns the TCP maximum segment size.

        Default value: 65535.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.MaximumSegmentSizeGet())

        """
        return _byteblower.HTTPMultiClient_MaximumSegmentSizeGet(self)


    def ReceiveWindowInitialSizeSet(self, value):
        """

        Sets the TCP receive window.

        :param windowsize: New value of the TCP receive window. Must be between 1 and
                           65535 bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.ReceiveWindowInitialSizeSet(65535)

        """
        return _byteblower.HTTPMultiClient_ReceiveWindowInitialSizeSet(self, value)


    def ReceiveWindowInitialSizeGet(self):
        """

        Returns the TCP receive window.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.MaximumConcurrentConnectionAttemptsGet())

        """
        return _byteblower.HTTPMultiClient_ReceiveWindowInitialSizeGet(self)


    def ReceiveWindowScalingIsEnabled(self):
        """

        Returns if TCP window scaling is enabled or not.

        Window scaling enables window sizes that are larger than 65535 bytes.

        :return: True: window scale enabled , False: window scale disabled

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.ReceiveWindowScalingIsEnabled())

        """
        return _byteblower.HTTPMultiClient_ReceiveWindowScalingIsEnabled(self)


    def ReceiveWindowScalingEnable(self, inEnable):
        """

        Enables of disables the TCP window scale option.

        Window scaling window sizes that are larger than 65535 bytes.

        :raises: ByteBlower.Exception.InvalidValue - when the value is not true or
                 false

        Example

        To enable window scaling

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.ReceiveWindowScalingEnable(True)


        """
        return _byteblower.HTTPMultiClient_ReceiveWindowScalingEnable(self, inEnable)


    def ReceiveWindowScalingValueSet(self, value):
        """

        Sets the TCP window scale value.

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in IETF
        rfc:`1323`.

        :param scale: Integer (0-8), which is used for bitwise shifting.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 integer

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.ReceiveWindowScalingValueSet(3)


        """
        return _byteblower.HTTPMultiClient_ReceiveWindowScalingValueSet(self, value)


    def ReceiveWindowScalingValueGet(self):
        """

        Returns the TCP window scale value.

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in IETF
        :rfc:`1323`.

        :return: current receive window scale

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.ReceiveWindowScalingValueGet())


        """
        return _byteblower.HTTPMultiClient_ReceiveWindowScalingValueGet(self)


    def SlowStartThresholdSet(self, value):
        """

        Set the initial slow-start threshold value used by TCP.

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you
        find that TCP takes a long time to reach peak throughput. See :rfc:`5681`
        "TCP Congestion Control" for more information on this topic.

        :param ssthresh: New value for the slow-start threshold

        :raises: ByteBlower.Exception.InvalidValue - when the value is not a positive
                 integer

        Example

        To set slow-start threshold to 1000000

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.SlowStartThresholdSet(1000000)


        """
        return _byteblower.HTTPMultiClient_SlowStartThresholdSet(self, value)


    def SlowStartThresholdGet(self):
        """

        Returns the initial slow-start threshold value used by TCP.

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you
        find that TCP takes a long time to reach peak throughput. See :rfc:`5681`
        "TCP Congestion Control" for more information on this topic.

        :return: Slow-start threshold

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpMultiClient.SlowStartThresholdGet())


        """
        return _byteblower.HTTPMultiClient_SlowStartThresholdGet(self)


    def TcpCongestionAvoidanceAlgorithmSet(self, value):
        """

        Configure the preferred TCP Congestion Avoidance Algorithm.

        :param congestionAvoidanceAlgorithm: Congestion Avoidance Algorithm to configure.

                                             - none
                                             - sack
                                             - newreno
                                             - sack-with-cubic
                                             - newreno-with-cubic

        :raises: python_error - Failed to parse enumerator: When the value could not be
                 interpreted as a valid TCAA

        Example

        Configure NewReno as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.NewReno)

        Configure Sack as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.Sack)

        Configure None as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.No_Algorithm)

        """
        return _byteblower.HTTPMultiClient_TcpCongestionAvoidanceAlgorithmSet(self, value)


    def TcpCongestionAvoidanceAlgorithmGet(self):
        """

        Returns the preferred TCP Congestion Avoidance Algorithm.

        :return: current Congestion Avoidance Algorithm.

        Possible values are:
        - none
        - sack
        - newreno
        - sack-with-cubic
        - newreno-with-cubic

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.TcpCongestionAvoidanceAlgorithmGet()==TCPCongestionAvoidanceAlgorithm.NewReno)


        """
        return _byteblower.HTTPMultiClient_TcpCongestionAvoidanceAlgorithmGet(self)


    def TypeOfServiceSet(self, value):
        """

        Sets the 'Type Of Service' or 'Traffic Class' used at the IP layer.

        Both IP headers reserve space to specify the expected quality of service(QOS).
        IPv4 calls this field the 'Type Of Service'. In IPv6 one uses the term
        'Traffic Class'. Despite naming, they are both 8 bits wide. For ease of use,
        the method is generic, it is used for both IPv4 and IPv6 layers. The
        implementation will configure the proper header.

        The input accepts integers from 0 up to 255. This value will be directly used
        in byte-sized field at the IP layer. No additional coding is performed.

        This method can be called solely during the configuration phase,thus before the
        parent ByteBlower port is started. Invoking the method at other moments will
        result in error.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.TypeOfServiceSet(16)

        """
        return _byteblower.HTTPMultiClient_TypeOfServiceSet(self, value)


    def TypeOfServiceGet(self):
        """

        Returns the 'Type Of Service' or 'Traffic Class' value.

        """
        return _byteblower.HTTPMultiClient_TypeOfServiceGet(self)


    def FlowLabelSet(self, value):
        """

        Sets the flow label for IPv6 flows.

        This feature only affects IPv6 flows. It is ignored for IPv4 flows.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.FlowLabelSet(1234)

        """
        return _byteblower.HTTPMultiClient_FlowLabelSet(self, value)


    def FlowLabelGet(self):
        """

        Returns the "Flow Label" for IPv6 flows.

        This feature only affects IPv6 flows. It is ignored for IPv4 flows.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient = port.RemotePortGet()
           print(httpMultiClient.FlowLabelGet())

        """
        return _byteblower.HTTPMultiClient_FlowLabelGet(self)


    def HttpMethodSet(self, *args):
        """

        Sets the HTTP request method.

        There are 2 possible values:

        GET
            For HTTP GET requests (data will be downloaded from the HTTP server).

        PUT
            For HTTP PUT requests (data will be uploaded to the HTTP server).

        Default value: GET

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.HttpMethodSet(HTTPRequestMethod.Get))



        Sets the HTTP request method.

        There are 2 possible values:

        GET
            For HTTP GET requests (data will be downloaded from the HTTP server).

        PUT
            For HTTP PUT requests (data will be uploaded to the HTTP server).

        Default value: GET

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.HttpMethodSet(HTTPRequestMethod.Get))


        """
        return _byteblower.HTTPMultiClient_HttpMethodSet(self, *args)


    def HttpMethodGet(self):
        """

        Returns the HTTP request method.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.HttpMethodGet() == HTTPRequestMethod.Get)

        """
        return _byteblower.HTTPMultiClient_HttpMethodGet(self)


    def InitialTimeToWaitSet(self, ns):
        """

        Sets the initial time to wait before really starting the flow.

        This can be used if you want to different flows to start at different times.

        Default value: 0

        :param timetowait: Time to wait before the flow will start.

        Example

        Initial Time to wait of 60 seconds

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.InitialTimeToWaitSet(60000000000)


        """
        return _byteblower.HTTPMultiClient_InitialTimeToWaitSet(self, ns)


    def InitialTimeToWaitGet(self):
        """

        Returns the initial time to wait value.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.InitialTimeToWaitGet())


        """
        return _byteblower.HTTPMultiClient_InitialTimeToWaitGet(self)


    def Start(self):
        """

        Starts the flow.

        :raises: :exc:`.ConfigError` This exception is thrown in case of an incomplete
                 configuration. For example if the remote IP or remote port is not set.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.Start()

        """
        return _byteblower.HTTPMultiClient_Start(self)


    def Stop(self):
        """

        Stops the flow.

        Explicitly stops a flow. Normally the flow finishes automatically when the
        configured duration or size has been reached. This method stops the flow
        immediately.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           httpMultiClient.Stop()

        """
        return _byteblower.HTTPMultiClient_Stop(self)


    def SamplingIntervalDurationGet(self):
        """

        Returns the duration for the result snapshots.

        :param intervalDuraton: expressed as nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.SamplingIntervalDurationGet())

        """
        return _byteblower.HTTPMultiClient_SamplingIntervalDurationGet(self)


    def SamplingIntervalDurationSet(self, value):
        """

        Sets the duration of the result snapshots.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.SamplingIntervalDurationSet(1500000)


        """
        return _byteblower.HTTPMultiClient_SamplingIntervalDurationSet(self, value)


    def SamplingBufferLengthGet(self):
        """

        Returns the snapshot buffer length.

        :return:  The length of the server sample buffer

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.SamplingBufferLengthGet())

        """
        return _byteblower.HTTPMultiClient_SamplingBufferLengthGet(self)


    def SamplingBufferLengthSet(self, value):
        """

        Configure the snapshot buffer size.

        ByteBlower server stores the snapshots in a circular buffer before they are
        transferred to the client. If the buffer overflows then the oldest snapshot is
        overwritten. This method configures the maximum size of the buffer.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpMultiClient.SamplingBufferLengthSet(6)

        """
        return _byteblower.HTTPMultiClient_SamplingBufferLengthSet(self, value)


    def ResultGet(self):
        """

        Returns the current result counters.

        :return: :class:`HTTPMultiResultSnapshot` object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.ResultGet().DescriptionGet())


        """
        return _byteblower.HTTPMultiClient_ResultGet(self)


    def ResultHistoryGet(self):
        """

        Returns the result history.

        This method returns a :class:`HTTPMultiResultHistory` Object. This will
        contain the Cumulative and the Interval counters over time.

        :return: :class:`HTTPMultiResultHistory`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpMultiClient.ResultHistoryGet().DescriptionGet())


        """
        return _byteblower.HTTPMultiClient_ResultHistoryGet(self)

HTTPMultiClient_swigregister = _byteblower.HTTPMultiClient_swigregister
HTTPMultiClient_swigregister(HTTPMultiClient)

HTTPMultiServerStatus_Stopped = _byteblower.HTTPMultiServerStatus_Stopped
HTTPMultiServerStatus_Started = _byteblower.HTTPMultiServerStatus_Started
class HTTPMultiServer(AbstractObject):
    """

    HTTPMultiServer provides the server-side for HTTPMultiClient.

    See :class:`HTTPMultiClient` for more information.

    .. versionadded:: 2.10.0


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPMultiServer, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPMultiServer, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ByteBlowerServerGet(self):
        return _byteblower.HTTPMultiServer_ByteBlowerServerGet(self)

    def ByteBlowerPortGet(self):
        return _byteblower.HTTPMultiServer_ByteBlowerPortGet(self)

    def StatusGet(self):
        """

        Returns the HTTP server status.

        :return: :class:`.HTTPMultiServerStatus`

        Example

        Before starting the HTTP server:  `HTTPMultiServerStatus.Stopped`
        After starting the HTTP server:  `HTTPMultiServerStatus.Started`

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.StatusGet() == HTTPMultiServerStatus_Started)



        """
        return _byteblower.HTTPMultiServer_StatusGet(self)


    def PortSet(self, inPort):
        """

        Sets the TCP port on which the HTTP server will listen.

        :param port: The TCP port on which the HTTP server will listen for incoming
                     requests.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer
        :raises: ByteBlower.Exception.InvalidConfig - when the value is not between 1
                 and 65535

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	http_server.PortSet(80)



        """
        return _byteblower.HTTPMultiServer_PortSet(self, inPort)


    def PortGet(self):
        """

        Returns the TCP port for the HTTP server.

        :return:  The configured TCP Port

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.PortGet())



        """
        return _byteblower.HTTPMultiServer_PortGet(self)


    def MaximumSegmentSizeSet(self, value):
        """

        Sets the TCP maximum segment size.

        This option specifies an upper bound on the TCP segment size.

        :param size: Maximum segment size. Should be between 1 and 65535.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	result_history = http_server.MaximumSegmentSizeSet(65535)



        """
        return _byteblower.HTTPMultiServer_MaximumSegmentSizeSet(self, value)


    def MaximumSegmentSizeGet(self):
        """

        Returns the TCP maximum segment size.

        The default value is 65535.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.MaximumSegmentSizeGet())



        """
        return _byteblower.HTTPMultiServer_MaximumSegmentSizeGet(self)


    def ReceiveWindowInitialSizeSet(self, value):
        """

        Sets the initial receive window for the server.

        Small windowsizes can decrease the performance of a TCP session. Please use
        good size for your configuration and network setup.

        :param windowsize: New value of the initial receive window.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	http_server.SlowStartThresholdSet(65535)


        """
        return _byteblower.HTTPMultiServer_ReceiveWindowInitialSizeSet(self, value)


    def ReceiveWindowInitialSizeGet(self):
        """

        Gets the initial receive window for the server.

        Small windowsizes can decrease the performance of a TCP session. Please use a
        good size for your configuration and network setup.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.ReceiveWindowInitialSizeGet())



        """
        return _byteblower.HTTPMultiServer_ReceiveWindowInitialSizeGet(self)


    def ReceiveWindowScalingIsEnabled(self):
        """

        Returns if window scaling is enabled or not.

        Windowscaling allows windowsizes to grow further than 65,536 bytes. For high
        speed or high latency links, window scaling should be enabled for a good
        throughput.

        :return: True when scaling is enabled, false when scaling is disabled

        Example

        When enabled:

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.ReceiveWindowScalingIsEnabled())


        """
        return _byteblower.HTTPMultiServer_ReceiveWindowScalingIsEnabled(self)


    def ReceiveWindowScalingEnable(self, value):
        """

        Enables of disables windowscaling.

        Windowscaling allows windowsizes to grow further than 65,536 bytes. For high
        speed or high latency links, window scaling should be enabled for a good
        throughput.

        :param scaling: bool which will enable (True) or disable (False) windowscaling.

        :raises: ByteBlower.Exception.InvalidValue - when the value is not true or
                 false

        Example

        To enable window scaling  or  To disable window scaling  or

        .. code-block:: python
           :emphasize-lines: 1

        	http_server.ReceiveWindowScalingEnable(True)

        """
        return _byteblower.HTTPMultiServer_ReceiveWindowScalingEnable(self, value)


    def ReceiveWindowScalingValueSet(self, value):
        """

        Sets the window scale which will be used for new clients.

        This must be done before requesting a page from a client, because this option
        is negotiated at the beginning of the TCP session.

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in IETF
        :rfc:`1323`.

        :param scale: Integer (0-8), which is used for bitwise shifting.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 integer

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	http_server.ReceiveWindowScalingValueSet(6)


        """
        return _byteblower.HTTPMultiServer_ReceiveWindowScalingValueSet(self, value)


    def ReceiveWindowScalingValueGet(self):
        """

        Returns the current receive window scale.

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in IETF
        :rfc:`1323`.

        :return: current receive window scale

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.ReceiveWindowScalingValueGet())



        """
        return _byteblower.HTTPMultiServer_ReceiveWindowScalingValueGet(self)


    def SlowStartThresholdSet(self, value):
        """

        Set the initial slow-start threshold value used by TCP.

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you find
        that TCP takes a long time to reach peak throughput. See rfc:`5681`
        "TCP Congestion Control" for more information on this topic.

        :param ssthresh: New value for the slow-start threshold

        :raises: ByteBlower.Exception.InvalidValue - when the value is not a positive
                 integer

        Example

        To set slow-start threshold to 1000000

        .. code-block:: python
           :emphasize-lines: 1

        	http_server.SlowStartThresholdSet(1000000)


        """
        return _byteblower.HTTPMultiServer_SlowStartThresholdSet(self, value)


    def SlowStartThresholdGet(self):
        """

        Returns the initial slow-start threshold value used by TCP.

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you
        find that TCP takes a long time to reach peak throughput. See :rfc:`5681`
        "TCP Congestion Control" for more information on this topic.

        :return: Slow-start threshold

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.SlowStartThresholdGet())



        """
        return _byteblower.HTTPMultiServer_SlowStartThresholdGet(self)


    def TcpCongestionAvoidanceAlgorithmSet(self, value):
        """

        Selects the TCP Congestion Avoidance Algorithm.

        Selects the TCP Congestion Avoidance Algorithm which will be used for new
        clients. This must be selected before requesting a page from a client,
        because for some algorithms, the congestion avoidance support is negotiated a
        the beginning of the TCP session.

        :parameter algorithm: Congestion Avoidance Algorithm to configure.

        Possible algorithms are:

        - none
        - sack
        - newreno
        - sack-with-cubic
        - newreno-with-cubic

        :raises: python_error: Failed to parse enumerator: When the value could not be
                 interpreted as a valid TCAA

        Example

        Configure NewReno as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

        	http_client.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.NewReno)

        Configure Sack as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

        	http_client.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.Sack)

        Configure None as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

        	http_client.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.No_Algorithm)



        """
        return _byteblower.HTTPMultiServer_TcpCongestionAvoidanceAlgorithmSet(self, value)


    def TcpCongestionAvoidanceAlgorithmGet(self):
        """

        Gets the current TCP Congestion Avoidance Algorithm for new clients.

        :return: current Congestion Avoidance Algorithm.

        Possible values are:
        - none
        - sack
        - newreno
        - sack-with-cubic
        - newreno-with-cubic

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.TcpCongestionAvoidanceAlgorithmGet() == TCPCongestionAvoidanceAlgorithm.NewReno)


        """
        return _byteblower.HTTPMultiServer_TcpCongestionAvoidanceAlgorithmGet(self)


    def Start(self):
        """

        Starts the HTTP server on the configured port with the configured
        configuration.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_server.Start()


        """
        return _byteblower.HTTPMultiServer_Start(self)


    def Stop(self):
        """

        Stops the HTTP server.

        Running sessions will be aborted and incoming connection requests will be
        refused.

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	http_server.Stop()



        """
        return _byteblower.HTTPMultiServer_Stop(self)


    def SamplingIntervalDurationGet(self):
        """

        Duration of one sampling interval in nanoseconds.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.SamplingIntervalDurationGet())



        """
        return _byteblower.HTTPMultiServer_SamplingIntervalDurationGet(self)


    def SamplingIntervalDurationSet(self, value):
        """

        Sets the duration of one sampling interval.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server.SamplingIntervalDurationGet())



        """
        return _byteblower.HTTPMultiServer_SamplingIntervalDurationSet(self, value)


    def SamplingBufferLengthGet(self):
        """

        Number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method gets the maximum number of samples the
        server can hold.

        :return: The length of the server sample buffer

        """
        return _byteblower.HTTPMultiServer_SamplingBufferLengthGet(self)


    def SamplingBufferLengthSet(self, value):
        """

        Sets the number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	http_server.SamplingBufferLengthSet(6)



        """
        return _byteblower.HTTPMultiServer_SamplingBufferLengthSet(self, value)


    def ResultGet(self):
        """

        Returns the current result counters.

        :return:  :class:`HTTPMultiResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(http_server_result = http_server.ResultGet().DescriptionGet())



        """
        return _byteblower.HTTPMultiServer_ResultGet(self)


    def ResultHistoryGet(self):
        """

        Returns the result history.

        This method returns a :class:`HTTPMultiResultHistory` object. This will contain
        the Cumulative and the Interval counters over time.

        :return: :class:`HTTPMultiResultHistory`.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	result_history = http_server.ResultHistoryGet()



        """
        return _byteblower.HTTPMultiServer_ResultHistoryGet(self)

HTTPMultiServer_swigregister = _byteblower.HTTPMultiServer_swigregister
HTTPMultiServer_swigregister(HTTPMultiServer)

class HTTPClient(SchedulableObject):
    """

    HTTP client application that may schedule HTTP requests to real webservers or
    the HTTP server application.

    Using this class, you can simulate TCP (Transmission Control Protocol) traffic
    The TCP is simulated by a HTML request to the HTTPServer. This is the
    HttpClient that will perform the GET or the PUT. This request can be sent to
    the :class:`HTTPServer` or even a real HTTPServer.

    .. code-block:: python

    	httpClient = port.ProtocolHttpClientAdd()
        httpClient.RemoteAddressSet('1.1.1.1')
        httpClient.RemotePortSet(80)
        httpClient.CaptureEnable()
        httpClient.RequestDurationSet(10 * 1000)
        httpClient.ReceiveWindowScalingValueSet(7)
        httpClient.SlowStartThresholdSet(2000000000)
        httpClient.RequestStart()



    """

    __swig_setmethods__ = {}
    for _s in [SchedulableObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPClient, name, value)
    __swig_getmethods__ = {}
    for _s in [SchedulableObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPClient, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RequestStatusGet(self):
        """

        Returns the status of the HTTP request.

        :return: :class:`.HTTPRequestStatus`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.RequestStatusGet() == HTTPRequestStatus.Scheduled)


        """
        return _byteblower.HTTPClient_RequestStatusGet(self)


    def ErrorMessageGet(self):
        """

        Returns the error message.

        When the request status is "Error" then extra information can be obtained
        with this method.

        :return:  The error message string

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.ErrorMessageGet())

        """
        return _byteblower.HTTPClient_ErrorMessageGet(self)


    def FinishedGet(self):
        """

        Returns whether or not the HTTP session has finished.

        :return: True: Finished (with or without error), False: Not Finished

        Example

        Check if the client is finished

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.FinishedGet())

        """
        return _byteblower.HTTPClient_FinishedGet(self)


    def HasSession(self):
        """

        Returns whether or not we have a HTTP session.

        :return:  True We have a session, False  We don't have a session

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.MaximumSegmentSizeGet())

        """
        return _byteblower.HTTPClient_HasSession(self)


    def HasError(self):
        """

        Returns true if an error has occurred.

        :return: True: An error has occurred , False: No error has occurred

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.HasError())

        """
        return _byteblower.HTTPClient_HasError(self)


    def WaitUntilConnected(self, timeout):
        """

        Waits until connection is established or timeout has expired.

        Valid states in which this method may be called: scheduled, connecting,
        running and finished.

        Returns true immediately when called from running or finished states.

        Returns false if timeout expired before running state was reached.

        :raises: :exc:`ConfigError` if called from configuration or stopped state.

        When called from error state or if error state is reached while waiting then the
        server-side exception that caused the error state will be rethrown here.

        :param timeout: How long we should wait before giving up (and returning false).

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	while not httpClient.WaitUntilConnected(1000000000):
        		print('Waiting until connected...')

        """
        return _byteblower.HTTPClient_WaitUntilConnected(self, timeout)


    def WaitUntilFinished(self, timeout_ns):
        """

        Waits until request is finished or timeout has expired.

        Valid states in which this method may be called:

        - scheduled
        - connecting
        - running
        - finished.

        Returns true immediately when called from finished state.

        Returns false if timeout expired before finished state was reached.

        :raises: :exc:`ConfigError` if called from configuration or stopped state.

        When called from error state or if error state is reached while waiting then
        the server-side exception that caused the error state will be rethrown here.

        :param timeout: How long we should wait before giving up (and returning false).

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	while not httpClient.WaitUntilFinished(1000000000):
        		print('Wait until finished...')

        """
        return _byteblower.HTTPClient_WaitUntilFinished(self, timeout_ns)

    RequestStartType_Direct = _byteblower.HTTPClient_RequestStartType_Direct
    RequestStartType_Scheduled = _byteblower.HTTPClient_RequestStartType_Scheduled

    def RequestStartTypeSet(self, inRequestStartType):
        """

        Configures the Start Type of a HTTP Request.

        Configures the Start Type of a HTTP Request. There are 2 possible values:

        direct
            will send out the HTTP Request as soon as a 'Page', 'Size' or 'Duration' is
            requested.

        scheduled
            will send out the HTTP Request ('Page', 'Size' or 'Duration') as soon as
            soon as the ByteBlower Port starts sending.

        :param startType: Start Type of the HTTP request.
                          Must be 'direct' or 'scheduled'.

        Default value: direct

        Example

        Setting the startype to direct

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.RequestStartTypeSet(RequestStartType.Direct)

        Setting the startype to scheduled use :meth:`RequestInitialTimeToWaitSet` to
        configure the schedule

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.RequestStartTypeSet(RequestStartType.Scheduled)

        """
        return _byteblower.HTTPClient_RequestStartTypeSet(self, inRequestStartType)


    def RequestStartTypeGet(self):
        """

        Returns the current configured Start Type.

        Returns the current configured Start Type for a HTTP Request. There are 2
        possible values:

        direct
            will send out the HTTP Request as soon as a 'Page', 'Size' or 'Duration' is
            requested.

        scheduled
            will send out the HTTP Request ('Page', 'Size' or 'Duration') as soon as
            soon as the ByteBlower Port starts sending.

        Default value: direct

        :return: Configured start type: direct or scheduled

        Example

        On a httpClient with direct starttype

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.RequestStartTypeGet() == RequestStartType.Scheduled)

        """
        return _byteblower.HTTPClient_RequestStartTypeGet(self)


    def RequestStart(self):
        """

        Start the current configured HTTP Request.

        The Start Type can be configured using :meth:`RequestStartTypeSet`

        Configuring the Request is done using :meth:`RequestSizeSet` and
        :meth:`RequestDurationSet`

        :raises: :exc:`.ConfigError` This exception is thrown when some  configurations
                  are incorrect. For example if the RemoteAddress is an IPv6 address
                  and the HTTPClient has a IPv4 address.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.RequestStart()

        """
        return _byteblower.HTTPClient_RequestStart(self)


    def RequestStop(self):
        """

        This will stop the client.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.RequestStop()



        """
        return _byteblower.HTTPClient_RequestStop(self)


    def RequestSizeSet(self, inRequestSize):
        """

        Method which will configure a page to send out an HTTP Request to request a
        certain number of Bytes.

        A HTTP Request page will be configured to request for a certain size of data on
        a ByteBlower HTTP server.

        This will prepare a nice TCP traffic test with the number of requested Bytes
        transferred over the network.

        .. note:: The HTTP Method that is used for the Request can be configured using
                  :meth:`HttpMethodSet`
                  The HTTP Method defines the way the data traffic will flow.

        .. note:: The Start Type that is used for the Request can be configured using
                  :meth:`RequestStartTypeSet`
                  The Start Type defines when the HTTP Request will start.

        .. note:: The generated HTTP Request URI format is specific for a ByteBlower
                  HTTP Server.

        :param requestsize: The number of Bytes to send the HTTP Request for.

        Example

        Setting the requestsize to 10000000 Bytes

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.RequestSizeSet(10000000)

        """
        return _byteblower.HTTPClient_RequestSizeSet(self, inRequestSize)


    def RequestSizeGet(self):
        """

        Method which will return the configured requested pagesize expressed in Bytes.

        :return: The configured requested pagesize in Bytes

        A HTTP Request page will be configured to request for a certain size of data on
        a ByteBlower HTTP server.

        Example

        Getting the configured requestsize

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.RequestSizeGet())

        """
        return _byteblower.HTTPClient_RequestSizeGet(self)


    def RequestDurationSet(self, inDurationNs):
        """

        Method which will configure a page to send out an HTTP Request to transmit data
        during a certain time.

        A HTTP Request page will be configured to request to send data, during a
        certain time, on a ByteBlower HTTP server.

        This will prepare a nice TCP traffic test with data transferred over the
        network until the requested duration has passed.

        .. note:: The HTTP Method that is used for the Request can be configured using
                  :meth:`HTTPMethodSet`. The HTTP Method defines the way the data
                  traffic will flow.

        .. note:: The Start Type that is used for the Request can be configured using
                  :meth:`RequestStartTypeSet`. The Start Type defines when the HTTP
                  Request will     start.

        .. note:: The generated HTTP Request URI format is specific for a ByteBlower
                  HTTP Server.

        :param requestDuration: The duration of data traffic to send the HTTP Request
                                for.

        :raises: python_error: bad lexical cast: When the value could not be
                 interpreted as a valid time string

        Example

        will configure a request to transfer data during 1.5 seconds expressed in nano seconds

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.RequestDurationSet(1.5 * 1000000000)

        """
        return _byteblower.HTTPClient_RequestDurationSet(self, inDurationNs)


    def RequestDurationGet(self):
        """

        Method which will return the configured HTTP Request duration.

        A HTTP Request page will be configured to request to send data, during a
        certain time, on a ByteBlower HTTP server.

        :return: The HTTP request duration.

        Example

        Get the configured request duration

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.RequestDurationGet())

        """
        return _byteblower.HTTPClient_RequestDurationGet(self)


    def RequestRateLimitSet(self, inRateLimitBytesps):
        """

        Method which will limit the rate of the HTTP traffic to a certain amount..

        :param rateLimit: The rate limit, in bytes per second.

        Example

        Setting the rate limit to 10 MBytesps

        .. code-block:: python
           :emphasize-lines: 2

        	httpClient.RequestRateLimitSet(10000000)

        Example

        Disable rate limit

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.RequestRateLimitSet(0)

        """
        return _byteblower.HTTPClient_RequestRateLimitSet(self, inRateLimitBytesps)


    def RequestRateLimitGet(self):
        """

        Method which will return the configured rate-limit of the HTTP traffic.

        :return: rateLimit The rate limit, in bytes per second.

        Example

        Getting the configured rate limit.

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.RequestRateLimitGet())

        """
        return _byteblower.HTTPClient_RequestRateLimitGet(self)


    def RequestPageSet(self, arg2):
        """

        Method which will set the HTML page which will be requested.

        If you are requesting on a ByteBlower HTTP Server, please check
        :meth:`RequestSizeSet` and :meth:`RequestDurationSet` for specialized HTTP
        Requests

        Method which will set the HTML page which will be requested. When
        :meth:`RequestStart` is called, the HTTP Client will send a HTTP Request
        message for this page and will listen for a response.

        A typical use in ByteBlower is a request for a certain size to a ByteBlower
        HTTP server. e.g. `10000000.html` This will give us a nice TCP traffic test
        with the number of requested Bytes transferred over the network.

        .. note:: The HTTP Method that is used for the Request can be configured using
                  :meth:`HttpMethodSet` The HTTP Method defines the way the data
                  traffic will flow.

        .. note:: The Start Type that is used for the Request can be configured using
                  :meth:`RequestStartTypeSet` The Start Type defines the way the data
                  traffic will flow.

        :param pagename: The page to send the HTTP Request for.

        Example

        Setting the client to request for the page: 100000.html

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.RequestPageSet('100000.html')


        """
        return _byteblower.HTTPClient_RequestPageSet(self, arg2)


    def RequestPageGet(self):
        """

        Method which will get the HTML page which will be requested.

        If you are requesting on a ByteBlower HTTP Server, please check
        :meth:`RequestSizeSet` and :meth:`RequestDurationSet` for specialized HTTP
        Requests

        Method which will set the HTML page which will be requested. When
        :meth:`RequestStart` is called, the HTTP Client will send a HTTP Request
        message for this page and will listen for a response.

        A typical use in ByteBlower is a request for a certain size to a ByteBlower
        HTTP server. e.g. 10000000.html This will give us a nice TCP traffic test with
        the number of requested Bytes transferred over the network.

        :return: the HTML page name that will be requested

        .. note:: The HTTP Method that is used for the Request can be configured using
                  :meth:`HttpMethodSet`
                  The HTTP Method defines the way the data traffic will flow.

        .. note:: The Start Type that is used for the Request can be configured using
                  :meth:`RequestStartTypeSet`
                  The Start Type defines when the data traffic will start.

        Example


        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.RequestPageGet())


        """
        return _byteblower.HTTPClient_RequestPageGet(self)


    def RequestUriSet(self, inURI):
        """

        Method which will set the URI, it contains the complete HTTP URI which will be requested.

        When :meth:`RequestStart` is called, the HTTP Client will send a HTTP Request
        message for this page and will listen for a response.

        Different from the :meth:`RequestPageSet` method, this method allows you to
        configure a HTTP Request to external (non-ByteBlower) HTTP servers without
        adding the 'server-client-id' to the HTTP Request page's path. Configuring the
        URI will also configure the HTTP Server address and HTTP Server TCP to which
        the HTTP Request is sent.

        .. note:: DNS resolution is not supported for the URI, so the HTTP Server needs
                  to be an IPv4 or IPv6 address.

        :param uri: The URI the httpClient must request.

        Example

        configure the HTTP Client to send a request to HTTP Server 1.1.1.1, on the
        default TCP port 80, for page '/test/index.html'

        .. code-block:: python
           :emphasize-lines: 2

        	httpClient.RequestUriSet(http://1.1.1.1/test/index.html)

        configure the HTTP Client to send a request to HTTP Server 10.10.10.2, on TCP
        port 8080, for page '/project/index.html'

        .. code-block:: python
           :emphasize-lines: 2

        	httpClient.RequestUriSet(http://10.10.10.2:8080/project/index.html)


        """
        return _byteblower.HTTPClient_RequestUriSet(self, inURI)


    def RequestUriGet(self):
        """

        Returns the requested URI.

        Returns the URI like it is or will be requested by the client.

        :return: HTTP Request URI as configured by :meth:`RequestUriSet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.RequestUriGet())

        """
        return _byteblower.HTTPClient_RequestUriGet(self)


    def LocalPortSet(self, inPort):
        """

        Configure the TCP port for the client to use.

        This method will set the TCP port for the client.

        :param port: TCP port on which the client will listen or replies and send its
                     requests.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        :raises: ByteBlower.Exception.InvalidConfig - when the value is not between 1
                 and 65535

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.LocalPortSet(45780)


        """
        return _byteblower.HTTPClient_LocalPortSet(self, inPort)


    def LocalPortGet(self):
        """

        Returns the TCP the httpclient will use to send its HTTPRequest.

        :return: The TCP port the client uses.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.LocalPortGet())

        """
        return _byteblower.HTTPClient_LocalPortGet(self)


    def RemoteAddressSet(self, inAddress):
        """

        Configure the destination address.

        Method to configure the address of the HTTP server which this client will try
        to contact.

        .. note:: Be aware that only addresses are used, no DNS is supported at this
                  moment.

        :param address: Address of the HTTP server this client will use.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.RemoteAddressSet('1.1.1.1')

        """
        return _byteblower.HTTPClient_RemoteAddressSet(self, inAddress)


    def RemoteAddressGet(self):
        """

        Return the configured destination address.

        Returns the current configured remote site address.

        :return: destination address

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpClient.RemoteAddressGet())

        """
        return _byteblower.HTTPClient_RemoteAddressGet(self)


    def RemotePortSet(self, inRemotePort):
        """

        Configure the TCP port which the client will use as destination port.

        This method is used to configure the TCP port of the server which the client
        will try to contact.

        :param port: TCP port of the HTTP server which the client will try to contact.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        :raises: ByteBlower.Exception.InvalidConfig - when the value is not between 1
                 and 65535

        Example

        Configure the client to use port 80 as destination port

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.RemotePortSet(80)


        """
        return _byteblower.HTTPClient_RemotePortSet(self, inRemotePort)


    def RemotePortGet(self):
        """

        Returns the configured destination port.

        This method returns the current configured TCP port of the HTTP server which
        this client will try to contact.

        :return: the remote (destination) tcp port

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	port = httpClient.RemotePortGet()

        """
        return _byteblower.HTTPClient_RemotePortGet(self)


    def MaximumSegmentSizeSet(self, inValue):
        """

        Sets the TCP maximum segment size.

        This option specifies an upper bound on the TCP segment size.

        :param size: Maximum segment size. Should be between 1 and 65535.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.MaximumSegmentSizeSet(65535)

        """
        return _byteblower.HTTPClient_MaximumSegmentSizeSet(self, inValue)


    def MaximumSegmentSizeGet(self):
        """

        Returns the configured TCP maximum segment size.

        The default value is 65535.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.MaximumSegmentSizeGet())


        """
        return _byteblower.HTTPClient_MaximumSegmentSizeGet(self)


    def ReceiveWindowInitialSizeSet(self, inValue):
        """

        Sets the initial receive window for the client.

        Small windowsizes can decrease the performance of a TCP session. Please use a
        good size for your configuration and network setup.

        :param windowsize: New value of the initial receive window.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.ReceiveWindowInitialSizeSet(65535)

        """
        return _byteblower.HTTPClient_ReceiveWindowInitialSizeSet(self, inValue)


    def ReceiveWindowInitialSizeGet(self):
        """

        Gets the initial receive window for the client.

        Small windowsizes can decrease the performance of a TCP session. Please use a
        good size for your configuration and network setup.

        Default value: 65535

        :return: The configured initial receive window size.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.ReceiveWindowInitialSizeGet())


        """
        return _byteblower.HTTPClient_ReceiveWindowInitialSizeGet(self)


    def ReceiveWindowScalingIsEnabled(self):
        """

        Returns if windowscaling is enabled or not.

        Windowscaling allows windowsizes to grow further than 65,536 bytes. For high
        speed or high latency links, window scaling should be enabled for a good
        throughput.

        :return: True window scale enabled, False window scale disabled

        Default value: True

        Example

        When enabled:

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.ReceiveWindowScalingIsEnabled())

        """
        return _byteblower.HTTPClient_ReceiveWindowScalingIsEnabled(self)


    def ReceiveWindowScalingEnable(self, inEnable):
        """

        Enables of disables windowscaling.

        Windowscaling allows windowsizes to grow further than 65,536 bytes. For high
        speed or high latency links, window scaling should be enabled for a good
        throughput.

        :param scaling: bool: which will enable (True) or disable (false)
                        windowscaling.

        :raises: ByteBlower.Exception.InvalidValue - when the value is not true or
                 false

        Default value: true

        Example

        To enable window scaling

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.ReceiveWindowScalingEnable(False)

        or to disable window scaling

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.ReceiveWindowScalingEnable(False)

        """
        return _byteblower.HTTPClient_ReceiveWindowScalingEnable(self, inEnable)


    def ReceiveWindowScalingValueSet(self, inValue):
        """

        Configures the window scale which will be used for the client.

        .. note:: This must be done before requesting the page, because this option is
                  negotiated at the beginning of the TCP session.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an Integer

        :raises: :exc:`.ConfigError` when the value is not in the range 0-8

        :param scale: Integer (0-8), which is used for bitwise shifting.

        Default value: 3

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.ReceiveWindowScalingValueSet()

        """
        return _byteblower.HTTPClient_ReceiveWindowScalingValueSet(self, inValue)


    def ReceiveWindowScalingValueGet(self):
        """

        Returns the current receive window scale.

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in IETF
        rfc:`1323`.

        Default value: 3

        :return:  the current receive window scale

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.ReceiveWindowScalingValueGet())


        """
        return _byteblower.HTTPClient_ReceiveWindowScalingValueGet(self)


    def SlowStartThresholdSet(self, inValue):
        """

        Set the initial slow-start threshold value used by TCP.

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you find
        that TCP takes a long time to reach peak throughput.
        See :rfc:`5681` "TCP Congestion Control" for more information on this topic.

        :param sstresh: New value for the slow-start threshold

        :raises: ByteBlower.Exception.InvalidValue - when the value is not a positive integer

        Default value: 65535

        Example

        To set slow-start threshold to 1000000

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.SlowStartThresholdSet(1000000)

        """
        return _byteblower.HTTPClient_SlowStartThresholdSet(self, inValue)


    def SlowStartThresholdGet(self):
        """

        Returns the initial slow-start threshold value used by TCP.

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you find
        that TCP takes a long time to reach peak throughput. See :rfc:`5681` "TCP
        Congestion Control" for more information on this topic.

        :return: slowstart threshold

        Default value: 65535

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.SlowStartThresholdGet())

        """
        return _byteblower.HTTPClient_SlowStartThresholdGet(self)


    def TcpCongestionAvoidanceAlgorithmSet(self, inValue):
        """

        Selects the used TCP Congestion Avoidance Algorithm (TCAA).

        This must be selected before requesting the page, because for some algorithms,
        the congestion avoidance support is negotiated a the beginning of the TCP
        session.

        :param algorithm: Congestion Avoidance Algorithm to configure.
                          Possible values are:

                          - none
                          - sack
                          - newreno
                          - sack-with-cubic
                          - newreno-with-cubic

        Default value: None

        :raises: :exc:`.ConfigError` Invalid TCP congestion avoidance algorithm: When
                 the value could not be interpreted as a valid TCAA

        Example
        Configure NewReno as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.NewReno)


        Configure Sack as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.Sack)


        Configure None as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.No_Algorithm)


        """
        return _byteblower.HTTPClient_TcpCongestionAvoidanceAlgorithmSet(self, inValue)


    def TcpCongestionAvoidanceAlgorithmGet(self):
        """

        Gets the current configured TCP Congestion Avoidance Algorithm.

        :return: current Congestion Avoidance Algorithm.
                 Possible values are:

                 - none
                 - sack
                 - newreno
                 - sack-with-cubic
                 - newreno-with-cubic

        Default value: None

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.TcpCongestionAvoidanceAlgorithmGet() == TCPCongestionAvoidanceAlgorithm.NewRenoWithCubic)

        """
        return _byteblower.HTTPClient_TcpCongestionAvoidanceAlgorithmGet(self)


    def RequestInitialTimeToWaitGet(self):
        """

        Returns the initial time to wait before a scheduled Request starts.

        :return: The initial time to wait before a scheduled request starts.
                 Units are ns

        Default value: 0

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.RequestInitialTimeToWaitGet())

        """
        return _byteblower.HTTPClient_RequestInitialTimeToWaitGet(self)


    def RequestInitialTimeToWaitSet(self, inDelay):
        """

        Sets the initial time to wait before really requesting a page (for a scheduled
        Request).

        This can be used if you want to start different request on different timestamps.

        :param timetowait: Time to wait before the request will be really sent.
                           Units are ns

        Default value: 0

        :raises: python_error: - bad lexical cast: When the value could not be
                 interpreted as a valid time string

        Example

        Initial Time to wait of 60 seconds expressed in nanoseconds

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.RequestInitialTimeToWaitSet(60000000000)


        """
        return _byteblower.HTTPClient_RequestInitialTimeToWaitSet(self, inDelay)


    def HttpSessionInfoGet(self):
        """

        Returns the HttpSessionInfo from this session.

        The HttpSessionInfo contains all the information of the current session. From
        state until the counters of received/transmitted bytes

        :return: :class:`HTTPSessionInfo`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	sessionInfoGet = httpClient.HttpSessionInfoGet()

        """
        return _byteblower.HTTPClient_HttpSessionInfoGet(self)


    def HttpSessionInfoDestroy(self):
        return _byteblower.HTTPClient_HttpSessionInfoDestroy(self)

    def HttpMethodSet(self, *args):
        """

        Configures the HTTPRequest method to be used.

        There are 2 possible values:

        GET
            The HTTP Request method will be a GET.

        PUT
            The HTTP Request method will be a PUT.

        Default value: GET

        :raises: python_error: bad lexical cast: When the value could not be
                 interpreted as a valid HTTPRequestMethod

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.HttpMethodSet(HTTPRequestMethod.Get)



        Configures the HTTPRequest method to be used.

        There are 2 possible values:

        GET
            The HTTP Request method will be a GET.

        PUT
            The HTTP Request method will be a PUT.

        Default value: GET

        :raises: python_error: bad lexical cast: When the value could not be
                 interpreted as a valid HTTPRequestMethod

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.HttpMethodSet(HTTPRequestMethod.Get)


        """
        return _byteblower.HTTPClient_HttpMethodSet(self, *args)


    def HttpMethodGet(self):
        """

        Returns the used HTTPRequest method.

        There are 2 possible values:

        GET
            The HTTP Request method will be a GET.
        PUT
            The HTTP Request method will be a PUT.

        Default value: GET

        :return:  The current selected HTTP request method

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO

        """
        return _byteblower.HTTPClient_HttpMethodGet(self)


    def CaptureEnable(self, inValue=True):
        """

        Enable the capture of the HTTPData.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.CaptureEnable()


        Enable the capture of the HTTPData.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.CaptureEnable()

        """
        return _byteblower.HTTPClient_CaptureEnable(self, inValue)


    def IsCaptureEnabled(self):
        return _byteblower.HTTPClient_IsCaptureEnabled(self)

    def CaptureGet(self):
        """

        Return the captured HTTP Data.

        :return: :class:`CapturedHTTPData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.CaptureGet().DescriptionGet())

        """
        return _byteblower.HTTPClient_CaptureGet(self)


    def CaptureClear(self):
        return _byteblower.HTTPClient_CaptureClear(self)

    def LatencyEnable(self, inValue=True):
        return _byteblower.HTTPClient_LatencyEnable(self, inValue)

    def IsLatencyEnabled(self):
        return _byteblower.HTTPClient_IsLatencyEnabled(self)

    def ClientIdGet(self):
        """

        Returns the unique client ID.

        Each client has a unique ID so that information about the same connection can
        be requested on a HTTP server object. This method returns the unique ClientID
        for this HTTP client.

        :return:  the httpclient unique ID

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.ClientIdGet())

        """
        return _byteblower.HTTPClient_ClientIdGet(self)


    def ServerIdGet(self):
        """

        Returns the unique ByteBlower Server ID.

        :return: str The ByteBlower server unique ID.

        Each ByteBlower server has a unique ID. This identifier stays persistant over
        the lifetime of the ByteBlowerServers (changed when rebooted).  This serverId
        together with the clientId identifies a HTTPConnection. By adding those 2 id's
        together it is unlikely that 2 httpclients each running on a different server
        end up with the same connection ID.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.ServerIdGet())

        """
        return _byteblower.HTTPClient_ServerIdGet(self)


    def ServerClientIdGet(self):
        """

        This method returns the combination of the server Id ( aka ByteBlower Server Id ) and client Id.

        This returns a combination of the ServerId and the Client Id. This combination
        will identify a HTTP connection. It is this combination of id's you can use to
        request the :class:`HTTPSessionInfo` on the HTTP server
        (:meth:`HTTPServer.HTTPSessionInfoGet`)

        :return:  The combined server- and client Id

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.ServerClientIdGet())

        """
        return _byteblower.HTTPClient_ServerClientIdGet(self)


    def ResultGet(self):
        return _byteblower.HTTPClient_ResultGet(self)

    def ResultHistoryGet(self):
        return _byteblower.HTTPClient_ResultHistoryGet(self)

    def HistorySamplingIntervalDurationGet(self):
        """

        Gets the default Sampling interval for the HTTP Session history.

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.HistorySamplingIntervalDurationGet())


        """
        return _byteblower.HTTPClient_HistorySamplingIntervalDurationGet(self)


    def HistorySamplingBufferLengthGet(self):
        """

        Gets the default Sampling Buffer Length for the HTTP Session history.

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.HistorySamplingBufferLengthGet())

        """
        return _byteblower.HTTPClient_HistorySamplingBufferLengthGet(self)


    def HistorySamplingIntervalDurationSet(self, inDuration):
        """

        Sets the default Sampling interval for the HTTP Session history.

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        This function is only allowed when the HTTP Session is not running yet. When
        the HTTP Session is running, the history must be configured on the HTTP Session
        object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.HistorySamplingIntervalDurationSet(500)

        """
        return _byteblower.HTTPClient_HistorySamplingIntervalDurationSet(self, inDuration)


    def HistorySamplingBufferLengthSet(self, inLength):
        """

        Sets the default Sampling Buffer Length for the HTTP Session history.

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        This function is only allowed when the HTTP Session is not running yet. When
        the HTTP Session is running, the history must be configured on the HTTP Session
        object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.HistorySamplingBufferLengthSet(10)

        """
        return _byteblower.HTTPClient_HistorySamplingBufferLengthSet(self, inLength)


    def TcpHistorySamplingIntervalDurationGet(self):
        """

        Gets the default Sampling interval for the TCP Session history.

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.TcpHistorySamplingIntervalDurationGet())

        """
        return _byteblower.HTTPClient_TcpHistorySamplingIntervalDurationGet(self)


    def TcpHistorySamplingBufferLengthGet(self):
        """

        Gets the default Sampling Buffer Length for the TCP Session history.

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpClient.TcpHistorySamplingBufferLengthGet())

        """
        return _byteblower.HTTPClient_TcpHistorySamplingBufferLengthGet(self)


    def TcpHistorySamplingIntervalDurationSet(self, inDuration):
        """

        Sets the default Sampling interval for the TCP Session history.

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        This function is only allowed when the HTTP Session is not running yet. When
        the HTTP Session is running, the history must be configured on the TCP Session
        object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.TcpHistorySamplingIntervalDurationSet(500)


        """
        return _byteblower.HTTPClient_TcpHistorySamplingIntervalDurationSet(self, inDuration)


    def TcpHistorySamplingBufferLengthSet(self, inLength):
        """

        Sets the default Sampling Buffer Length for the TCP Session history.

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        This function is only allowed when the HTTP Session is not running yet. When
        the HTTP Session is running, the history must be configured on the TCP Session
        object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpClient.TcpHistorySamplingBufferLengthSet(12)

        """
        return _byteblower.HTTPClient_TcpHistorySamplingBufferLengthSet(self, inLength)


    def TypeOfServiceSet(self, value):
        """

        Configures the 'Type Of Service' or 'Traffic Class' used at the IP layer.

        .. versionadded:: 2.5.0

        Both IP headers reserve space to specify the expected quality of service (QOS).
        IPv4 calls this field the 'Type Of Service'. In IPv6 one uses the term
        'Traffic Class'. Despite naming, they are both 8 bits wide. For ease of use,
        the method is generic, it is used for both IPv4 and IPv6 layers. The
        implementaion will configure the proper header.

        The input accepts integers from 0 up to 255. This value will be directly used
        in byte-sized field at the IP layer. No additional coding is performed.

        This method can be called solely during the configuration phase,thus before the
        parent ByteBlower port is started. Invoking the method at other moments will
        result in error.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.TypeOfServiceSet(16)

        """
        return _byteblower.HTTPClient_TypeOfServiceSet(self, value)


    def TypeOfServiceGet(self):
        """

        Retrieves the 'Type Of Service' or 'Traffic Class' configuration of the IP layer.

        .. versionadded:: 2.5.0

        Both IP headers reserve space to for an the expected quality of service (QOS)
        field. In IPv4 this field is called the 'Type Of Service'. IPv6 uses the term
        'Traffic Class'. Despite naming, they are both 8 bits wide. For ease of use,
        the getter is generic, it is used for both IPv4 and IPv6 layers.

        This method returns a number from 0 up to 255. This value represents the the
        byte used at the IP layer.

        :return: The byte value of the 'Type Of Service' or 'Traffic Class' field.
                 The default value is 0.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	type = httpClient.TypeOfServiceGet()

        """
        return _byteblower.HTTPClient_TypeOfServiceGet(self)


    def FlowLabelSet(self, value):
        """

        Configures the flow label for IPv6 flows.

        .. versionadded:: 2.7.0

        This feature only affects IPv6 flows. It is ignored for IPv4 flows.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpClient.FlowLabelSet(1234)

        """
        return _byteblower.HTTPClient_FlowLabelSet(self, value)


    def FlowLabelGet(self):
        """

        Returns the configured "Flow Label" for IPv6 flows.

        .. versionadded:: 2.7.0

        This feature only affects IPv6 flows. It is ignored for IPv4 flows.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpClient.FlowLabelGet())

        """
        return _byteblower.HTTPClient_FlowLabelGet(self)

HTTPClient_swigregister = _byteblower.HTTPClient_swigregister
HTTPClient_swigregister(HTTPClient)


def ConvertRequestStartTypeToString(inRequestStartType):
    return _byteblower.ConvertRequestStartTypeToString(inRequestStartType)
ConvertRequestStartTypeToString = _byteblower.ConvertRequestStartTypeToString

def ParseRequestStartType(inStr):
    return _byteblower.ParseRequestStartType(inStr)
ParseRequestStartType = _byteblower.ParseRequestStartType
class HTTPClientMobile(AbstractObject):
    """

    HTTP client application that may schedule HTTP requests to the HTTP server
    application.

    .. versionadded:: 2.6.0

    Using this class, you can simulate TCP (Transmission Control Protocol) traffic
    The TCP is simulated by a HTML request to the HTTPServer. This is the HttpClient
    that will perform the GET or the PUT. This request can be sent to the
    :class:`HTTPServer` object

    Example

    .. code-block:: python
       :caption: Standard usage of the HTTPClient for WirelessEndpoints

       http_client = wireless_endpoint.ProtocolHttpClientAdd()

       # configure the HTTP server to talk with
       http_client.RemoteAddressSet('10.4.8.2')
       http_client.RemotePortSet(8080)

       # we want a session of 10 seconds
       nanoseconds_per_second = 1 * 1000 * 1000 * 1000
       http_client.RequestDurationSet(10 * nanoseconds_per_second)

       # we do not want to start immediately
       http_client.RequestInitialTimeToWaitSet(1 * nanoseconds_per_second)

       # we want the client to restart if the connection is broken
       # e.g. when the access point restarts
       http_client.RestartEnable(True)

       # start the wireless endpoint 
       wireless_endpoint.Prepare()
       wireless_endpoint.Start()

    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPClientMobile, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPClientMobile, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RequestStatusGet(self):
        return _byteblower.HTTPClientMobile_RequestStatusGet(self)

    def ErrorMessageGet(self):
        return _byteblower.HTTPClientMobile_ErrorMessageGet(self)

    def RequestDurationSet(self, inDurationNs):
        """

        Method which will configure a page to send out an HTTP Request to transmit data
        during a certain time.

        A HTTP Request page will be configured to request to send data, during a
        certain time, on a ByteBlower HTTP server.

        This will prepare a nice TCP traffic test with data transferred over the
        network until the requested duration has passed.

        .. note:: The HTTP Method that is used for the Request can be configured using
                  :meth:`HttpMethodSet`


        .. note:: The generated HTTP Request URI format is specific for a ByteBlower
                  HTTP Server.

        :param requestDuration: The duration of data traffic to send the HTTP Request
                                for.
        :type requestDuration: int

        :raies: python_error: bad lexical cast: When the value could not be interpreted
                as a valid time string

        Example

        .. code-block:: python
           :emphasize-lines: 4
           :caption: Request a data transfer for 3 seconds.

           nanoseconds_per_second = 1000 * 1000 * 1000

           http_client.RequestDurationSet(3 * nanoseconds_per_second)

        """
        return _byteblower.HTTPClientMobile_RequestDurationSet(self, inDurationNs)


    def RequestDurationGet(self):
        """

        Method which will return the configured HTTP Request duration.

        A HTTP Request page will be configured to request to send data, during a
        certain time, on a ByteBlower HTTP server.

        :return: The HTTP request duration.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Prints the configured request duration

           print(http_client.RequestDurationGet())


        """
        return _byteblower.HTTPClientMobile_RequestDurationGet(self)


    def LocalPortSet(self, inPort):
        """

        Configure the TCP port for the client to use.

        This method will set the TCP port for the client.

        :param port: TCP port on the client will use to communicate with the HTTP 
                     server. Valid range: 1-65535

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        :raises: ByteBlower.Exception.InvalidConfig - when the value is not between 1
                 and 65535

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Set the local TCP port to 20000

           http_client.LocalPortSet(20000)

        """
        return _byteblower.HTTPClientMobile_LocalPortSet(self, inPort)


    def LocalPortGet(self):
        """

        Returns the TCP the HTTPClientMobile will use to send its HTTPRequest.

        :return: The TCP port the client uses.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.LocalPortGet())

        """
        return _byteblower.HTTPClientMobile_LocalPortGet(self)


    def RemoteAddressSet(self, inAddress):
        """

        Configure the destination address.

        Method to configure the address of the HTTP server which this client will try
        to contact.

        .. note:: Be aware that only addresses are used, no DNS is supported at this
                  moment.

        :param address: IP address of the HTTP server this client will use.
        :type address: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client.RemoteAddressSet('192.168.0.4')

        """
        return _byteblower.HTTPClientMobile_RemoteAddressSet(self, inAddress)


    def RemoteAddressGet(self):
        """

        Return the configured destination address.

        :return: destination address
        :rtype: string

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.RemoteAddressGet())

        """
        return _byteblower.HTTPClientMobile_RemoteAddressGet(self)


    def RemotePortSet(self, inRemotePort):
        """

        Configure the TCP port which the client will use as destination port.

        This method is used to configure the TCP port of the server which the client
        will try to contact.

        :param port:  TCP port of the HTTP server which the client will try to contact.
        :type port: int

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        raises: ByteBlower.Exception.InvalidConfig - when the value is not between 1
                and 65535

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Set the remote port to port 80.

           http_client.RemotePortSet(80)

        """
        return _byteblower.HTTPClientMobile_RemotePortSet(self, inRemotePort)


    def RemotePortGet(self):
        """

        Returns the configured destination port.

        This method returns the current configured TCP port of the HTTP server which
        this client will try to contact.

        :return: the remote (destination) tcp port
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.RemotePortGet())

        """
        return _byteblower.HTTPClientMobile_RemotePortGet(self)


    def HttpSessionInfoGet(self):
        return _byteblower.HTTPClientMobile_HttpSessionInfoGet(self)

    def HttpSessionInfoDestroy(self):
        return _byteblower.HTTPClientMobile_HttpSessionInfoDestroy(self)

    def RequestInitialTimeToWaitGet(self):
        """

        Returns the initial time to wait before a scheduled Request starts.

        :return: The initial time in nanoseconds to wait before a scheduled request 
                 starts. (default 0)
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.RequestInitialTimeToWaitGet())

        """
        return _byteblower.HTTPClientMobile_RequestInitialTimeToWaitGet(self)


    def RequestInitialTimeToWaitSet(self, inDelay):
        """

        Sets the initial time to wait before really requesting a page (for a scheduled
        Request).

        This can be used if you want to start different request on different
        timestamps.

        :param timetowait: Time in nanoseconds to wait before the request will be really 
                           sent. (default: 0)
        :type timetowait: int

        .. todo:: figure out what the exception will be.

        :raises: python_error: bad lexical cast: When the value could not be
                 interpreted as a valid time string

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client.RequestInitialTimeToWaitSet(1000000000)

        """
        return _byteblower.HTTPClientMobile_RequestInitialTimeToWaitSet(self, inDelay)


    def HttpMethodSet(self, *args):
        """

        Configures the HTTPRequest method to be used.

        .. note:: Only 2 HTTP methods are supported for now:

                  - :attr:`HTTPRequestMethod.Get`: (default) starts a download
                  - :attr:`HTTPRequestMethod.Put`: starts an upload

        :param method: The method to be used.               
        :type method: :class:`HTTPRequestMethod`

        :raises: python_error: bad lexical cast: When the value could not be
                 interpreted as a valid HTTPRequestMethod

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client.HttpMethodSet(HTTPRequestMethod.Put)


        Configures the HTTPRequest method to be used.

        .. note:: Only 2 HTTP methods are supported for now:

                  - :attr:`HTTPRequestMethod.Get`: (default) starts a download
                  - :attr:`HTTPRequestMethod.Put`: starts an upload

        :param method: The method to be used.               
        :type method: :class:`HTTPRequestMethod`

        :raises: python_error: bad lexical cast: When the value could not be
                 interpreted as a valid HTTPRequestMethod

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client.HttpMethodSet(HTTPRequestMethod.Put)

        """
        return _byteblower.HTTPClientMobile_HttpMethodSet(self, *args)


    def HttpMethodGet(self):
        """

        Returns the used HTTPRequest method.

        Default value: :attr:`.HTTPRequestMethod.Get`

        :return: The current selected HTTP request method
        :rtype: :class:`HTTPRequestMethod`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.HttpMethodGet() == HTTPRequestMethod.Get)

        """
        return _byteblower.HTTPClientMobile_HttpMethodGet(self)


    def LatencyEnable(self, inValue=True):
        return _byteblower.HTTPClientMobile_LatencyEnable(self, inValue)

    def RequestRateLimitSet(self, inRateLimitBytesps):
        """

        Method which will limit the rate of the HTTP traffic to a certain amount..

        :param ratelimit: The rate limit, in bytes per second.  0 disables the rate limit.
        :type ratelimit: int

        Example

        .. code-block:: python
           :emphasize-lines: 4
           :caption: Set the ratelimit to 10 megabytes per second

           bytes_per_megabyte = 1000 * 1000

           http_client = wireless_endpoint.ProtocolHttpClientAdd()
           http_client.RequestRateLimitSet(10 * bytes_per_megabyte)

        Example

        Disable rate limit

        .. code-block:: python
           :emphasize-lines: 1

           http_client.RequestRateLimitSet(0)

        """
        return _byteblower.HTTPClientMobile_RequestRateLimitSet(self, inRateLimitBytesps)


    def RequestRateLimitGet(self):
        """

        Method which will return the configured rate-limit of the HTTP traffic.

        :return: rateLimit The rate limit, in bytes per second.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Get the configured rate limit in bytes per second

           print(http_client.RequestRateLimitGet())

        """
        return _byteblower.HTTPClientMobile_RequestRateLimitGet(self)


    def RestartIsEnabled(self):
        """

        Method which will return whether or not the HTTP Client will restart the
        session when the connection fails.

        :return: True if enabled, false otherwise.
        :rtype: bool

        .. versionadded:: 2.10.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.RestartIsEnabled())

        """
        return _byteblower.HTTPClientMobile_RestartIsEnabled(self)


    def RestartEnable(self, arg2):
        """

        Let the HTTP Client try to restart the session when a connection fails.

        The HTTP Client will setup a new HTTP connection when the connection is lost for
        some reason. Possible reasons are loss of the network connection on the device,
        loss of the TCP connection due to a rebooting device somewhere in the network...

        To distinguish the different sessions, the ClientServerId is used as a prefix.
        The connection attempt number is appended to the ID

        .. versionadded:: 2.10.0

        :param enable: True to enable, False to disable.
        :type enable: bool

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: Enable the restart behaviour

           http_client.RestartEnable(True)

        """
        return _byteblower.HTTPClientMobile_RestartEnable(self, arg2)


    def ClientIdGet(self):
        """

        Returns the unique client ID.

        Each client has a unique ID so that information about the same connection can
        be requested on a HTTP server object. This method returns the unique ClientID
        for this HTTP client.

        :return: the HTTPClientMobile unique ID
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.ClientId())

        """
        return _byteblower.HTTPClientMobile_ClientIdGet(self)


    def ServerIdGet(self):
        """

        Returns the unique ByteBlower Server ID.

        :return: The ByteBlower server unique ID.
        :rtype: str

        Each ByteBlower server has a unique ID. This identifier stays persistent over
        the lifetime of the ByteBlowerServers ( changed when rebooted ). This serverId
        together with the clientId identifies a HTTPConnection. By adding those 2 id's
        together it is unlikely that 2 HTTPClientMobiles each running on a different
        server end up with the same connection ID.

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: prints the Server ID

           print(http_client.ServerIdGet())

        """
        return _byteblower.HTTPClientMobile_ServerIdGet(self)


    def ServerClientIdGet(self):
        """

        This method returns the combination of the server Id (aka ByteBlower Server Id)
        and client Id.

        This returns a combination of the ServerId and the Client Id. This combination
        will identify a HTTP connection. It is this combination of id's you can use to
        request the :class:`HTTPSessionInfo` on the HTTP server :class:`HTTPServer`

        :return: The combined server- and client Id
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.ServerClientIdGet())

        """
        return _byteblower.HTTPClientMobile_ServerClientIdGet(self)


    def ResultGet(self):
        return _byteblower.HTTPClientMobile_ResultGet(self)

    def ResultHistoryGet(self):
        return _byteblower.HTTPClientMobile_ResultHistoryGet(self)

    def HistorySamplingIntervalDurationGet(self):
        return _byteblower.HTTPClientMobile_HistorySamplingIntervalDurationGet(self)

    def HistorySamplingIntervalDurationSet(self, inDuration):
        return _byteblower.HTTPClientMobile_HistorySamplingIntervalDurationSet(self, inDuration)

    def TypeOfServiceSet(self, value):
        """

        Configures the 'Type Of Service' or 'Traffic Class' used at the IP layer.

        .. versionadded:: 2.5.0

        This method sets the :term:`Type of Service` for an IPv4 connection or the
        :term:`Traffic Class` for an IPv6 connection. Despite naming, they are both 
        8 bits wide. For ease of use, the method is generic, it is used for both IPv4
        and IPv6 layers. The implementation will configure the proper header.

        The input accepts integers from 0 up to 255. This value will be directly used
        in byte-sized field at the IP layer. No additional coding is performed.

        This method can be called solely during the configuration phase, thus before 
        the parent ByteBlower port is started. Invoking the method at other moments 
        will result in error.

        :param tos: The literal value to be set (0-255)
        :type tos: integer

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client.TypeOfServiceSet(8)

        """
        return _byteblower.HTTPClientMobile_TypeOfServiceSet(self, value)


    def TypeOfServiceGet(self):
        """

        Retrieves the 'Type Of Service' or 'Traffic Class' configuration of the IP
        layer.

        .. versionadded:: 2.5.0

        Both IP headers reserve space to for an the expected quality of service(QOS)
        field. In IPv4 this field is called the 'Type Of Service'. IPv6 uses the term
        'Traffic Class'. Despite naming, they are both 8 bits wide. For ease of use,
        the getter is generic, it is used for both IPv4 and IPv6 layers.

        This method returns a number from 0 up to 255. This value represents the the
        byte used at the IP layer.

        :return: The byte value of the 'Type Of Service' or 'Traffic Class' field.
                 The default value is 0.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(http_client.TypeOfServiceGet())

        """
        return _byteblower.HTTPClientMobile_TypeOfServiceGet(self)

HTTPClientMobile_swigregister = _byteblower.HTTPClientMobile_swigregister
HTTPClientMobile_swigregister(HTTPClientMobile)

HTTPServerStatus_Running = _byteblower.HTTPServerStatus_Running
HTTPServerStatus_Stopped = _byteblower.HTTPServerStatus_Stopped
HTTPServerStatus_Error = _byteblower.HTTPServerStatus_Error
HTTPServerStatus_Unknown = _byteblower.HTTPServerStatus_Unknown
class HTTPServer(AbstractObject):
    """

    HTTP server application that handles incoming HTTP requests with the correct
    URL format by returning a document of the appropriate size.

    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPServer, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPServer, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ByteBlowerServerGet(self):
        return _byteblower.HTTPServer_ByteBlowerServerGet(self)

    def ByteBlowerPortGet(self):
        return _byteblower.HTTPServer_ByteBlowerPortGet(self)

    def Start(self):
        """

        Starts the HTTP server on the configured port with the configured
        configuration.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpServer.Start()


        """
        return _byteblower.HTTPServer_Start(self)


    def Stop(self):
        """

        Stops the HTTP server.

        Running sessions will be stopped and new requests will be ignored.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpServer.Stop()



        """
        return _byteblower.HTTPServer_Stop(self)


    def StatusGet(self):
        """

        Returns the HTTP server status.

        :return: :class:`.HTTPServerStatus`

        Example

        Before starting the HTTP server:  {stopped} After starting the HTTP server:
        {running}

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpServer.StatusGet() == HTTPRequestStatus.Connecting)


        """
        return _byteblower.HTTPServer_StatusGet(self)


    def PortSet(self, inPort):
        """

        Configures the TCP port on which the HTTP server will listen.

        :param port: The TCP port on which the HTTP server will listen for incoming
                     requests.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        :raises: ByteBlower.Exception.InvalidConfig - when the value is not between 1
                 and 65535

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpServer.PortSet(80)


        """
        return _byteblower.HTTPServer_PortSet(self, inPort)


    def PortGet(self):
        """

        Returns the configured TCP port for the HTTP server.

        :return: The configured TCP Port

        Example

        .. code-block:: python
           :emphasize-lines: 3

           print(httpServer.PortGet())


        """
        return _byteblower.HTTPServer_PortGet(self)


    def HttpSessionInfoGet(self, inServerClientId):
        """

        Returns the :class:`.HTTPSessionInfo` from this session.

        The HttpSessionInfo contains all the information of the current session. From
        state until the counters of received/transmitted bytes

        :param clientID: ID of the client which has connected with this server. This ID
                         can be retrieved from the :meth:`HTTPClient.ServerClientIdGet`
                         method on the HTTPClient.

        .. warning:: call :meth:`HasSession` to verify that the client session exists,
                     before calling this function. Otherwise, an exception may be
                     thrown.

        :return: :class:`.HTTPSessionInfo`

        :raises: :exc:`.ConfigError` when the HTTP Server did not setup the given HTTP
                 session (e.g. when the TCP connection failed)

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpServer.HttpSessionInfoGet())


        """
        return _byteblower.HTTPServer_HttpSessionInfoGet(self, inServerClientId)


    def HasSession(self, inServerClientId):
        """

        Returns whether or not a client session exists with the given
        server-client-identifier.

        :return: True when we have a Session, False if we don't

        See also: :meth:`.HTTPClient.ServerClientIdGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpServer.HasSession('BBhttpS2502398654/BBhttpC1146349503' ))



        """
        return _byteblower.HTTPServer_HasSession(self, inServerClientId)


    def ResultGet(self, inServerClientId):
        return _byteblower.HTTPServer_ResultGet(self, inServerClientId)

    def ResultHistoryGet(self, inServerClientId):
        return _byteblower.HTTPServer_ResultHistoryGet(self, inServerClientId)

    def HttpSessionInfoDestroy(self, inServerClientId):
        return _byteblower.HTTPServer_HttpSessionInfoDestroy(self, inServerClientId)

    def MaximumSegmentSizeSet(self, inValue):
        """

        Sets the TCP maximum segment size.

        This option specifies an upper bound on the TCP segment size.

        :param size: Maximum segment size. Should be between 1 and 65535.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpServer.MaximumSegmentSizeSet(65525)


        """
        return _byteblower.HTTPServer_MaximumSegmentSizeSet(self, inValue)


    def MaximumSegmentSizeGet(self):
        """

        Returns the configured TCP maximum segment size.

        The default value is 65535.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpServer.MaximumSegmentSizeGet())



        """
        return _byteblower.HTTPServer_MaximumSegmentSizeGet(self)


    def ReceiveWindowInitialSizeSet(self, inValue):
        """

        Sets the initial receive window for the server.

        Small windowsizes can decrease the performance of a TCP session. Please use a
        good size for your configuration and network setup.

        :param windowsize: New value of the initial receive window.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpServer.ReceiveWindowInitialSizeSet(65535)



        """
        return _byteblower.HTTPServer_ReceiveWindowInitialSizeSet(self, inValue)


    def ReceiveWindowInitialSizeGet(self):
        """

        Gets the initial receive window for the server.

        Small windowsizes can decrease the performance of a TCP session. Please use a
        good size for your configuration and network setup.

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 Integer

        Example

        .. code-block:: python
           :emphasize-lines: 3

           print(httpServer.ReceiveWindowInitialSizeGet())

        """
        return _byteblower.HTTPServer_ReceiveWindowInitialSizeGet(self)


    def ReceiveWindowScalingIsEnabled(self):
        """

        Returns if window scaling is enabled or not.

        Windowscaling allows windowsizes to grow further than 65,536 bytes. For high
        speed or high latency links, window scaling should be enabled for a good
        throughput.

        :return: True: Window scaling is enabled, False when disabled


        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpServer.ReceiveWindowScalingIsEnabled())


        """
        return _byteblower.HTTPServer_ReceiveWindowScalingIsEnabled(self)


    def ReceiveWindowScalingEnable(self, inWindowScaling):
        """

        Enables of disables windowscaling.

        Windowscaling allows windowsizes to grow further than 65,536 bytes. For high
        speed or high latency links, window scaling should be enabled for a good
        throughput.

        :param scaling: Boolean which will enable ( true ) or disable ( false )
                        windowscaling.

        :raises: ByteBlower.Exception.InvalidValue - when the value is not true or
                 false

        Example

        To enable window scaling  or  To disable window scaling  or

        .. code-block:: python
           :emphasize-lines: 1

        	httppServer.ReceiveWindowScalingEnable(True)



        """
        return _byteblower.HTTPServer_ReceiveWindowScalingEnable(self, inWindowScaling)


    def SessionStorageIsEnabled(self):
        """


        """
        return _byteblower.HTTPServer_SessionStorageIsEnabled(self)


    def SessionStorageEnable(self, value):
        """


        """
        return _byteblower.HTTPServer_SessionStorageEnable(self, value)


    def ReceiveWindowScalingValueGet(self):
        """

        Returns the current receive window scale.

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in
        :rfc:`1323`.

        :return: current receive window scale

        Default value: 3

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpServer.ReceiveWindowScalingValueGet())


        """
        return _byteblower.HTTPServer_ReceiveWindowScalingValueGet(self)


    def ReceiveWindowScalingValueSet(self, inRcvWindowScale):
        """

        Configures the window scale which will be used for new clients.

        This must be done before requesting a page from a client, because this option
        is negotiated at the beginning of the TCP session.

        The TCP window scale option is an option to increase the receive window size
        allowed in Transmission Control Protocol above its former maximum value of
        65,535 bytes. This TCP option, along with several others, is defined in
        IETF rfc:`1323`.

        :param scale: Integer (0-8), which is used for bitwise shifting.

        Default value: 3

        :raises: ByteBlower.Exception.InvalidValue.Integer - when the value is not an
                 integer

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpServer.ReceiveWindowScalingValueSet(7)



        """
        return _byteblower.HTTPServer_ReceiveWindowScalingValueSet(self, inRcvWindowScale)


    def SlowStartThresholdSet(self, inValue):
        """

        Set the initial slow-start threshold value used by TCP.

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you find
        that TCP takes a long time to reach peak throughput. See :rfc:`5681`
        "TCP Congestion Control" for more information on this topic.

        :param ssthresh: New value for the slow-start threshold

        :raises: ByteBlower.Exception.InvalidValue - when the value is not a positive
                 integer

        Default value: 65535

        Example

        To set slow-start threshold to 1000000

        .. code-block:: python
           :emphasize-lines: 1

        	httpServer.SlowStartThresholdSet(1000000)



        """
        return _byteblower.HTTPServer_SlowStartThresholdSet(self, inValue)


    def SlowStartThresholdGet(self):
        """

        Returns the initial slow-start threshold value used by TCP.

        The slow-start threshold indicates when the slow-start phase ends and the
        congestion avoidance phase starts. Consider increasing this value if you find
        that TCP takes a long time to reach peak throughput. See :rfc:`5681`
        "TCP Congestion Control" for more information on this topic.

        :return: Slow-start threshold

        Default value: 65535

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpServer.SlowStartThresholdGet())



        """
        return _byteblower.HTTPServer_SlowStartThresholdGet(self)


    def TcpCongestionAvoidanceAlgorithmSet(self, inValue):
        """

        Selects the TCP Congestion Avoidance Algorithm.

        Selects the TCP Congestion Avoidance Algorithm which will be used for new
        clients. This must be selected before requesting a page from a client, because
        for some algorithms, the congestion avoidance support is negotiated a the
        beginning of the TCP session.

        :param algorithm: Congestion Avoidance Algorithm to configure.

        Possible values are:
        - none
        - sack
        - newreno
        - sack-with-cubic
        - newreno-with-cubic

        Default value: None

        :raises: python_error: Failed to parse enumerator: When the value could not be
                 interpreted as a valid TCAA

        Example

        Configure NewReno as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

           httpServer.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.NewReno)

        Configure Sack as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

           httpServer.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.Sack)

        Configure None as congestionAvoidance Algorithm

        .. code-block:: python
           :emphasize-lines: 1

           httpServer.TcpCongestionAvoidanceAlgorithmSet(TCPCongestionAvoidanceAlgorithm.No_Algorithm)



        """
        return _byteblower.HTTPServer_TcpCongestionAvoidanceAlgorithmSet(self, inValue)


    def TcpCongestionAvoidanceAlgorithmGet(self):
        """

        Gets the current configured TCP Congestion Avoidance Algorithm for new clients.

        :return: current Congestion Avoidance Algorithm.
        :rtype: :class:`.TCPCongestionAvoidanceAlgorithm`

        Default value: :attr:`.TCPCongestionAvoidanceAlgorithm.No_Algorithm`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpServer.TcpCongestionAvoidanceAlgorithmGet() == TCPCongestionAvoidanceAlgorithm.NewRenoWithCubic)



        """
        return _byteblower.HTTPServer_TcpCongestionAvoidanceAlgorithmGet(self)


    def ClientIdentifiersGet(self):
        """

        Returns the list of known identifiers of HTTP clients which made a connection
        to this server.

        :return: List of Client Identifiers which have connected this server.

        See also: :meth:`HTTPClient.ServerClientIdGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpServer.ClientIdentifiersGet()[0])



        """
        return _byteblower.HTTPServer_ClientIdentifiersGet(self)


    def HistorySamplingIntervalDurationGet(self):
        """

        Gets the default Sampling interval for the HTTP Session history.

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpServer.HistorySamplingIntervalDurationGet())


        """
        return _byteblower.HTTPServer_HistorySamplingIntervalDurationGet(self)


    def HistorySamplingBufferLengthGet(self):
        """

        Gets the default Sampling Buffer Length for the HTTP Session history.

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(httpServer.HistorySamplingBufferLengthGet())



        """
        return _byteblower.HTTPServer_HistorySamplingBufferLengthGet(self)


    def HistorySamplingIntervalDurationSet(self, inDuration):
        """

        Sets the default Sampling interval for the HTTP Session history.

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        .. note:: This setting will only be used on new HTTP sessions. When the session
                  history settings must be changed, the settings must be set on the
                  HTTP Session object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpServer.HistorySamplingIntervalDurationSet(500)


        """
        return _byteblower.HTTPServer_HistorySamplingIntervalDurationSet(self, inDuration)


    def HistorySamplingBufferLengthSet(self, inLength):
        """

        Sets the default Sampling Buffer Length for the HTTP Session history.

        The history on the HTTP Session History object can be configured when the
        session is started. This method allows to configure the HTTP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        .. note:: This setting will only be used on new HTTP sessions. When the session
                  history settings must be changed, the settings must be set on the
                  HTTP Session object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpServer.HistorySamplingBufferLengthSet(10)


        """
        return _byteblower.HTTPServer_HistorySamplingBufferLengthSet(self, inLength)


    def TcpHistorySamplingIntervalDurationGet(self):
        """

        Gets the default Sampling interval for the TCP Session history.

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(httpServer.TcpHistorySamplingIntervalDurationGet())


        """
        return _byteblower.HTTPServer_TcpHistorySamplingIntervalDurationGet(self)


    def TcpHistorySamplingBufferLengthGet(self):
        """

        Gets the default Sampling Buffer Length for the TCP Session history.

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(httpServer.TcpHistorySamplingBufferLengthGet())

        """
        return _byteblower.HTTPServer_TcpHistorySamplingBufferLengthGet(self)


    def TcpHistorySamplingIntervalDurationSet(self, inDuration):
        """

        Sets the default Sampling interval for the TCP Session history.

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        .. note:: This setting will only be used on new HTTP sessions. When the session
                  history settings must be changed, the settings must be set on the
                  HTTP Session object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            httpServer.TcpHistorySamplingIntervalDurationSet(500)



        """
        return _byteblower.HTTPServer_TcpHistorySamplingIntervalDurationSet(self, inDuration)


    def TcpHistorySamplingBufferLengthSet(self, inLength):
        """

        Sets the default Sampling Buffer Length for the TCP Session history.

        The history on the TCP Session History object can be configured when the
        session is started. This method allows to configure the TCP Session History
        before the request is started and has thus the advantage not to invalidate
        previous history items.

        .. note:: This setting will only be used on new HTTP sessions. When the session
                  history settings must be changed, the settings must be set on the
                  HTTP Session object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	httpServer.TcpHistorySamplingBufferLengthSet(10)



        """
        return _byteblower.HTTPServer_TcpHistorySamplingBufferLengthSet(self, inLength)

HTTPServer_swigregister = _byteblower.HTTPServer_swigregister
HTTPServer_swigregister(HTTPServer)

class ICMPEchoSession(AbstractObject):
    """

    Session for handling ICMP Echo Requests and Replies.

    This Session uses the ICMP protocol for receiving and / or transmitting
    ICMP Echo Request and / or Replies

    Some use cases for this session are:

    - DUT validation

      - Verify Echo Request / Replies are either or not filtered out

      - Verify public / private connectivity for Routers, NAT gateways, ...

    - DUT stability

      - Verify Echo Replies are received during some stability tests


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICMPEchoSession, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ICMPEchoSession, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RemoteAddressSet(self, inIPAddress):
        """

        Configure the destination IPv4 address.

        .. versionadded:: 2.3.0

        This method configures the destination IPv4 address for our ICMP Echo packets

        The destination IPv4 address defines to where the ICMP Echo Requests will be
        sent or from where ICMP Echo Responses are / were received.

        :param ipv4Address: The Destination IPv4 Address for this session.

        :raises: <python_error> - Invalid IPv4 address: When the value could not
                 be interpreted as an IPv4 address

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.RemoteAddressSet('10.8.254.69')



        """
        return _byteblower.ICMPEchoSession_RemoteAddressSet(self, inIPAddress)


    def RemoteAddressGet(self):
        """

        Returns the ICMP Echo Request destination IPv4 address.

        .. versionadded:: 2.3.0

        This method returns the IPv4 address which has been configured with
        :meth:`RemoteAddressSet`

        :return: The Destination IPv4 address for this session.

        :raises: ByteBlower.Session - When the destination IPv4 address was not yet
                 configured

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.RemoteAddressGet())



        """
        return _byteblower.ICMPEchoSession_RemoteAddressGet(self)


    def TtlSet(self, inTTL):
        """

        Configures the IPv4 time-to-live.

        This method configures the IPv4 TTL (time-to-live) for the ICMP Echo packets.

        The TTL defines the maximum lifetime of an IPv4 (in this case ICMP) packet in
        the network. Every router that the packet passes decrements the TTL field in
        the packet. When the TTL reaches value 0 before it is delivered at its
        destination, it will be dropped. The router will respond to the sender with an
        ICMP packet type 11 (Time Exceeded).

        .. note:: The IPv4 TTL applies for all ICMP Echo packets (Requests and Responses)

        .. note:: The TTL only applies for this session, other sessions in this
                  `class:`.ICMPProtocol` are not affected.

        :param ttl: The IPv4 TTL you wish to configure. (Valid range: 0 to 255.)
                    Default: 255

        :raises: <python_error> - bad lexical cast: When the value could not be
                                  interpreted as a valid integer
        :raises: ByteBlower.Protocol.InvalidValue - When the value is out of range

        .. versionadded:: 1.8.18

        Example

        Configure a TTL of 127 for the ICMP Request and Reply packets

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.TtlSet(127)


        """
        return _byteblower.ICMPEchoSession_TtlSet(self, inTTL)


    def TtlGet(self):
        """

        Returns the current IPv4 time-to-live.

        This method returns the current IPv4 TTL (time-to-live) for the
        ICMP Echo packets.

        The TTL defines the maximum lifetime of an IPv4 (in this case ICMP) packet in
        the network. Every router that the packet passes decrements the TTL field in
        the packet. When the TTL reaches value 0 before it is delivered at its
        destination, it will be dropped. The router will respond to the sender with an
        ICMP packet type 11 (Time Exceeded).

        .. note:: The IPv4 TTL applies for all ICMP Echo packets (Requests and Responses)

        Default value: 255

        :return: IPv4 time-to-live for all ICMP Echo packets

        .. versionadded:: 1.8.18

        """
        return _byteblower.ICMPEchoSession_TtlGet(self)


    def TypeOfServiceSet(self, inTOS):
        """

        Configures the 'Type Of Service' used at the IP layer.

        .. versionadded:: 2.5.0

        The input accepts integers from 0 up to 255. This value will be directly used
        in byte-sized field at the IP layer. No additional coding is performed.

        This method can be called solely during the configuration phase, thus before
        the parent ByteBlower port is started. Invoking the method at other moments
        will result in error.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession.TypeOfServiceSet(16)


        """
        return _byteblower.ICMPEchoSession_TypeOfServiceSet(self, inTOS)


    def TypeOfServiceGet(self):
        """

        Retrieves the 'Type Of Service' configuration of the IP layer.

        .. versionadded:: 2.5.0

        This method returns a number from 0 up to 255. This value represents the the
        byte used at the IP layer.

        :return: The byte value of the 'Type Of Service' or 'Traffic Class' field.
                 The default value is 0.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.TypeOfServiceGet())



        """
        return _byteblower.ICMPEchoSession_TypeOfServiceGet(self)


    def IdentifierGet(self):
        """

        Returns the ICMP Echo Request ICMPID.

        This method returns the ICMP Echo Request ICMPID.
        This is also known as the Application ID

        The Application ID is either generated randomly or is the one that has been
        provided with :meth:`.ICMPProtocol.SessionAdd`

        :return: The ICMP Echo Request ICMP ID for this Session.

        Example

        Returns the (integer) value of the ICMP ID (Application ID)

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.IdentifierGet())



        """
        return _byteblower.ICMPEchoSession_IdentifierGet(self)


    def DataSizeSet(self, inDataSize):
        """

        Configures the data size.

        This method configures the data size of our ICMP Echo Requests

        The data size of our ICMP Echo Requests is the payload size of the packet

        :param dataSize: The ICMP data size you wish to configure.

        The valid range of `dataSize` is:
        (0 to *<port_mdl>*) - *<ICMP_header_size>*.

        Where

        <port_mdl>
            Value of :meth:`.ByteBlowerPort.MDLGet`

        *<ICMP_header_size>*
            Ethernet header size (14) + IPv4 header size (20) + ICMP header size (8)

        Default value: 56

        :raises: <python_error> - bad lexical cast: When the value could not be
                 interpreted as a valid integer
        :raises: ByteBlower.Protocol.InvalidValue - When the value is out of range

        Example

        Configure 92Bytes payload for the ICMP Request packets

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.DataSizeSet(92)


        """
        return _byteblower.ICMPEchoSession_DataSizeSet(self, inDataSize)


    def DataSizeGet(self):
        """

        Returns the data size.

        This method returns the data size of our ICMP Echo Requests

        The data size of our ICMP Echo Requests is the payload size of the packet

        Default value: 56

        :return: ICMP Echo data size

        Example

        The ICMP session has been configure to add 76Bytes payload in the ICMP Request packets

        .. code-block:: python
           :emphasize-lines: 2

        	print(icmpEchoSession.DataSizeGet())


        """
        return _byteblower.ICMPEchoSession_DataSizeGet(self)


    def EchoRequestSend(self):
        """

        Transmit an ICMP Echo Request.

        This method sends one ICMP Echo Request.

        .. note:: This method call is (partially) non-blocking. The call will not
                  return as soon the session is setup and the request is sent or an
                  error occurred (exception is thrown). The call does not wait until
                  an Echo Reply is received.


        .. note:: The Destination IPv4 address must be configured (using
                  :meth:`RemoteAddressSet`) before sending Echo Requests

        :raises: ByteBlower.Session.Unavailable - When the destination IPv4 address was
                 not yet configured
        :raises: ByteBlower.Protocol.Session.CreationFailed - When the destination IPv4
                 address cannot be reached

        """
        return _byteblower.ICMPEchoSession_EchoRequestSend(self)


    def EchoStatsClear(self):
        """

        Resets the ICMP Session statistics.

        .. deprecated:: 2.3.0
                        The recommended approach is to destruct this session and create
                        a new one.

        This method resets the ICMP Session statistics.

        """
        return _byteblower.ICMPEchoSession_EchoStatsClear(self)


    def EchoLoopIntervalSet(self, inTimeNs):
        """

        Configures the Echo Request interval.

        This method configures the interval between subsequent Echo Request packets
        when sending in a loop.

        The interval has a nanosecond resolution. You can provide a time unit for the
        loop interval value.

        The Echo Request Loop can be started using :meth:`EchoLoopStart`

        :param loopInterval: The interval between two ICMP Echo Request packets [ns].
                             Valid range: 0 to *<max_uint64>*[ns]
                             Where *<max_uint64>*  = 0xFFFFFFFFFFFFFFFF = 18446744073709551615
                             (= maximum unsigned 64bit integer)
        :type loopInterval: int

        Default value: 1s

        :raises: <python_error> - Failed to parse time string: When the value could not
                 be interpreted as a valid time string

        Example

        Configure an interval of 50 microseconds (50000 nanoseconds)

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.EchoLoopIntervalSet(50000)

        Configure an interval of 500 milliseconds

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.EchoLoopIntervalSet(500000000)


        Configure an interval of 1.25 milliseconds

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.EchoLoopIntervalSet(1250000)



        """
        return _byteblower.ICMPEchoSession_EchoLoopIntervalSet(self, inTimeNs)


    def EchoLoopIntervalGet(self):
        """

        Returns the Echo Request interval.

        This method returns the interval between subsequent Echo Request packets when
        sending in a loop.

        The Echo Request Loop can be started using :meth:`EchoLoopStart`

        .. note:: The interval is always returned in nanoseconds resolution. No unit is
                  added to the value.

        Default value: 1s

        :return: The interval between two ICMP Echo Request packets [ns]
        :rtype: int

        Example

        The transmit loop is configured with an interval of 625 microseconds

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.EchoLoopIntervalGet())


        """
        return _byteblower.ICMPEchoSession_EchoLoopIntervalGet(self)


    def EchoLoopCountSet(self, inCount):
        """

        Configures the Echo Request count.

        This method configures the number of Echo Requests which will be transmitted
        when sending in a loop.

        The Echo Request Loop can be started using :meth:`EchoLoopStart`

        :param packetCount: The number of ICMP Echo Request packets to transmit

        Default value: infinite

        The actual value is *<max_uint64>* = 0xFFFFFFFFFFFFFFFF = 18446744073709551615)

        :except: <python_error> - bad lexical cast: When the value could not be
                 interpreted as a valid integer

        .. versionadded:: 1.8.18

        Example

        Configure the loop to transmit 100 ICMP Echo Request packets

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.EchoLoopCountSet(100)


        """
        return _byteblower.ICMPEchoSession_EchoLoopCountSet(self, inCount)


    def EchoLoopCountGet(self):
        """

        Returns the Echo Request count.

        This method returns the number of Echo Requests which will be transmitted when
        sending in a loop.

        Default value: infinite
        (*<max_uint64>* = 0xFFFFFFFFFFFFFFFF = 18446744073709551615)

        :return: The number of ICMP Echo Request packets in a loop

        .. versionadded:: 1.8.18

        Example

        The transmit loop is configured to transmit 12345 packets

        .. code-block:: python
           :emphasize-lines: 1

            print(icmpEchoSession.EchoLoopCountGet())



        """
        return _byteblower.ICMPEchoSession_EchoLoopCountGet(self)


    def EchoLoopStart(self):
        """

        Starts sending Echo Requests in a loop.

        This method start sending Echo Requests in a loop.

        The interval between Echo Request can be configured using the method
        :meth:`EchoLoopIntervalSet`

        If a limited number of Echo Request is desired, this can be configured using
        the method :meth:`EchoLoopCountSet`

        .. note:: This method call is (partially) non-blocking. The call will return as
                  soon as the session is started an the loop is running or an error
                  occurred during session initialization.

        .. note:: The Destination IPv4 address must be configured (using
                  :meth:`RemoteAddressSet`) before sending Echo Requests

        :raises: ByteBlower.Session.Unavailable - When the destination IPv4 address
                 was not yet configured
        :raises: ByteBlower.Protocol.Session.CreationFailed - When the destination IPv4
                 address cannot be reached

        """
        return _byteblower.ICMPEchoSession_EchoLoopStart(self)


    def EchoLoopStop(self):
        """

        Stops sending Echo Requests in a loop.

        This method stops sending Echo Requests in a loop. The loop can be started with
        :meth:`EchoLoopStart`

        .. note:: This method does not throw an exception if the loop was not started

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.EchoLoopStop()



        """
        return _byteblower.ICMPEchoSession_EchoLoopStop(self)


    def GetICMPProtocol(self):
        return _byteblower.ICMPEchoSession_GetICMPProtocol(self)

    def SessionInfoGet(self):
        """

        Returns the session information.

        .. versionadded:: 2.3.0

        This method returns the SessionInfo object.

        :return: The session information in an object.
        :rtype: A :class:`ICMPEchoSessionInfo` object

        Example

        The transmit loop is configured to transmit 12345 packets

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.EchoLoopStart()


        """
        return _byteblower.ICMPEchoSession_SessionInfoGet(self)

ICMPEchoSession_swigregister = _byteblower.ICMPEchoSession_swigregister
ICMPEchoSession_swigregister(ICMPEchoSession)

class ICMPEchoSessionInfo(AbstractRefreshableResult):
    """



    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICMPEchoSessionInfo, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ICMPEchoSessionInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TxEchoRequestsGet(self):
        """

        Returns the ICMP Echo requests which were transmitted for the session.

        :return: The number of ICMP Echo requests which were sent during the session

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(icmpEchoSessionInfo.TxEchoRequestsGet())



        """
        return _byteblower.ICMPEchoSessionInfo_TxEchoRequestsGet(self)


    def TxEchoRepliesGet(self):
        """

        Returns the ICMP Echo replies which were transmitted for the session.

        :return: The number of ICMP Echo replies which were sent during the session

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(icmpEchoSessionInfo.TxEchoRepliesGet())



        """
        return _byteblower.ICMPEchoSessionInfo_TxEchoRepliesGet(self)


    def RxEchoRequestsGet(self):
        """

        Returns the ICMP Echo requests which were received for the session.

        :return: The number of ICMP Echo requests which were received during the
                 session

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSessionInfo.RxEchoRequestsGet())



        """
        return _byteblower.ICMPEchoSessionInfo_RxEchoRequestsGet(self)


    def RxEchoRepliesGet(self):
        """

        Returns the ICMP Echo replies which were received for the session.

        :return: The number of ICMP Echo replies which were received during the session

        Example

        .. code-block:: python
           :emphasize-lines: 3

           print(icmpEchoSessionInfo.RxEchoRepliesGet())


        """
        return _byteblower.ICMPEchoSessionInfo_RxEchoRepliesGet(self)


    def RefreshTimestampGet(self):
        """

        Gets the timestamp on the server of when the session info was refreshed.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(icmpEchoSessionInfo.RefreshTimestampGet())



        """
        return _byteblower.ICMPEchoSessionInfo_RefreshTimestampGet(self)

ICMPEchoSessionInfo_swigregister = _byteblower.ICMPEchoSessionInfo_swigregister
ICMPEchoSessionInfo_swigregister(ICMPEchoSessionInfo)

class ICMPProtocol(AbstractObject):
    """

    The ICMP protocol is attached to the IPv4 protocol and allows the host to start
    ICMP sessions, through which it can communicate with the Layer3 IP network.


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICMPProtocol, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ICMPProtocol, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ServerGet(self):
        return _byteblower.ICMPProtocol_ServerGet(self)

    def PortGet(self):
        return _byteblower.ICMPProtocol_PortGet(self)

    def SessionAdd(self, *args):
        """

        Creates an ICMP Echo Session, through which this host can query the Layer3 IP network.

        See :class:`ICMPEchoSession` for more information.

        When an external tool connects to the ByteBlowerPort with an ICMP session
        (e.g. `ping`), that session will not be listed in :meth:`SessionGet`.
        If you want such sessions to be listed there, you will need to call
        :meth:`SessionAdd` given the `applicationId` that is used by the external tool.

        :param applicationId: Provide an application id for this session.
                              This should be unique across the host. If none is given,
                              a random value is generated.
                              Default: `Random generate number`

        :return: :class:`.ICMPEchoSession` - The created echo session is immediately
                 returned.

        Example

        This example creates an Echo session with a random application ID and returns
        this new object.

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession = icmpProtocol.SessionAdd()



        Creates an ICMP Echo Session, through which this host can query the Layer3 IP network.

        See :class:`ICMPEchoSession` for more information.

        When an external tool connects to the ByteBlowerPort with an ICMP session
        (e.g. `ping`), that session will not be listed in :meth:`SessionGet`.
        If you want such sessions to be listed there, you will need to call
        :meth:`SessionAdd` given the `applicationId` that is used by the external tool.

        :param applicationId: Provide an application id for this session.
                              This should be unique across the host. If none is given,
                              a random value is generated.
                              Default: `Random generate number`

        :return: :class:`.ICMPEchoSession` - The created echo session is immediately
                 returned.

        Example

        This example creates an Echo session with a random application ID and returns
        this new object.

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession = icmpProtocol.SessionAdd()


        """
        return _byteblower.ICMPProtocol_SessionAdd(self, *args)


    def SessionGet(self):
        """

        Returns the active list of ICMP Echo Sessions.

        .. note:: The ICMP Protocol may have more active sessions at *server-side* than
                  listed here.

                  This list only returns the :class:`ICMPEchoSession` objects for which
                  a handle has been created at client-side. See below for more
                  information.

        When an external tool connects to the ByteBlowerPort with an ICMP session
        (e.g. `ping`), that session will not be listed here. If you want such sessions
        to be listed here, you will need to call :meth:`SessionAdd` given the
        `applicationId` that is used by the external tool.

        :return: A :class:`ICMPEchoSessionList`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           list = icmpProtocol.SessionGet()


        """
        return _byteblower.ICMPProtocol_SessionGet(self)


    def SessionDestroy(self, inSession):
        return _byteblower.ICMPProtocol_SessionDestroy(self, inSession)
ICMPProtocol_swigregister = _byteblower.ICMPProtocol_swigregister
ICMPProtocol_swigregister(ICMPProtocol)

class ICMPv6EchoSession(AbstractObject):
    """

    Session for handling ICMPv6 Echo Requests and Replies.

    This Session uses the ICMPv6 protocol for receiving and / or transmitting
    ICMPv6 Echo Request and / or Replies An ICMPv6 session can be created using
    :meth:`.ICMPv6Protocol.SessionAdd`

    Some use cases for this session are:

    DUT validation
        Verify some DUT behavioural items

        - Verify whether Echo Request / Replies are filtered out or not
        - Verify public / private connectivity for Routers, NAT gateways, ...

    DUT stability
        Verify that Echo Replies are received during stability tests


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICMPv6EchoSession, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ICMPv6EchoSession, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RemoteAddressSet(self, inIPAddress):
        """

        Configure the destination IPv6 address.

        .. versionadded:: 2.3.0

        This method configures the destination IPv6 address for our ICMPv6 Echo packets

        The destination IPv6 address defines to where the ICMPv6 Echo Requests will be
        sent or from where ICMPv6 Echo Responses are / were received.

        :param ipv6address: The Destination IPv6 Address for this session.

        :raises: python_error: Invalid IPv6 address: When the value could not be
                 interpreted as an IPv6 address

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.RemoteAddressSet(2001:0db8:85a3:0042:1000:8a2e:0370:7334)



        """
        return _byteblower.ICMPv6EchoSession_RemoteAddressSet(self, inIPAddress)


    def RemoteAddressGet(self):
        """

        Returns the ICMPv6 Echo Request destination IPv6 address.

        .. versionadded:: 2.3.0

        This method returns the IPv6 address which has been configured with
        :meth:`RemoteAddressSet`

        :return: The Destination IPv6 address for this session.

        :raises: ByteBlower.Session - When the destination IPv6 address was not yet
                 configured

        Example

        .. code-block:: python
           :emphasize-lines: 3

           print(icmpEchoSession.RemoteAddressGet())


        """
        return _byteblower.ICMPv6EchoSession_RemoteAddressGet(self)


    def DataSizeSet(self, inDataSize):
        """

        Configures the data size.

        This method configures the data size of our ICMPv6 Echo Requests

        The data size of our ICMPv6 Echo Requests is the payload size of the packet

        :param datasize: The ICMPv6 data size you wish to configure.

        Valid range: 0 to *<port_mdl>* - *<ICMPv6_header_size>*.
        Where

        *<port_mdl>*
            Value of :meth:`ByteBlowerPort.MDLGet`

        *<ICMPv6_header_size>*
            Ethernet header size  (14) + IPv6 header size (40) + ICMPv6 header size (8)

        Default value: 56

        :raises: python_error: bad lexical cast: When the value could not be
                 interpreted as a valid integer

        :raises: ByteBlower.Protocol.InvalidValue - When the value is out of range

        Example

        Configure 92Bytes payload for the ICMP Request packets

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.DataSizeSet(92)



        """
        return _byteblower.ICMPv6EchoSession_DataSizeSet(self, inDataSize)


    def DataSizeGet(self):
        """

        Returns the data size of our ICMPv6 Echo Requests.

        The data size of our ICMPv6 Echo Requests is the payload size of the packet

        Default value: 56

        :return: ICMPv6 Echo data size

        Example

        The ICMPv6 session has been configure to add 76 Bytes payload in the ICMPv6
        Request packets

        .. code-block:: python
           :emphasize-lines: 3

           pritn(icmpEchoSession.DataSizeGet())


        """
        return _byteblower.ICMPv6EchoSession_DataSizeGet(self)


    def IdentifierGet(self):
        """

        Getting the ICMPv6 Echo Request Identifier (Application ID)

        :return: The ICMPv6 Echo Request ICMPv6 Identifier for this Session.

        Example

        Returns the (integer) value of the ICMP ID (Application ID)

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.IdentifierGet())



        """
        return _byteblower.ICMPv6EchoSession_IdentifierGet(self)


    def EchoRequestSend(self):
        """

        Transmit an ICMPv6 Echo Request.

        This method sends one ICMPv6 Echo Request.

        .. note:: This method call is (partially) non-blocking. The call will not
                  return as soon the session is setup and the request is sent or an
                  error occurred (exception is thrown). The call does not wait until an
                  Echo Reply is received.

        .. note:: The Destination IPv6 address must be configured (using
                  :meth:`RemoteAddressSet`) before sending Echo Requests

        :raises: ByteBlower.Session.Unavailable - When the destination IPv6 address was
                 not yet configured

        :raises: ByteBlower.Protocol.Session.CreationFailed - When the destination IPv6
                 address cannot be reached

        """
        return _byteblower.ICMPv6EchoSession_EchoRequestSend(self)


    def EchoStatisticsClear(self):
        """

        Resets the ICMPv6 Session statistics.

        .. deprecated:: 2.3.0.
           The recommended approach is to destruct this session and create a new one.

        This method resets the ICMPv6 Session statistics.

        """
        return _byteblower.ICMPv6EchoSession_EchoStatisticsClear(self)


    def EchoLoopIntervalSet(self, inTimeNs):
        """

        Configures the Echo Request interval.

        This method configures the interval between subsequent Echo Request packets
        when sending in a loop.

        The interval has a nanosecond resolution. You can provide a time unit for the
        loop interval value.

        The Echo Request Loop can be started using :meth:`EchoLoopStart`

        :param loopInterval: The interval between two ICMPv6 Echo Request packets [ns].
        :type loopInterval: int

        Valid range: 0 to *<max_uint64>*

            Where *<max_uint64>*    0xFFFFFFFFFFFFFFFF
            = 18446744073709551615
            (= maximum unsigned 64bit integer)

        Default value: 1s

        :raises: python_error: Failed to parse time string:
                 When the value could not be interpreted as a valid time string

        Example

        Configure an interval of 50 microseconds (50000 nanoseconds)

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession.EchoLoopIntervalSet(50000)

        Configure an interval of 500 milliseconds

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.EchoLoopIntervalSet(500000000)


        Configure an interval of 1.25 milliseconds

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.EchoLoopIntervalSet(1250000)



        """
        return _byteblower.ICMPv6EchoSession_EchoLoopIntervalSet(self, inTimeNs)


    def EchoLoopIntervalGet(self):
        """

        Returns the Echo Request interval.

        This method returns the interval between subsequent Echo Request packets when
        sending in a loop.

        The Echo Request Loop can be started using :meth:`EchoLoopStart`

        .. note:: The interval is always returned in nanoseconds resolution.
                  No unit is added to the value.

        Default value: 1s

        :return: The interval between two ICMPv6 Echo Request packets [ns]

        Example

        The transmit loop is configured with an interval of 625 microseconds

        .. code-block:: python
           :emphasize-lines: 3

        	print(icmpEchoSession.EchoLoopIntervalGet())


        """
        return _byteblower.ICMPv6EchoSession_EchoLoopIntervalGet(self)


    def EchoLoopCountSet(self, arg2):
        """

        Configures the Echo Request count.

        This method configures the number of Echo Requests which will be transmitted
        when sending in a loop.

        The Echo Request Loop can be started using :meth:`EchoLoopStart`

        :param packetcount: The number of ICMPv6 Echo Request packets to transmit

        Default value: infinite
        The actual value is

            *<max_uint64>*
            = 0xFFFFFFFFFFFFFFFF
            = 18446744073709551615
            (= maximum unsigned 64bit integer)

        :raises: python_error bad lexical cast: When the value could not be
                 interpreted as a valid integer

        .. versionadded:: 1.8.18

        Example

        Configure the loop to transmit 500 ICMP Echo Request packets

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.EchoLoopCountSet(500)


        """
        return _byteblower.ICMPv6EchoSession_EchoLoopCountSet(self, arg2)


    def EchoLoopCountGet(self):
        """

        Returns the Echo Request count.

        This method returns the number of Echo Requests which will be transmitted when
        sending in a loop.

        Default value: infinite

            The actual value is *<max_uint64>*
            = 0xFFFFFFFFFFFFFFFF
            = 18446744073709551615 (= maximum unsigned 64bit integer)

        :return: The number of ICMPv6 Echo Request packets in a loop

        .. versionadded:: 1.8.18

        Example

        The transmit loop is configured to transmit 12345 packets

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.EchoLoopCountGet())



        """
        return _byteblower.ICMPv6EchoSession_EchoLoopCountGet(self)


    def EchoLoopStart(self):
        """

        Starts sending Echo Requests in a loop.

        This method start sending Echo Requests in a loop.

        The interval between Echo Request can be configured using the method
        :meth:`EchoLoopIntervalSet`

        If a limited number of Echo Request is desired, this can be configured using
        the method :meth:`EchoLoopCountSet`

        .. note:: This method call is (partially) non-blocking. The call will return as
                  soon as the session is started an the loop is running or an error
                  occurred during session initialization.

        .. note:: The Destination IPv6 address must be configured (using
                  :meth:`RemoteAddressSet`) before sending Echo Requests

        :raises: Session.Unavailable - When the destination IPv6 address was not yet
                 configured

        :raises: Protocol.Session.CreationFailed - When the destination IPv6 address
                 cannot be reached

        """
        return _byteblower.ICMPv6EchoSession_EchoLoopStart(self)


    def EchoLoopStop(self):
        """

        Stops sending Echo Requests in a loop.

        This method stops sending Echo Requests in a loop. The loop can be started with
        :meth:`EchoLoopStart`

        .. note:: This method does not throw an exception if the loop was not started

        """
        return _byteblower.ICMPv6EchoSession_EchoLoopStop(self)


    def HopLimitSet(self, arg2):
        """

        Setting the ICMPv6 Echo Request HopLimit.

        The Hop Limit field is decremented when the packet is forwarded by a router.

        :param hopLimit: The ICMPv6 Echo Request ICMPv6 HopLimit for this Session.
                         The maximum legal value is 255.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.HopLimitSet(123)



        """
        return _byteblower.ICMPv6EchoSession_HopLimitSet(self, arg2)


    def HopLimitGet(self):
        """

        Getting the ICMPv6 Echo Request HopLimit.

        :return: The ICMPv6 Echo Request ICMPv6 HopLimit for this Session.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.HopLimitGet())



        """
        return _byteblower.ICMPv6EchoSession_HopLimitGet(self)


    def TrafficClassSet(self, inTrafficClass):
        """

        Configures the 'Traffic Class' used at the IP layer.

        .. versionadded:: 2.5.0

        The input accepts integers from 0 up to 255. This value will be directly used
        in byte-sized field at the IP layer. No additional coding is performed.

        This method can be called solely during the configuration phase, thus before
        the parent ByteBlower port is started. Invoking the method at other moments
        will result in error.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.TrafficClassSet(16)


        """
        return _byteblower.ICMPv6EchoSession_TrafficClassSet(self, inTrafficClass)


    def TrafficClassGet(self):
        """

        Retrieves the 'Traffic Class' configuration of the IP layer.

        .. versionadded:: 2.5.0

        This method returns a number from 0 up to 255. This value represents the the
        byte used at the IP layer.

        :return: The byte value of the 'Type Of Service' or 'Traffic Class' field.

        The default value is 0.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.TrafficClassGet())



        """
        return _byteblower.ICMPv6EchoSession_TrafficClassGet(self)


    def SessionInfoGet(self):
        """

        Returns the session information.

        .. versionadded:: 2.3.0

        This method returns the :class:`ICMPv6SessionInfo` object.

        :return: :class:`.ICMPv6SessionInfo`

        Example

        The transmit loop is configured to transmit 12345 packets

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.SessionInfoGet().DescriptionGet())



        """
        return _byteblower.ICMPv6EchoSession_SessionInfoGet(self)


    def GetICMPv6Protocol(self):
        return _byteblower.ICMPv6EchoSession_GetICMPv6Protocol(self)
ICMPv6EchoSession_swigregister = _byteblower.ICMPv6EchoSession_swigregister
ICMPv6EchoSession_swigregister(ICMPv6EchoSession)

class ICMPv6EchoSessionInfo(AbstractRefreshableResult):
    """



    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICMPv6EchoSessionInfo, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ICMPv6EchoSessionInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TxEchoRequestsGet(self):
        """

        Returns the ICMP Echo requests which were transmitted for the session.

        :return: The number of ICMP Echo requests which were sent during the session

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	icmpEchoSession.TxEchoRequestsGet()



        """
        return _byteblower.ICMPv6EchoSessionInfo_TxEchoRequestsGet(self)


    def TxEchoRepliesGet(self):
        """

        Returns the ICMP Echo replies which were transmitted for the session.

        :return: The number of ICMP Echo replies which were sent during the session

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.TxEchoRepliesGet())



        """
        return _byteblower.ICMPv6EchoSessionInfo_TxEchoRepliesGet(self)


    def RxEchoRequestsGet(self):
        """

        Returns the ICMP Echo requests which were received for the session.

        :return: The number of ICMP Echo requests which were received during the session

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.RxEchoRequestsGet())



        """
        return _byteblower.ICMPv6EchoSessionInfo_RxEchoRequestsGet(self)


    def RxEchoRepliesGet(self):
        """

        Returns the ICMP Echo replies which were received for the session.

        :return: The number of ICMP Echo replies which were received during the session

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.RxEchoRepliesGet())



        """
        return _byteblower.ICMPv6EchoSessionInfo_RxEchoRepliesGet(self)


    def RefreshTimestampGet(self):
        """

        Gets the timestamp on the server of when the session info was refreshed.

        :return: Returns the timestamp of the refresh

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(icmpEchoSession.RefreshTimestampGet())


        """
        return _byteblower.ICMPv6EchoSessionInfo_RefreshTimestampGet(self)

ICMPv6EchoSessionInfo_swigregister = _byteblower.ICMPv6EchoSessionInfo_swigregister
ICMPv6EchoSessionInfo_swigregister(ICMPv6EchoSessionInfo)

class ICMPv6Protocol(AbstractObject):
    """

    ICMPv6 Protocol.

    Every :class:`IPv6Configuration` has a ICMPv6Protocol attached. With this class
    you can create a :class:`.ICMPv6EchoSession` to send Echo Requests


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICMPv6Protocol, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ICMPv6Protocol, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PortGet(self):
        return _byteblower.ICMPv6Protocol_PortGet(self)

    def SessionAdd(self, *args):
        """

        Creates an ICMPv6 Echo Session, through which this host can query the Layer3
        IP network.

        See :class:`.ICMPv6EchoSession` for more information.

        When an external tool connects to the ByteBlowerPort with an ICMPv6 session
        (e.g. `ping6`), that session will not be listed in :meth:`SessionGet`. If you
        want such sessions to be listed there, you will need to call :meth:`SessionAdd`
        given the `applicationId` that is used by the
        external tool.

        :param applicationId: Provide an ICMPv6 application id for this session. This
                              should be unique across the host. If none is given, a
                              random value is generated.
                              Default: `Random generate number`

        :return: :class:`.ICMPv6EchoSession` - The created echo session.

        Example

        This example creates an Echo session with a random application ID and returns
        this new object.

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession = icmpProtocol.SessionAdd()



        Creates an ICMPv6 Echo Session, through which this host can query the Layer3
        IP network.

        See :class:`.ICMPv6EchoSession` for more information.

        When an external tool connects to the ByteBlowerPort with an ICMPv6 session
        (e.g. `ping6`), that session will not be listed in :meth:`SessionGet`. If you
        want such sessions to be listed there, you will need to call :meth:`SessionAdd`
        given the `applicationId` that is used by the
        external tool.

        :param applicationId: Provide an ICMPv6 application id for this session. This
                              should be unique across the host. If none is given, a
                              random value is generated.
                              Default: `Random generate number`

        :return: :class:`.ICMPv6EchoSession` - The created echo session.

        Example

        This example creates an Echo session with a random application ID and returns
        this new object.

        .. code-block:: python
           :emphasize-lines: 1

           icmpEchoSession = icmpProtocol.SessionAdd()


        """
        return _byteblower.ICMPv6Protocol_SessionAdd(self, *args)


    def SessionGet(self):
        """

        Returns the active list of ICMPv6 Echo Sessions.

        .. note:: The ICMPv6 Protocol may have more active sessions at *server-side*
                  than listed here. This list only returns the
                  :class:`.ICMPv6EchoSession` objects for which a handle has been
                  created at client-side. See below for more information.

        When an external tool connects to the :class:`.ByteBlowerPort` with an ICMPv6
        session (e.g. `ping6`), that session will not be listed here. If you want such
        sessions to be listed here, you will need to call :meth:`SessionAdd` given the
        `applicationId` that is used by the external tool.

        :return: :class:`.ICMPv6EchoSessionList` object

        Example

        .. code-block:: python
           :emphasize-lines: 1

           list = icmpProtocol.SessionGet()


        """
        return _byteblower.ICMPv6Protocol_SessionGet(self)


    def SessionDestroy(self, inSession):
        return _byteblower.ICMPv6Protocol_SessionDestroy(self, inSession)
ICMPv6Protocol_swigregister = _byteblower.ICMPv6Protocol_swigregister
ICMPv6Protocol_swigregister(ICMPv6Protocol)

class IGMPProtocol(AbstractObject):
    """

    The Internet Group Management Protocol (IGMP) Protocol for IPv4 manages
    multicast group membership for a given IPv4 host.

    This class support three IGMP Protocol versions:

    IGMPv1
        :rfc:1112

    IGMPv2
        :rfc:2236. IGMPv2 allows group membership termination to be quickly
        reported to the routing protocol, which is important for high-bandwidth
        multicast groups and/or subnets with highly volatile group membership.

    IGMPv3
        :rfc:3376. Version 3 of IGMP adds support for "source filtering", that
        is, the ability for a system to report interest in receiving packets
        **only** from specific source addresses, or from **all but** specific
        source addresses, sent to a particular multicast address. That information
        may be used by multicast routing protocols to avoid delivering multicast
        packets from specific sources to networks where there are no interested
        receivers.


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IGMPProtocol, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IGMPProtocol, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ProtocolInfoGet(self):
        """

        Returns the ProtocolInfo object that contains various stats on the IGMPProtocol

        :return: :class:`.IGMPProtocolInfo`

        Example

        .. code-block:: python
           :emphasize-lines: 1
                protocolInfo = icmpProtocol.ProtocolInfoGet()


        """
        return _byteblower.IGMPProtocol_ProtocolInfoGet(self)


    def ProtocolInfoDestroy(self, inIGMPProtocolInfo):
        return _byteblower.IGMPProtocol_ProtocolInfoDestroy(self, inIGMPProtocolInfo)

    def SessionV1Add(self, inGroupAddress):
        """

        Adding a IGMPv1 Session.

        :return: :class:`IGMPv1MemberSession`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	sessionv1 = icmpProtocol.SessionV1Add('235.0.0.1')


        """
        return _byteblower.IGMPProtocol_SessionV1Add(self, inGroupAddress)


    def SessionV2Add(self, inGroupAddress):
        """

        Adding a IGMPv2 Session.

        :return: :class:`IGMPv2MemberSession`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	sessionv2 = icmpProtocol.SessionV2Add('235.0.0.1')


        """
        return _byteblower.IGMPProtocol_SessionV2Add(self, inGroupAddress)


    def SessionV3Add(self, inGroupAddress):
        """

        Adding a IVMPv3 Session.

        :return: :class:`IGMPv3MemberSession`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	sessionv3 = icmpProtocol.SessionV3Add('235.0.0.1')



        """
        return _byteblower.IGMPProtocol_SessionV3Add(self, inGroupAddress)


    def SessionDestroy(self, *args):
        return _byteblower.IGMPProtocol_SessionDestroy(self, *args)
IGMPProtocol_swigregister = _byteblower.IGMPProtocol_swigregister
IGMPProtocol_swigregister(IGMPProtocol)

class IGMPProtocolInfo(AbstractRefreshableResult):
    """

    Class: IGMPProtocolInfo


    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IGMPProtocolInfo, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IGMPProtocolInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RxGet(self):
        return _byteblower.IGMPProtocolInfo_RxGet(self)

    def RxQueriesGet(self):
        return _byteblower.IGMPProtocolInfo_RxQueriesGet(self)

    def RxReportsGet(self):
        return _byteblower.IGMPProtocolInfo_RxReportsGet(self)

    def RxVersion1QueriesGet(self):
        return _byteblower.IGMPProtocolInfo_RxVersion1QueriesGet(self)

    def RxVersion1ReportsGet(self):
        return _byteblower.IGMPProtocolInfo_RxVersion1ReportsGet(self)

    def RxVersion2QueriesGet(self):
        return _byteblower.IGMPProtocolInfo_RxVersion2QueriesGet(self)

    def RxVersion2ReportsGet(self):
        return _byteblower.IGMPProtocolInfo_RxVersion2ReportsGet(self)

    def RxVersion2LeavesGet(self):
        return _byteblower.IGMPProtocolInfo_RxVersion2LeavesGet(self)

    def RxVersion3QueriesGet(self):
        return _byteblower.IGMPProtocolInfo_RxVersion3QueriesGet(self)

    def RxVersion3ReportsGet(self):
        return _byteblower.IGMPProtocolInfo_RxVersion3ReportsGet(self)

    def TxGet(self):
        return _byteblower.IGMPProtocolInfo_TxGet(self)

    def TxReportsGet(self):
        return _byteblower.IGMPProtocolInfo_TxReportsGet(self)

    def TxVersion1ReportsGet(self):
        return _byteblower.IGMPProtocolInfo_TxVersion1ReportsGet(self)

    def TxVersion2ReportsGet(self):
        return _byteblower.IGMPProtocolInfo_TxVersion2ReportsGet(self)

    def TxVersion2LeavesGet(self):
        return _byteblower.IGMPProtocolInfo_TxVersion2LeavesGet(self)

    def TxVersion3ReportsGet(self):
        return _byteblower.IGMPProtocolInfo_TxVersion3ReportsGet(self)

    def RefreshTimestampGet(self):
        """




        """
        return _byteblower.IGMPProtocolInfo_RefreshTimestampGet(self)

IGMPProtocolInfo_swigregister = _byteblower.IGMPProtocolInfo_swigregister
IGMPProtocolInfo_swigregister(IGMPProtocolInfo)

class IGMPMemberSession(SchedulableObject):
    __swig_setmethods__ = {}
    for _s in [SchedulableObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IGMPMemberSession, name, value)
    __swig_getmethods__ = {}
    for _s in [SchedulableObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IGMPMemberSession, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def MulticastAddressGet(self):
        return _byteblower.IGMPMemberSession_MulticastAddressGet(self)

    def VersionGet(self):
        return _byteblower.IGMPMemberSession_VersionGet(self)

    def SessionInfoGet(self):
        return _byteblower.IGMPMemberSession_SessionInfoGet(self)

    def SessionInfoDestroy(self, inMemberSessionInfo):
        return _byteblower.IGMPMemberSession_SessionInfoDestroy(self, inMemberSessionInfo)
IGMPMemberSession_swigregister = _byteblower.IGMPMemberSession_swigregister
IGMPMemberSession_swigregister(IGMPMemberSession)

class IGMPv1MemberSession(IGMPMemberSession):
    """



    """

    __swig_setmethods__ = {}
    for _s in [IGMPMemberSession]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IGMPv1MemberSession, name, value)
    __swig_getmethods__ = {}
    for _s in [IGMPMemberSession]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IGMPv1MemberSession, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Join(self):
        """


        """
        return _byteblower.IGMPv1MemberSession_Join(self)


    def Leave(self):
        """


        """
        return _byteblower.IGMPv1MemberSession_Leave(self)

IGMPv1MemberSession_swigregister = _byteblower.IGMPv1MemberSession_swigregister
IGMPv1MemberSession_swigregister(IGMPv1MemberSession)

class IGMPv2MemberSession(IGMPMemberSession):
    """


    """

    __swig_setmethods__ = {}
    for _s in [IGMPMemberSession]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IGMPv2MemberSession, name, value)
    __swig_getmethods__ = {}
    for _s in [IGMPMemberSession]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IGMPv2MemberSession, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Join(self):
        """


        """
        return _byteblower.IGMPv2MemberSession_Join(self)


    def Leave(self):
        """


        """
        return _byteblower.IGMPv2MemberSession_Leave(self)

IGMPv2MemberSession_swigregister = _byteblower.IGMPv2MemberSession_swigregister
IGMPv2MemberSession_swigregister(IGMPv2MemberSession)

class IGMPv3MemberSession(IGMPMemberSession):
    """


    """

    __swig_setmethods__ = {}
    for _s in [IGMPMemberSession]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IGMPv3MemberSession, name, value)
    __swig_getmethods__ = {}
    for _s in [IGMPMemberSession]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IGMPv3MemberSession, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def MulticastListen(self, inSourceFilter, inSourceList):
        """


        """
        return _byteblower.IGMPv3MemberSession_MulticastListen(self, inSourceFilter, inSourceList)


    def SourceFilterModeGet(self):
        """


        """
        return _byteblower.IGMPv3MemberSession_SourceFilterModeGet(self)


    def SourceListGet(self):
        """


        """
        return _byteblower.IGMPv3MemberSession_SourceListGet(self)

IGMPv3MemberSession_swigregister = _byteblower.IGMPv3MemberSession_swigregister
IGMPv3MemberSession_swigregister(IGMPv3MemberSession)

class IGMPMemberSessionInfo(AbstractRefreshableResult):
    """

    InfoObject of the IGMPSession. Contains various stats of the IGMPSession

    Example

    .. code-block:: python
       :emphasize-lines: 1

    	sessionv1 = igmpProtocol.SessionV1Add()
    	igmpMemberSessionInfo = sessionv1.SessionInfoGet()


    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IGMPMemberSessionInfo, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IGMPMemberSessionInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RxGet(self):
        """

        Returns the number of IGMP messages received by this session.

        :return: number of IGMP messages received by this session

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.RxGet())



        """
        return _byteblower.IGMPMemberSessionInfo_RxGet(self)


    def RxQueriesGet(self):
        """

        Returns the number of received IGMP queries by this session.

        :return: Number of IGMP v1 queries received

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.RxQueriesGet())



        """
        return _byteblower.IGMPMemberSessionInfo_RxQueriesGet(self)


    def RxVersion1ReportsGet(self):
        """

        Returns the number of transmitted IGMP V2 reports by this session.

        :return: Number of IGMP v1 reports received

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.RxVersion1ReportsGet())



        """
        return _byteblower.IGMPMemberSessionInfo_RxVersion1ReportsGet(self)


    def RxVersion2ReportsGet(self):
        """

        Returns the number of transmitted IGMP V2 reports by this session.

        :return: Number of IGMP v2 reports received

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.RxVersion2ReportsGet())


        """
        return _byteblower.IGMPMemberSessionInfo_RxVersion2ReportsGet(self)


    def TxGet(self):
        """

        Returns the number of IGMP messages transmitted by this session.

        :return: Number of IGMP messages transmitted

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.TxGet())



        """
        return _byteblower.IGMPMemberSessionInfo_TxGet(self)


    def TxVersion1ReportsGet(self):
        """

        Returns the number of transmitted IGMP V1 reports by this session.

        :return: Number of IGMP v1 reports transmitted

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.TxVersion1ReportsGet())



        """
        return _byteblower.IGMPMemberSessionInfo_TxVersion1ReportsGet(self)


    def TxVersion2ReportsGet(self):
        """

        Returns the number of transmitted IGMP V2 reports by this session.

        :return: Number of IGMP v2 reports transmitted

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.TxVersion2ReportsGet())



        """
        return _byteblower.IGMPMemberSessionInfo_TxVersion2ReportsGet(self)


    def TxVersion2LeavesGet(self):
        """

        Returns the number of transmitted IGMP V2 leaves by this session.

        :return: Number of IGMP v2 leaves transmitted

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.TxVersion2LeavesGet())



        """
        return _byteblower.IGMPMemberSessionInfo_TxVersion2LeavesGet(self)


    def TxVersion3ReportsGet(self):
        """

        Returns the number of transmitted IGMP V3 reports by this session.

        :return: Number of IGMP v3 reports transmitted

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.TxVersion3ReportsGet())



        """
        return _byteblower.IGMPMemberSessionInfo_TxVersion3ReportsGet(self)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp when the counters of this object where last refreshed.

        :return: RefreshTimestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(igmpMemberSessionInfo.RefreshTimestampGet())



        """
        return _byteblower.IGMPMemberSessionInfo_RefreshTimestampGet(self)

IGMPMemberSessionInfo_swigregister = _byteblower.IGMPMemberSessionInfo_swigregister
IGMPMemberSessionInfo_swigregister(IGMPMemberSessionInfo)

class MLDMulticastListenerSessionInfo(AbstractRefreshableResult):
    """



    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MLDMulticastListenerSessionInfo, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MLDMulticastListenerSessionInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RxGet(self):
        """

        Returns the number of received MLD messages by this session.

        :return: Number of MLD messages received

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_RxGet(self)


    def RxListenerQueriesGet(self):
        """

        Returns the number of received MLD queries by this session.

        :return: Number of MLD v1 queries received

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_RxListenerQueriesGet(self)


    def RxVersion1ListenerReportsGet(self):
        """

        Returns the number of received MLD v1 Listener reports by this session.

        :return:  Number of MLD v1 Listener reports received

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_RxVersion1ListenerReportsGet(self)


    def TxGet(self):
        """

        Returns the number of transmitted MLD messages by this session.

        :return: Number of MLD messages Transmitted

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_TxGet(self)


    def TxVersion1ListenerReportsGet(self):
        """

        Returns the number of transmitted MLD V1 reports by this session.

        :return: Number of transmitted MLD v1 reports

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_TxVersion1ListenerReportsGet(self)


    def TxVersion1ListenerDonesGet(self):
        """

        Returns the number of received MLD V1 Listeners done by this session.

        :return:  Number of transmitted MLD v1 Listener dones

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_TxVersion1ListenerDonesGet(self)


    def TxVersion2ListenerReportsGet(self):
        """

        Returns the number of received MLD queries by this session.

        :return: Number of transmitted MLD v2 Listener reports

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_TxVersion2ListenerReportsGet(self)


    def RefreshTimestampGet(self):
        """

        Retuns the timestamp when the info was last refreshed.

        :return: RefreshTimestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDMulticastListenerSessionInfo_RefreshTimestampGet(self)

MLDMulticastListenerSessionInfo_swigregister = _byteblower.MLDMulticastListenerSessionInfo_swigregister
MLDMulticastListenerSessionInfo_swigregister(MLDMulticastListenerSessionInfo)

class MLDMulticastListenerSession(SchedulableObject):
    __swig_setmethods__ = {}
    for _s in [SchedulableObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MLDMulticastListenerSession, name, value)
    __swig_getmethods__ = {}
    for _s in [SchedulableObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MLDMulticastListenerSession, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def MulticastAddressGet(self):
        return _byteblower.MLDMulticastListenerSession_MulticastAddressGet(self)

    def VersionGet(self):
        return _byteblower.MLDMulticastListenerSession_VersionGet(self)

    def SessionInfoGet(self):
        return _byteblower.MLDMulticastListenerSession_SessionInfoGet(self)

    def SessionInfoDestroy(self, inMulticastListenerSessionInfo):
        return _byteblower.MLDMulticastListenerSession_SessionInfoDestroy(self, inMulticastListenerSessionInfo)
MLDMulticastListenerSession_swigregister = _byteblower.MLDMulticastListenerSession_swigregister
MLDMulticastListenerSession_swigregister(MLDMulticastListenerSession)

class MLDProtocol(AbstractObject):
    """

    The Multicast Listener Discovery Protocol (MLD) Protocol for IPv6 manages
    multicast address listening for a given IPv6 host.

    This class support two MLD Protocol versions:

    MLDv1
        :rfc:2710

    MLDv2
        :rfc:3810. Version 2 of MLD adds support for 'source filtering', that is,
        the ability for a system to report interest in receiving packets *only*
        from specific source addresses, or from *all but* specific source
        addresses, sent to a particular multicast address. That information may be
        used by multicast routing protocols to avoid delivering multicast packets
        from specific sources to networks where there are no interested receivers.


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MLDProtocol, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MLDProtocol, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ProtocolInfoGet(self):
        """

        :return: :class:`.MLDProtocolInfo`

        """
        return _byteblower.MLDProtocol_ProtocolInfoGet(self)


    def ProtocolInfoDestroy(self, inMLDProtocolInfo):
        return _byteblower.MLDProtocol_ProtocolInfoDestroy(self, inMLDProtocolInfo)

    def SessionV1Add(self, inMulticastAddress):
        """

        Create a MLDv1 session.

        :return: :class:`.MLDv1MulticastListenerSession`

        Example


        """
        return _byteblower.MLDProtocol_SessionV1Add(self, inMulticastAddress)


    def SessionV2Add(self, inMulticastAddress):
        """

        Create a MLDv2 session.

        :return: :class:`MLDv2MulticastListenerSession`

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MLDProtocol_SessionV2Add(self, inMulticastAddress)


    def SessionDestroy(self, *args):
        return _byteblower.MLDProtocol_SessionDestroy(self, *args)
MLDProtocol_swigregister = _byteblower.MLDProtocol_swigregister
MLDProtocol_swigregister(MLDProtocol)

class MLDProtocolInfo(AbstractRefreshableResult):
    """



    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MLDProtocolInfo, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MLDProtocolInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RxGet(self):
        return _byteblower.MLDProtocolInfo_RxGet(self)

    def RxListenerQueriesGet(self):
        return _byteblower.MLDProtocolInfo_RxListenerQueriesGet(self)

    def RxListenerReportsGet(self):
        return _byteblower.MLDProtocolInfo_RxListenerReportsGet(self)

    def RxVersion1ListenerQueriesGet(self):
        return _byteblower.MLDProtocolInfo_RxVersion1ListenerQueriesGet(self)

    def RxVersion1ListenerReportsGet(self):
        return _byteblower.MLDProtocolInfo_RxVersion1ListenerReportsGet(self)

    def RxVersion1ListenerDonesGet(self):
        return _byteblower.MLDProtocolInfo_RxVersion1ListenerDonesGet(self)

    def RxVersion2ListenerQueriesGet(self):
        return _byteblower.MLDProtocolInfo_RxVersion2ListenerQueriesGet(self)

    def RxVersion2ListenerReportsGet(self):
        return _byteblower.MLDProtocolInfo_RxVersion2ListenerReportsGet(self)

    def TxGet(self):
        return _byteblower.MLDProtocolInfo_TxGet(self)

    def TxListenerReportsGet(self):
        return _byteblower.MLDProtocolInfo_TxListenerReportsGet(self)

    def TxVersion1ListenerReportsGet(self):
        return _byteblower.MLDProtocolInfo_TxVersion1ListenerReportsGet(self)

    def TxVersion1ListenerDonesGet(self):
        return _byteblower.MLDProtocolInfo_TxVersion1ListenerDonesGet(self)

    def TxVersion2ListenerReportsGet(self):
        return _byteblower.MLDProtocolInfo_TxVersion2ListenerReportsGet(self)

    def RefreshTimestampGet(self):
        """



        """
        return _byteblower.MLDProtocolInfo_RefreshTimestampGet(self)

MLDProtocolInfo_swigregister = _byteblower.MLDProtocolInfo_swigregister
MLDProtocolInfo_swigregister(MLDProtocolInfo)

class MLDv1MulticastListenerSession(MLDMulticastListenerSession):
    """



    """

    __swig_setmethods__ = {}
    for _s in [MLDMulticastListenerSession]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MLDv1MulticastListenerSession, name, value)
    __swig_getmethods__ = {}
    for _s in [MLDMulticastListenerSession]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MLDv1MulticastListenerSession, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ListeningStart(self):
        """



        """
        return _byteblower.MLDv1MulticastListenerSession_ListeningStart(self)


    def ListeningStop(self):
        """



        """
        return _byteblower.MLDv1MulticastListenerSession_ListeningStop(self)

MLDv1MulticastListenerSession_swigregister = _byteblower.MLDv1MulticastListenerSession_swigregister
MLDv1MulticastListenerSession_swigregister(MLDv1MulticastListenerSession)

class MLDv1StartListening(_object):
    """



    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MLDv1StartListening, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MLDv1StartListening, name)
    __repr__ = _swig_repr

    def __init__(self, arg2):
        this = _byteblower.new_MLDv1StartListening(arg2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_MLDv1StartListening
    __del__ = lambda self: None
MLDv1StartListening_swigregister = _byteblower.MLDv1StartListening_swigregister
MLDv1StartListening_swigregister(MLDv1StartListening)

class MLDv1StopListening(_object):
    """



    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MLDv1StopListening, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MLDv1StopListening, name)
    __repr__ = _swig_repr

    def __init__(self, arg2):
        this = _byteblower.new_MLDv1StopListening(arg2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _byteblower.delete_MLDv1StopListening
    __del__ = lambda self: None
MLDv1StopListening_swigregister = _byteblower.MLDv1StopListening_swigregister
MLDv1StopListening_swigregister(MLDv1StopListening)

class MLDv2MulticastListenerSession(MLDMulticastListenerSession):
    """



    """

    __swig_setmethods__ = {}
    for _s in [MLDMulticastListenerSession]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MLDv2MulticastListenerSession, name, value)
    __swig_getmethods__ = {}
    for _s in [MLDMulticastListenerSession]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MLDv2MulticastListenerSession, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def MulticastListen(self, inSourceFilter, inSourceList):
        """



        """
        return _byteblower.MLDv2MulticastListenerSession_MulticastListen(self, inSourceFilter, inSourceList)


    def SourceFilterModeGet(self):
        """



        """
        return _byteblower.MLDv2MulticastListenerSession_SourceFilterModeGet(self)


    def SourceListGet(self):
        """


        """
        return _byteblower.MLDv2MulticastListenerSession_SourceListGet(self)

MLDv2MulticastListenerSession_swigregister = _byteblower.MLDv2MulticastListenerSession_swigregister
MLDv2MulticastListenerSession_swigregister(MLDv2MulticastListenerSession)

class MLDv2IPMulticastListen(_object):
    """



    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MLDv2IPMulticastListen, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MLDv2IPMulticastListen, name)
    __repr__ = _swig_repr

    def __init__(self, arg2):
        this = _byteblower.new_MLDv2IPMulticastListen(arg2)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SourceFilterSet(self, filter):
        """



        """
        return _byteblower.MLDv2IPMulticastListen_SourceFilterSet(self, filter)


    def SourceFilterGet(self):
        """



        """
        return _byteblower.MLDv2IPMulticastListen_SourceFilterGet(self)


    def MulticastSourcesSet(self, sourceList):
        """



        """
        return _byteblower.MLDv2IPMulticastListen_MulticastSourcesSet(self, sourceList)


    def MulticastSourcesGet(self):
        """



        """
        return _byteblower.MLDv2IPMulticastListen_MulticastSourcesGet(self)

    __swig_destroy__ = _byteblower.delete_MLDv2IPMulticastListen
    __del__ = lambda self: None
MLDv2IPMulticastListen_swigregister = _byteblower.MLDv2IPMulticastListen_swigregister
MLDv2IPMulticastListen_swigregister(MLDv2IPMulticastListen)

class TelnetClient(AbstractObject):
    """

    A Telnet client application that allows communication with an external Telnet
    server.

    The Telnet protocol allows for bidirectional interactive communication between
    a Telnet client (i.e. this application) on a ByteBlower port and an external
    Telnet server.

    The Telnet protocol can be used to log in on other machines using a virtual
    terminal. By sending Telnet commands using :meth:`Send`, waiting for a small
    amount of time and reading the response using :meth:`Receive`, a complete
    interactive session may be constructed.

    The protocol can also be used to debug other network protocols. For example,
    contacting an HTTP server (on port 80) using a Telnet client and sending a
    valid HTTP request towards it, should correctly return the HTTP response data.

    .. versionadded:: 2.2.0


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TelnetClient, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TelnetClient, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PortGet(self):
        return _byteblower.TelnetClient_PortGet(self)

    def RemoteAddressSet(self, inAddress):
        """

        Sets the IP address of the Telnet server to which this client connects.

        Before this address is set, no connection can be opened or traffic can be sent.

        Both IPv4 and IPv6 addresses are supported, but the provided (remote) address
        must match be of the same type as the ByteBlower port of this client.

        .. note:: Currently, DNS is not supported, so providing a URL is not possible.

        :param address: The IP address of the Telnet server to which this client
                        connects. This should be either an valid IPv4 address or a
                        valid IPv6 address.
        :type address: str

        :raises: :exc:`.ConfigError` If an invalid IP address is entered, this error is
                 thrown.

        :raises: ByteBlower.Protocol.InvalidValue - If an IPv4 address is provided,
                 while this client is on an IPv6 ByteBlower port or vice versa, this
                 exception is thrown.

        :raises: ByteBlower.Protocol.ConfigLocked - If a Telnet session is currently
                 opened, this exception is thrown. Use ::Close to close the session
                 before changing the Telnet server address.

        Example

        This snippet sets the IP address of the Telnet server to be contacted.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_RemoteAddressSet(self, inAddress)


    def RemoteAddressGet(self):
        """

        Returns the IP address of the Telnet server to which this client connects.

        Before this address is set, no connection can be opened or traffic can be sent.

        Both IPv4 and IPv6 addresses are supported, but the provided (remote) address
        must match use the same IP protocol as the ByteBlower port of this client.

        ..note:: Currently, DNS is not supported, so providing a URL is not possible.

        :return: The IP address of the Telnet server to which this client connects.
                 This should be either an valid IPv4 address or a valid IPv6 address.

        :raises: ByteBlower.Protocol.InvalidValue - If the remote IP address is not
                 configured yet

        Example

        This example returns the IP address of the Telnet server.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_RemoteAddressGet(self)


    def RemotePortSet(self, inRemotePort):
        """

        Configures (remote) TCP port on the Telnet server to which this client
        connects.

        The client will communicate with the Telnet server on the configured port.

        If the TCP port isn't explicitly set (yet), the server will take the default
        Telnet server port (23).

        Default value 23

        :param port: The TCP port on the Telnet server to which this client connects.
                     This should be an integer value. Values larger the maximum port
                     value of 65536 overflow into a valid port number.

        :raises: InvalidValue.Integer - If the parameter value isn't an integer

        :raises: ByteBlower.Protocol.ConfigLocked - If a Telnet session is currently
                 opened, this exception is thrown. Use :meth:`Close` to close the
                 session before changing the Telnet server     port.

        Example

        This snippet sets the port number of the Telnet server to be contacted.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_RemotePortSet(self, inRemotePort)


    def RemotePortGet(self):
        """

        Returns the (remote) TCP port on the Telnet server to which this client
        connects

        The client will communicate with the Telnet server on the configured port.

        If the TCP port isn't explicitly set (yet), this will return the default Telnet
        server port (23).

        Default value 23

        :return: The currently configured TCP port on the Telnet server to which this
                 client connects. This is an integer value.

        Example

        This example returns the port number of the Telnet server.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_RemotePortGet(self)


    def LocalPortSet(self, inLocalPort):
        """

        Configures the (local) TCP port used by this client.

        The client will communicate with the server through a TCP network socket on
        this port and listen on it for incoming traffic.

        If the TCP port isn't explicitly set (yet), the server will use a valid and
        unique TCP port number for within the scope of the ByteBlower port
        (e.g. 32687).

        Default value Valid and unique client TCP port

        :param port: The TCP port to be used by this client. This should be an integer
                     value. Values larger the maximum port value of 65536 overflow into
                     a valid port number.

        :raises: InvalidValue.Integer - If the parameter value isn't an integer

        :raises: ByteBlower.Protocol.ConfigLocked - If a Telnet session is currently
                 opened, this exception is thrown. Use ::Close to close the session
                 before changing the Telnet server port.

        Example

        This snippet sets the port number on which this client will connect to the
        Telnet server.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_LocalPortSet(self, inLocalPort)


    def LocalPortGet(self):
        """

        Returns the (local) TCP port used by this client.

        The client will communicate with the server through a TCP network socket on
        this port and listen on it for incoming traffic.

        If the TCP port isn't explicitly set (yet), this will return a valid and unique
        TCP port number for within the scope of the ByteBlower port (e.g. 32687).

        Default value Valid unique client TCP port

        :return: int: The currently configured TCP port on this client.

        Example

        This example returns the port number on which this client connects to the
        Telnet server.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_LocalPortGet(self)


    def Open(self):
        """

        Starts the Telnet client and opens the session with the Telnet server.

        It will create a new TCP connection. The TCP statistics will be reset. If a
        Telnet session is already open, nothing is done.

        After calling this method, data may be sent to the server :meth:`Send` will be
        queued for transmission after this handshake.

        Bug

        When contacting a non-existing or unreachable Telnet server, this application
        has unexpected behavior. The :meth:`Open` method returns immediately and TCP
        moves to the 'active' status. After the timeout expires, TCP moves to the
        'finished' status instead of the 'timeOut' status. All the while, data may be
        sent using :meth:`Send`. This data is queued during the handshake, but it will
        not be sent.

        :raises: ByteBlower.Protocol.Unavailable - If the Telnet server address has not
                 been configured, this exception is thrown. Use :meth:`RemoteAddressSet`
                 to configure the Telnet server address.

        Example

        This command opens the Telnet session, which initiates the handshake of the
        underlying TCP session. It returns immediately.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_Open(self)


    def Send(self, inData):
        """

        Sends the provided to the Telnet server over the network..

        Data may be sent as soon as a connection is opened. Data sent during the TCP
        handshake will be queued to be sent immediately after it.

        Bug

        When contacting a non-existing or unreachable Telnet server, this method will
        not provide an error. When the TCP handshake fails (probably due to timeout),
        TCP will move (incorrectly) to finished after a while. None of the traffic sent
        at layer 5 will be received by the Telnet server.

        :param data: This string will be sent to the server for processing.

        :raises: ByteBlower.Protocol.InvalidAction - When no session is active, this
                 exception is thrown. Use :meth:`Open` to open the session.

        Example

        This command sends the provided data over the network towards the Telnet
        server.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_Send(self, inData)


    def Receive(self):
        """

        Reads data received over the Telnet session from the network and returns it.

        If this method is executed, all received data since the last time it was
        called is returned. If more data is still flowing in from the network, the rest
        of the data will be returned the next time the receive method is executed.

        Bug

        When contacting a non-existing or unreachable Telnet server, this method will
        not provide an error. When the TCP handshake fails (probably due to timeout),
        TCP will move (incorrectly) to finished after a while. None of the traffic sent
        at layer 5 will be received by the Telnet server.

        :return: The data received from the Telnet server.

        :raises: ByteBlower.Protocol.InvalidAction - When no session is active.
                 Use :meth:`Open` to open the session.

        Example

        This example shows the response received from the Telnet server after sending
        the 'uname -a' command.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_Receive(self)


    def Close(self):
        """

        Closes the Telnet session with the server and stops the Telnet client.

        The TCP session will be closed and reset, so a new session can be opened.

        If no Telnet session is open, nothing is done.

        Example

        This command closes the Telnet session if one is active.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_Close(self)


    def ConnectionStateGet(self):
        """

        Returns the current TCP connection state.

        :return: :class:`TCP ConnectionState`

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.TelnetClient_ConnectionStateGet(self)

TelnetClient_swigregister = _byteblower.TelnetClient_swigregister
TelnetClient_swigregister(TelnetClient)

class PhysicalInterface(AbstractObject):
    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PhysicalInterface, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PhysicalInterface, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetByteBlowerServer(self):
        return _byteblower.PhysicalInterface_GetByteBlowerServer(self)

    def IdGet(self):
        return _byteblower.PhysicalInterface_IdGet(self)

    def NameGet(self):
        return _byteblower.PhysicalInterface_NameGet(self)

    def TypeGet(self):
        return _byteblower.PhysicalInterface_TypeGet(self)

    def MacAddressGet(self):
        return _byteblower.PhysicalInterface_MacAddressGet(self)

    def ByteBlowerInterfaceGet(self):
        return _byteblower.PhysicalInterface_ByteBlowerInterfaceGet(self)

    def ByteBlowerInterfaceCountGet(self):
        return _byteblower.PhysicalInterface_ByteBlowerInterfaceCountGet(self)

    def LinkStatusGet(self):
        return _byteblower.PhysicalInterface_LinkStatusGet(self)

    def LinkTypeGet(self):
        return _byteblower.PhysicalInterface_LinkTypeGet(self)

    def VendorNameGet(self):
        return _byteblower.PhysicalInterface_VendorNameGet(self)

    def ProductNameGet(self):
        return _byteblower.PhysicalInterface_ProductNameGet(self)
PhysicalInterface_swigregister = _byteblower.PhysicalInterface_swigregister
PhysicalInterface_swigregister(PhysicalInterface)

class Layer2Configuration(AbstractObject):
    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Layer2Configuration, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Layer2Configuration, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def PortGet(self):
        return _byteblower.Layer2Configuration_PortGet(self)

    def AddressSet(self, inLayer2Address):
        return _byteblower.Layer2Configuration_AddressSet(self, inLayer2Address)

    def AddressGet(self):
        return _byteblower.Layer2Configuration_AddressGet(self)
Layer2Configuration_swigregister = _byteblower.Layer2Configuration_swigregister
Layer2Configuration_swigregister(Layer2Configuration)

EthernetEncoding_SNAP = _byteblower.EthernetEncoding_SNAP
EthernetEncoding_DIX = _byteblower.EthernetEncoding_DIX

def ConvertEthernetEncodingToString(inEthernetEncoding):
    return _byteblower.ConvertEthernetEncodingToString(inEthernetEncoding)
ConvertEthernetEncodingToString = _byteblower.ConvertEthernetEncodingToString

def ParseEthernetEncoding(inEthernetEncoding):
    return _byteblower.ParseEthernetEncoding(inEthernetEncoding)
ParseEthernetEncoding = _byteblower.ParseEthernetEncoding
class EthernetConfiguration(Layer2Configuration):
    """

    EthernetII provides an interface for the Ethernet configuration on a
    ByteBlower port.

    """

    __swig_setmethods__ = {}
    for _s in [Layer2Configuration]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EthernetConfiguration, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer2Configuration]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EthernetConfiguration, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def AddressSet(self, inMacAddress):
        return _byteblower.EthernetConfiguration_AddressSet(self, inMacAddress)

    def AddressGet(self):
        return _byteblower.EthernetConfiguration_AddressGet(self)

    def TypeGet(self):
        """

        Returns the layer 2 encoding scheme.

        :return: The layer 2 encoding scheme.

        Example

        This example returns the layer 2 encoding scheme.

        .. code-block:: python
           :emphasize-lines: 1

        	print(ethernetConf.TypeGet())

        """
        return _byteblower.EthernetConfiguration_TypeGet(self)


    def TypeSet(self, inEthernetEncoding):
        """

        Sets the layer 2 encoding scheme.

        :param encoding: Currently supported encodings are SNAP and DIX.

        Example

        This example sets the layer 2 encoding scheme.

        .. code-block:: python
           :emphasize-lines: 1

        	print(ethernetConf.TypeSet())


        """
        return _byteblower.EthernetConfiguration_TypeSet(self, inEthernetEncoding)


    def MacSet(self, inMacAddress):
        return _byteblower.EthernetConfiguration_MacSet(self, inMacAddress)

    def MacGet(self):
        return _byteblower.EthernetConfiguration_MacGet(self)
    if _newclass:
        IsValidMacAddress = staticmethod(_byteblower.EthernetConfiguration_IsValidMacAddress)
    else:
        IsValidMacAddress = _byteblower.EthernetConfiguration_IsValidMacAddress
EthernetConfiguration_swigregister = _byteblower.EthernetConfiguration_swigregister
EthernetConfiguration_swigregister(EthernetConfiguration)

def EthernetConfiguration_IsValidMacAddress(inMacAddress):
    return _byteblower.EthernetConfiguration_IsValidMacAddress(inMacAddress)
EthernetConfiguration_IsValidMacAddress = _byteblower.EthernetConfiguration_IsValidMacAddress

class VLANTag(Layer25Configuration):
    """

    Configure the VLAN tag on a ByteBlower Port.

    IEEE 802.1Q is the networking standard that supports Virtual LANs (VLANs) on an
    Ethernet network. The standard defines a system of VLAN tagging for Ethernet
    frames and the accompanying procedures to be used by bridges and switches in
    handling such frames

    802.1Q does not actually encapsulate the original frame. Instead, for Ethernet
    frames, it adds a 32-bit field between the source MAC address and the
    EtherType/Length fields of the original frame

    TPID
        Tag Protocol Identifier - 16bits

    TCI
        Tag Control Information - 16bits

    In the latter case the TCI consists of:

    PCP
        Priority Code Point - 3bits

    DEI
        Drop Eligible Indicator - 1bit

    VID
        VLAN Identifier - 12bits

    """

    __swig_setmethods__ = {}
    for _s in [Layer25Configuration]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, VLANTag, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer25Configuration]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, VLANTag, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ProtocolIDGet(self):
        """

        Get the VLAN Protocol ID (TPID)

        A 16-bit field specifying the VLAN Protocol ID used in the frames.

        IEEE 802.1AD specifies the VLAN C-TAG (customer tag) and S-TAG (service-provider
        tag). The C-TAG (0x8100) is used on the innermost VLAN tag, while the S-TAG
        (0x88a8) is used on all other VLAN tags.

        I.e. When a single VLAN is used on the *ByteBlowerPort*, the TPID will be
        0x8100. When VLAN stacking is used, the innermost VLAN tag (closest to the
        Ethernet payload) will use the C-TAG (0x8100) while all other VLAN tags use the
        S-TAG (0x88a8).

        :return: Returns the used Protocol ID (`TPID`) for this VLAN tag.

        Example

        Getting the vlan TPID of a ByteBlower port tagged with a single VLAN
        (0x8100 == 33024)


        .. code-block:: python
           :emphasize-lines: 1

        	print(vlanTag.ProtocolIDGet())


        """
        return _byteblower.VLANTag_ProtocolIDGet(self)


    def ProtocolIDSet(self, value):
        return _byteblower.VLANTag_ProtocolIDSet(self, value)

    def IDSet(self, inId):
        """

        Configure the VLAN ID.

        A 12-bit field specifying the VLAN to which the frame belongs. The hexadecimal
        values of 0x000 and 0xFFF are reserved. All other values may be used as VLAN
        identifiers, allowing up to 4094 VLANs

        :param id: Your VLAN ID

        Example
        Creating a VLAN tag on the your ByteBlower port

        .. code-block:: python
           :emphasize-lines: 1

        	vlanTag.IDSet(2)

        """
        return _byteblower.VLANTag_IDSet(self, inId)


    def IDGet(self):
        """

        Get the VLANID.

        A 12-bit field specifying the VLAN to which the frame belongs. The hexadecimal
        values of 0x000 and 0xFFF are reserved. All other values may be used as VLAN
        identifiers, allowing up to 40094 VLANs.

        Default value: 0

        :return: the configured VLAN ID installed on this ByteBlower port.

        Example

        Getting the vlanID of a ByteBlower port tagged with VLAN Id 107

        .. code-block:: python
           :emphasize-lines: 3

        	print(vlanTag.IDGet())
        	#returns 107

        """
        return _byteblower.VLANTag_IDGet(self)


    def PrioritySet(self, inPriority):
        """

        Set the VLAN Priority.

        A 3-bit field which refers to the IEEE 802.1p priority. It indicates the frame
        priority level. Values are from 0 (best effort) to 7 (highest); 1 represents
        the lowest priority. These values can be used to prioritize different classes
        of traffic (voice, video, data, etc.).

        :param priority: The priority you want to configure: a number between 0 and 7.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	vlanTag.PrioritySet(0)


        """
        return _byteblower.VLANTag_PrioritySet(self, inPriority)


    def PriorityGet(self):
        """

        Get the VLAN Priority.

        A 3-bit field which refers to the IEEE 802.1p priority. It indicates the frame
        priority level. Values are from 0 (best effort) to 7 (highest); 1 represents
        the lowest priority. These values can be used to prioritize different classes of
        traffic (voice, video, data, etc.).

        Default value: 0

        :return:  Returns the configured priority of the VLAN protocol

        Example

        Getting the vlanID of a ByteBlower port tagged with VLAN Id 107

        .. code-block:: python
           :emphasize-lines: 3

        	print(vlanTag.PriorityGet())

        """
        return _byteblower.VLANTag_PriorityGet(self)


    def DropEligibleSet(self, value):
        """

        Enable/Disable the Drop Eligible Indicator.

        A 1-bit field. (formerly CFI) May be used separately or in conjunction with
        PCP to indicate frames eligible to be dropped in the presence of congestion.

        :param enable: bool -
                       True will enable the Drop Eligible Indicator
                       False will disable the Drop Eligible Indicator.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	vlanTag.DropEligibleSet(True)

        """
        return _byteblower.VLANTag_DropEligibleSet(self, value)


    def DropEligibleGet(self):
        """

        Returns the status of the Drop Eligible Indicator.

        A 1-bit field. (formerly CFI) May be used separately or in conjunction with PCP
        to indicate frames eligible to be dropped in the presence of congestion.

        Default value: Disabled

        :return: True if Drop Eligible Indicator is enabled, False if disabled.

        """
        return _byteblower.VLANTag_DropEligibleGet(self)

VLANTag_swigregister = _byteblower.VLANTag_swigregister
VLANTag_swigregister(VLANTag)

class PPPAuthProtocol(AbstractObject):
    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PPPAuthProtocol, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PPPAuthProtocol, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_PPPAuthProtocol
    __del__ = lambda self: None
PPPAuthProtocol_swigregister = _byteblower.PPPAuthProtocol_swigregister
PPPAuthProtocol_swigregister(PPPAuthProtocol)

class PAPProtocol(PPPAuthProtocol):
    """

    Represents the Password Authentication Protocol  

    PPP defines an extensible Link Control Protocol, which allows negotiation of an
    Authentication Protocol for authenticating its peer before allowing Network 
    Layer protocols to transmit over the link.  

    This class provides the Password Authentication protocol as described per 
    :rfc:`1334`, section 2  

    The Password Authentication Protocol (PAP) provides a simple method for the
    peer to establish its identity using a 2-way handshake. This is done only upon
    initial link establishment.  

    After the Link Establishment phase is complete, an Id/Password pair is 
    repeatedly sent by the peer to the authenticator until authentication is
    acknowledged or the connection is terminated.  

    PAP is not a strong authentication method. Passwords are sent over the circuit 
    " *in the clear* ", and there is no protection from playback or repeated 
    trial and error attacks. The peer is in control of the frequency and timing of
    the attempts.  

    By default, authentication is not mandatory. If authentication of the link is 
    desired, an implementation MUST specify the Authentication-Protocol 
    Configuration Option during Link Establishment phase.  

    .. versionadded:: 2.5.0  

    """

    __swig_setmethods__ = {}
    for _s in [PPPAuthProtocol]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PAPProtocol, name, value)
    __swig_getmethods__ = {}
    for _s in [PPPAuthProtocol]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PAPProtocol, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetPPPProtocol(self, *args):
        return _byteblower.PAPProtocol_GetPPPProtocol(self, *args)

    def PeerIDGet(self):
        """

        Returns the configured Peer-ID.  

        :return:  peerID  

        Example

        .. code-block:: python

           # TODO

        """
        return _byteblower.PAPProtocol_PeerIDGet(self)


    def PeerIDSet(self, inUserId):
        """

        Configures the Peer-ID on the Password authentication Protocol ( PAP )  

        :param peerID: The new Peer-ID  

        .. code-block:: python

           # TODO

        """
        return _byteblower.PAPProtocol_PeerIDSet(self, inUserId)


    def PasswordGet(self):
        """

        Returns the configured password.  

        :return: password  
        :rtype: str


        .. code-block:: python

           # TODO

        """
        return _byteblower.PAPProtocol_PasswordGet(self)


    def PasswordSet(self, inPassword):
        """

        Configures the password on the Password authentication Protocol ( PAP )

        The password will be transmitted *plaintext* over the wire.  

        :param password: The password for the given Peer-ID  
        :type password: str


        .. code-block:: python

           # TODO

        """
        return _byteblower.PAPProtocol_PasswordSet(self, inPassword)

PAPProtocol_swigregister = _byteblower.PAPProtocol_swigregister
PAPProtocol_swigregister(PAPProtocol)

class CHAPProtocol(PPPAuthProtocol):
    """

    Represents the Challenge-Handshake Authentication Protocol  

    PPP defines an extensible Link Control Protocol, which allows negotiation of 
    an Authentication Protocol for authenticating its peer before allowing Network
    Layer protocols to transmit over the link.  

    This class provides the Password Authentication protocol as described per 
    :rfc:1334, section 3  

    The Challenge-Handshake Authentication Protocol (CHAP) is used to periodically
    verify the identity of the peer using a 3-way handshake. This is done upon 
    initial link establishment, and MAY be repeated anytime after the link has been
    established.  

    After the Link Establishment phase is complete, the authenticator sends a 
    "challenge" message to the peer. The peer responds with a value calculated
    using a "one-way hash" function. The authenticator checks the response 
    against its own calculation of the expected hash value. If the values match, 
    the authentication is acknowledged, otherwise the connection SHOULD be 
    terminated.  

    CHAP provides protection against playback attack through the use of an 
    incrementally changing identifier and a variable challenge value. The use of 
    repeated challenges is intended to limit the time of exposure to any single 
    attack. The authenticator is in control of the frequency and timing of the 
    challenges.  

    This authentication method depends upon a "*secret*" known only to the 
    authenticator and that peer. The secret is not sent over the link. This method
    is most likely used where the same secret is easily accessed from both ends of 
    the link.  

    By default, authentication is not mandatory. If authentication of the link is 
    desired, an implementation MUST specify the Authentication-Protocol 
    Configuration Option during Link Establishment phase.  

    .. versionadded:: 2.5.0

    """

    __swig_setmethods__ = {}
    for _s in [PPPAuthProtocol]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CHAPProtocol, name, value)
    __swig_getmethods__ = {}
    for _s in [PPPAuthProtocol]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CHAPProtocol, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetPPPProtocol(self, *args):
        return _byteblower.CHAPProtocol_GetPPPProtocol(self, *args)

    def SecretSet(self, secret):
        """

        Configures the Secret on the Challenge Handshake Authentication Protocol (CHAP)

        :param secret: The secret for authenticating to the PPP server.  

        .. code-block:: python

           # TODO

        """
        return _byteblower.CHAPProtocol_SecretSet(self, secret)


    def SecretGet(self):
        """

        Returns the configured Secret.  

        :return: Secret value  

        .. code-block:: python

           # TODO

        """
        return _byteblower.CHAPProtocol_SecretGet(self)

CHAPProtocol_swigregister = _byteblower.CHAPProtocol_swigregister
CHAPProtocol_swigregister(CHAPProtocol)

class PPPNetworkControlProtocol(AbstractObject):
    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PPPNetworkControlProtocol, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PPPNetworkControlProtocol, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_PPPNetworkControlProtocol
    __del__ = lambda self: None
PPPNetworkControlProtocol_swigregister = _byteblower.PPPNetworkControlProtocol_swigregister
PPPNetworkControlProtocol_swigregister(PPPNetworkControlProtocol)

class IPv4CPProtocol(PPPNetworkControlProtocol):
    """

    Internet Protocol Control Protocol.  

    Internet Protocol Control Protocol (IPCP) is a network control protocol for 
    establishing and configuring Internet Protocol over a Point-to-Point Protocol
    link. IPCP is responsible for configuring, enabling, and disabling the IP 
    protocol modules on both ends of the point-to-point link. IPCP uses the same
    packet exchange mechanism as the Link Control Protocol.

    The implementation is conform :rfc:1332  

    .. note:: The RFC deprecated the `IP-Addresses` configuration option. 
              ByteBlower does not provide the (optional) backward compatibility for
              this option.  
    .. note:: IP compression is not supported.  

    .. versionadded:: 2.5.0  


    """

    __swig_setmethods__ = {}
    for _s in [PPPNetworkControlProtocol]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPv4CPProtocol, name, value)
    __swig_getmethods__ = {}
    for _s in [PPPNetworkControlProtocol]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IPv4CPProtocol, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IpAddressGet(self):
        """

        Returns local the IPv4 address.  

        This method returns the IP address to be used at the local end of the link. 
        Before the IPCP protocol negotiated the IP address, this method will return the
        value configured with :meth:`IpAddressSet`. After IP address negotiation with
        the remote peer, the method will return the IP address negotiated with the 
        remote peer.  

        The latter will be either:

        - the same as the value configured with :meth:`IpAddressSet`

          - if the remote peer accepted that address.

        - the address imposed by the remote peer:
          - if we requested that the peer provides the address

          - when the remote peer did not accept the requested IP address.

        :return: The IP address to be used by the local peer.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4CPProtocol_IpAddressGet(self)


    def IpAddressSet(self, inIPAddress):
        """

        Configures the IPv4 address to be used at the local end of the link.  

        During IP address negotiation, the given address will be proposed to the remote
        end of the link.  

        :param ipAddress: The IPv4 address to be used during negotiation at the local 
                          peer.  

        .. note:: The IPv4 address '0.0.0.0' has a special meaning: 
                  This will request the remote peer to provide an IP address. 
                  See also :meth:`IpAddressPeerProvided` for a convenience method.  

        :raises: BadIPv4Address - When an incorrect IPv4 address string was provided.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4CPProtocol_IpAddressSet(self, inIPAddress)


    def IpAddressRemoteGet(self):
        """

        Returns the IP address of the remote peer.  

        This method will return the IP address which has been requested by the remote
        peer during (the last) address negotiation.  

        :return: IP address of the remote peer of the last address negotiation. 
                 '0.0.0.0' if no negotiation took place yet.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4CPProtocol_IpAddressRemoteGet(self)


    def IpAddressPeerProvided(self):
        """

        Request the peer to provide an IP address.  

        During IP address negotiation, we will request to peer to provide an IP 
        address.

        ..note:: This method call will have the same effect as calling 
                 :meth:`IpAddressSet` with *<ipAddress>* set to '0.0.0.0'.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4CPProtocol_IpAddressPeerProvided(self)


    def Open(self):
        """

        Perform an administrative open on the IPCP protocol.  

        This event indicates that the link is administratively available for traffic.

        In the opened state, the protocol will come up when the PPP session is 
        established. When the PPP/IPCP session was already established, the IPCP will 
        start negotiation.  

        See also :rfc:1661, section 4.3 for detailed information about the Open event.  

        """
        return _byteblower.IPv4CPProtocol_Open(self)


    def Close(self):
        """

        Perform an administrative close on the IPCP protocol.  

        This event indicates that the link is not available for traffic.  

        In the closed state, the protocol will not come up when the PPP session is 
        established. When the PPP/IPCP session was already established, the IPCP 
        session will properly terminate the network layer.   

        See also :rfc:1661, section 4.3 for detailed information about the Close event.

        """
        return _byteblower.IPv4CPProtocol_Close(self)

IPv4CPProtocol_swigregister = _byteblower.IPv4CPProtocol_swigregister
IPv4CPProtocol_swigregister(IPv4CPProtocol)

class IPv6CPProtocol(PPPNetworkControlProtocol):
    """

    IP version 6 over PPPoE.  

    IPv6 Control Protocol (IPv6CP) is a network control protocol for establishing 
    and configuring the IPv6 (see also Layer3.IPv6) over PPP . It forms IPv6 
    link-local addresses on PPP links. The IPv6 Control Protocol (IPV6CP) is 
    responsible for configuring, enabling, and disabling the IPv6 protocol modules
    on both ends of the point-to-point link. IPV6CP uses the same packet exchange
    mechanism as the Link Control Protocol (LCP).  

    The implementation is conform :rfc:2472  

    .. versionadded:: 2.5.0  

    """

    __swig_setmethods__ = {}
    for _s in [PPPNetworkControlProtocol]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPv6CPProtocol, name, value)
    __swig_getmethods__ = {}
    for _s in [PPPNetworkControlProtocol]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IPv6CPProtocol, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def InterfaceIdentifierGet(self):
        """

        Returns the local IPv6 interface identifier.  

        This method returns the IPv6 interface identifier to be used at the local end 
        of the link. The initial value is based on the local MAC address (from 
        :meth:`.EthernetConfiguration.MacGet`).  

        After IPv6 interface identifier negotiation with the remote peer, the method 
        will return the IPv6 interface identifier negotiated with the remote peer.  

        The latter will be either:

        - the initial value if the remote peer accepted that address.
        - the address imposed by the remote peer when the remote peer did not accept 
          the requested address.

        :return: The IPv6 interface identifier to be used by the local peer.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv6CPProtocol_InterfaceIdentifierGet(self)


    def InterfaceIdentifierRemoteGet(self):
        """

        Returns the IPv6 interface identifier of the remote peer.  

        This method will return the IPv6 interface identifier which has been requested 
        by the remote peer during (the last) address negotiation.  

        :return: IPv6 interface identifier of the remote peer of the last address 
                 negotiation.  '00:00:00:00:00:00:00:00' if no negotiation took place 
                 yet.  

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv6CPProtocol_InterfaceIdentifierRemoteGet(self)


    def Open(self):
        """

        Perform an administrative open on the IPv6CP protocol.  

        This event indicates that the link is administratively available for traffic.  

        In the opened state, the protocol will come up when the PPP session is 
        established. When the PPP/IPv6CP session was already established, the IPv6CP 
        will start negotiation.  

        See also :rfc:1661, section 4.3 for detailed information about the Open event.

        """
        return _byteblower.IPv6CPProtocol_Open(self)


    def Close(self):
        """

        Perform an administrative close on the IPv6CP protocol.  

        This event indicates that the link is not available for traffic.  

        In the closed state, the protocol will not come up when the PPP session is 
        established. When the PPP/IPv6CP session was already established, the IPv6CP 
        session will properly terminate the network layer.  

        See also :rfc:1661, section 4.3 for detailed information about the Close event.  

        """
        return _byteblower.IPv6CPProtocol_Close(self)

IPv6CPProtocol_swigregister = _byteblower.IPv6CPProtocol_swigregister
IPv6CPProtocol_swigregister(IPv6CPProtocol)

class PPPProtocol(AbstractObject):
    """

    The Point-to-Point Protocol (PPP) provides a standard method for transporting 
    multi-protocol datagrams over point-to-point links. PPP is comprised of three
    main components:  

    1.  A method for encapsulating multi-protocol datagrams.  
    2.  A Link Control Protocol (LCP) for establishing, configuring, and testing the data-link connection.   
    3.  A family of Network Control Protocols (NCPs) for establishing and configuring different network-layer protocols.  

    The implementation is conform :rfc:`1661`.  

    .. versionadded:: 2.5.0  


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PPPProtocol, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PPPProtocol, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PortGet(self, *args):
        return _byteblower.PPPProtocol_PortGet(self, *args)

    def AuthProtocolPapAdd(self):
        """

        This method will add the Password Authentication Protocol.  

        :return: :class:`.PAPProtocol`

        """
        return _byteblower.PPPProtocol_AuthProtocolPapAdd(self)


    def AuthProtocolPapGet(self):
        """

        This method will return the current configured Password Authentication Protocols.  

        :return: :class:`PAPProtocolList`

        """
        return _byteblower.PPPProtocol_AuthProtocolPapGet(self)


    def AuthProtocolChapAdd(self):
        """

        This method will add the Challenge-handshake Authentication Protocol.

        :return: :class:`.CHAPProtocol`

        """
        return _byteblower.PPPProtocol_AuthProtocolChapAdd(self)


    def AuthProtocolChapGet(self):
        """

        This method will return the current configured Challenge-Handshake Authentication Protocols.

        :return: :class:`CHAPProtocolList`

        """
        return _byteblower.PPPProtocol_AuthProtocolChapGet(self)


    def NcpIpcpAdd(self):
        """

        This method will add support for an IPv6 Control Protocol.  

        IPCP is the Internet Protocol Control Protocol.  

        :return: The IPCP NCP object is returned. The object types is 
                 Layer2.Ppp.NetworkControl.Ipcp.  

        Example

        .. code-block:: python
           :caption: Adding IPCP as Network Control Protocol  

           # TODO


        """
        return _byteblower.PPPProtocol_NcpIpcpAdd(self)


    def NcpIpcpGet(self):
        """

        This method will return the current configured Internet Protocol Control Protocols (IPCP).  

        :return: :class:`.IPv4CPProtocol`

        Example

        .. code-block:: python

           # TODO

        """
        return _byteblower.PPPProtocol_NcpIpcpGet(self)


    def NcpIpv6cpAdd(self):
        """

        This method will add support for an IPv4 Control Protocol.  

        IPv6CP is the Internet Protocol Control Protocol for IPv6.  

        :return: :class:`.IPv6CPProtocol`

        Example

        .. code-block:: python
           :caption: Adding IPv6CP as Network Control Protocol  

           # TODO

        """
        return _byteblower.PPPProtocol_NcpIpv6cpAdd(self)


    def NcpIpv6cpGet(self):
        """

        This method will return the current configured IPv6 Control Protocols (IPv6CP).  

        :return: :class:`.IPv6CPProtocol`

        .. code-block:: python

           # TODO

        """
        return _byteblower.PPPProtocol_NcpIpv6cpGet(self)

PPPProtocol_swigregister = _byteblower.PPPProtocol_swigregister
PPPProtocol_swigregister(PPPProtocol)

PPPoEStatus_Initial = _byteblower.PPPoEStatus_Initial
PPPoEStatus_Discovering = _byteblower.PPPoEStatus_Discovering
PPPoEStatus_Requesting = _byteblower.PPPoEStatus_Requesting
PPPoEStatus_SessionActive = _byteblower.PPPoEStatus_SessionActive
PPPoEStatus_Terminated = _byteblower.PPPoEStatus_Terminated

def ConvertPPPoEStatusToString(inPPPoEStatus):
    return _byteblower.ConvertPPPoEStatusToString(inPPPoEStatus)
ConvertPPPoEStatusToString = _byteblower.ConvertPPPoEStatusToString
class PPPoEClient(Layer25Configuration):
    """

    A PPPoE client which allows you to setup Layer3 connectivity.  

    PPP over Ethernet (PPPoE) provides the ability to connect a network of hosts 
    over a simple bridging access device to a remote Access Concentrator.  

    The client implements the PPPoE protocol as per :rfc:`2516`.  

    The associated PPP Protocol has support for multiple authentication protocols.
    Layer3 connectivity includes IPv4 and IPv6 .  

    .. versionadded:: 2.5.0  


    """

    __swig_setmethods__ = {}
    for _s in [Layer25Configuration]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PPPoEClient, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer25Configuration]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PPPoEClient, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PppGet(self):
        """

        Returns the associated PPP Protocol object.  

        Returns the PPP ( Point-to-Point ) Protocol which is transmitted over Ethernet 
        ( PPPoE ). Through this object, you can configure the AuthProtocol. 

        :return: :class:`.PPPProtocol`

        Example

        .. code-block:: python

           # TODO


        """
        return _byteblower.PPPoEClient_PppGet(self)


    def ServiceNameSet(self, inServiceName):
        """

        This method will set the Requested Service Name for the PPPoE client.  

        :param serviceName: PPPoE Service Name which the client requests.
        :type serviceName: str

        Example

        .. code-block:: python

           # TODO

        """
        return _byteblower.PPPoEClient_ServiceNameSet(self, inServiceName)


    def ServiceNameGet(self):
        """

        This method will return the Requested Service Name for the PPPoE client.  

        :return: PPPoE Service Name which the client requests.  
        :rtype: str


        .. code-block:: python

           # TODO

        """
        return _byteblower.PPPoEClient_ServiceNameGet(self)


    def SessionIdGet(self):
        """

        This method will return the PPPoE SessionID of the last started PPPoE Session. 

        :return: False if No session started yet, else the PPPoE SessionID of the last 
                 started session.  

        """
        return _byteblower.PPPoEClient_SessionIdGet(self)


    def Start(self):
        """

        This will Start the PPPoE client.  

        This method will start the PPPoE session, setup PPP, authenticate using the
        configured authentication protocol and setup the currently configured network
        control protocols.  

        :raises: SessionUnavailable - When something unexpectedly happened during PPPoE
                 session initiation.  

        :raises: LinkEstablishmentTimeout - When PPP network layer was not configured
                 within reasonable timeout.  

        :return: PPPoE Session ID  


        .. code-block:: python

           # TODO

        """
        return _byteblower.PPPoEClient_Start(self)


    def StartAsync(self):
        """

        Starts the PPPoE client.  

        This call will initiate the start of the PPPoE client but will not wait for the
        result.

        """
        return _byteblower.PPPoEClient_StartAsync(self)


    def Terminate(self):
        """

        This will Terminate the PPPoE client.  

        Termination will properly terminate all PPPoE and PPP related protocols, from 
        higher-layers to lower-layers, starting from the network control protocol 
        (i.e. IPCP  or IPv6CP ).  

        """
        return _byteblower.PPPoEClient_Terminate(self)


    def StatusGet(self):
        """

        Returns the current status of the PPPoE connection.  

        Possible states are: 

        Initial
            PPPoE not yet started  

        Discovering
            PPPoE discovery message sent  

        Requesting
            PPPoE request sent  

        SessionActive
            PPPoE session is active  

        Terminated
            PPPoE session has been terminated  

        :return: Current PPPoE Status  

        Example

        .. code-block:: python

           # TODO


        """
        return _byteblower.PPPoEClient_StatusGet(self)


    def ServerGet(self):
        return _byteblower.PPPoEClient_ServerGet(self)
PPPoEClient_swigregister = _byteblower.PPPoEClient_swigregister
PPPoEClient_swigregister(PPPoEClient)

class PAPProtocolList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PAPProtocolList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PAPProtocolList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.PAPProtocolList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.PAPProtocolList___nonzero__(self)

    def __bool__(self):
        return _byteblower.PAPProtocolList___bool__(self)

    def __len__(self):
        return _byteblower.PAPProtocolList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.PAPProtocolList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.PAPProtocolList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.PAPProtocolList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.PAPProtocolList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.PAPProtocolList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.PAPProtocolList___setitem__(self, *args)

    def pop(self):
        return _byteblower.PAPProtocolList_pop(self)

    def append(self, x):
        return _byteblower.PAPProtocolList_append(self, x)

    def empty(self):
        return _byteblower.PAPProtocolList_empty(self)

    def size(self):
        return _byteblower.PAPProtocolList_size(self)

    def swap(self, v):
        return _byteblower.PAPProtocolList_swap(self, v)

    def begin(self):
        return _byteblower.PAPProtocolList_begin(self)

    def end(self):
        return _byteblower.PAPProtocolList_end(self)

    def rbegin(self):
        return _byteblower.PAPProtocolList_rbegin(self)

    def rend(self):
        return _byteblower.PAPProtocolList_rend(self)

    def clear(self):
        return _byteblower.PAPProtocolList_clear(self)

    def get_allocator(self):
        return _byteblower.PAPProtocolList_get_allocator(self)

    def pop_back(self):
        return _byteblower.PAPProtocolList_pop_back(self)

    def erase(self, *args):
        return _byteblower.PAPProtocolList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_PAPProtocolList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.PAPProtocolList_push_back(self, x)

    def front(self):
        return _byteblower.PAPProtocolList_front(self)

    def back(self):
        return _byteblower.PAPProtocolList_back(self)

    def assign(self, n, x):
        return _byteblower.PAPProtocolList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.PAPProtocolList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.PAPProtocolList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.PAPProtocolList_reserve(self, n)

    def capacity(self):
        return _byteblower.PAPProtocolList_capacity(self)
    __swig_destroy__ = _byteblower.delete_PAPProtocolList
    __del__ = lambda self: None
PAPProtocolList_swigregister = _byteblower.PAPProtocolList_swigregister
PAPProtocolList_swigregister(PAPProtocolList)

class CHAPProtocolList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CHAPProtocolList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CHAPProtocolList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.CHAPProtocolList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.CHAPProtocolList___nonzero__(self)

    def __bool__(self):
        return _byteblower.CHAPProtocolList___bool__(self)

    def __len__(self):
        return _byteblower.CHAPProtocolList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.CHAPProtocolList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.CHAPProtocolList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.CHAPProtocolList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.CHAPProtocolList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.CHAPProtocolList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.CHAPProtocolList___setitem__(self, *args)

    def pop(self):
        return _byteblower.CHAPProtocolList_pop(self)

    def append(self, x):
        return _byteblower.CHAPProtocolList_append(self, x)

    def empty(self):
        return _byteblower.CHAPProtocolList_empty(self)

    def size(self):
        return _byteblower.CHAPProtocolList_size(self)

    def swap(self, v):
        return _byteblower.CHAPProtocolList_swap(self, v)

    def begin(self):
        return _byteblower.CHAPProtocolList_begin(self)

    def end(self):
        return _byteblower.CHAPProtocolList_end(self)

    def rbegin(self):
        return _byteblower.CHAPProtocolList_rbegin(self)

    def rend(self):
        return _byteblower.CHAPProtocolList_rend(self)

    def clear(self):
        return _byteblower.CHAPProtocolList_clear(self)

    def get_allocator(self):
        return _byteblower.CHAPProtocolList_get_allocator(self)

    def pop_back(self):
        return _byteblower.CHAPProtocolList_pop_back(self)

    def erase(self, *args):
        return _byteblower.CHAPProtocolList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_CHAPProtocolList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.CHAPProtocolList_push_back(self, x)

    def front(self):
        return _byteblower.CHAPProtocolList_front(self)

    def back(self):
        return _byteblower.CHAPProtocolList_back(self)

    def assign(self, n, x):
        return _byteblower.CHAPProtocolList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.CHAPProtocolList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.CHAPProtocolList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.CHAPProtocolList_reserve(self, n)

    def capacity(self):
        return _byteblower.CHAPProtocolList_capacity(self)
    __swig_destroy__ = _byteblower.delete_CHAPProtocolList
    __del__ = lambda self: None
CHAPProtocolList_swigregister = _byteblower.CHAPProtocolList_swigregister
CHAPProtocolList_swigregister(CHAPProtocolList)

class IPCPProtocolList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPCPProtocolList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPCPProtocolList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.IPCPProtocolList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.IPCPProtocolList___nonzero__(self)

    def __bool__(self):
        return _byteblower.IPCPProtocolList___bool__(self)

    def __len__(self):
        return _byteblower.IPCPProtocolList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.IPCPProtocolList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.IPCPProtocolList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.IPCPProtocolList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.IPCPProtocolList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.IPCPProtocolList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.IPCPProtocolList___setitem__(self, *args)

    def pop(self):
        return _byteblower.IPCPProtocolList_pop(self)

    def append(self, x):
        return _byteblower.IPCPProtocolList_append(self, x)

    def empty(self):
        return _byteblower.IPCPProtocolList_empty(self)

    def size(self):
        return _byteblower.IPCPProtocolList_size(self)

    def swap(self, v):
        return _byteblower.IPCPProtocolList_swap(self, v)

    def begin(self):
        return _byteblower.IPCPProtocolList_begin(self)

    def end(self):
        return _byteblower.IPCPProtocolList_end(self)

    def rbegin(self):
        return _byteblower.IPCPProtocolList_rbegin(self)

    def rend(self):
        return _byteblower.IPCPProtocolList_rend(self)

    def clear(self):
        return _byteblower.IPCPProtocolList_clear(self)

    def get_allocator(self):
        return _byteblower.IPCPProtocolList_get_allocator(self)

    def pop_back(self):
        return _byteblower.IPCPProtocolList_pop_back(self)

    def erase(self, *args):
        return _byteblower.IPCPProtocolList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_IPCPProtocolList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.IPCPProtocolList_push_back(self, x)

    def front(self):
        return _byteblower.IPCPProtocolList_front(self)

    def back(self):
        return _byteblower.IPCPProtocolList_back(self)

    def assign(self, n, x):
        return _byteblower.IPCPProtocolList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.IPCPProtocolList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.IPCPProtocolList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.IPCPProtocolList_reserve(self, n)

    def capacity(self):
        return _byteblower.IPCPProtocolList_capacity(self)
    __swig_destroy__ = _byteblower.delete_IPCPProtocolList
    __del__ = lambda self: None
IPCPProtocolList_swigregister = _byteblower.IPCPProtocolList_swigregister
IPCPProtocolList_swigregister(IPCPProtocolList)

class IPv6CPProtocolList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPv6CPProtocolList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IPv6CPProtocolList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.IPv6CPProtocolList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.IPv6CPProtocolList___nonzero__(self)

    def __bool__(self):
        return _byteblower.IPv6CPProtocolList___bool__(self)

    def __len__(self):
        return _byteblower.IPv6CPProtocolList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.IPv6CPProtocolList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.IPv6CPProtocolList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.IPv6CPProtocolList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.IPv6CPProtocolList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.IPv6CPProtocolList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.IPv6CPProtocolList___setitem__(self, *args)

    def pop(self):
        return _byteblower.IPv6CPProtocolList_pop(self)

    def append(self, x):
        return _byteblower.IPv6CPProtocolList_append(self, x)

    def empty(self):
        return _byteblower.IPv6CPProtocolList_empty(self)

    def size(self):
        return _byteblower.IPv6CPProtocolList_size(self)

    def swap(self, v):
        return _byteblower.IPv6CPProtocolList_swap(self, v)

    def begin(self):
        return _byteblower.IPv6CPProtocolList_begin(self)

    def end(self):
        return _byteblower.IPv6CPProtocolList_end(self)

    def rbegin(self):
        return _byteblower.IPv6CPProtocolList_rbegin(self)

    def rend(self):
        return _byteblower.IPv6CPProtocolList_rend(self)

    def clear(self):
        return _byteblower.IPv6CPProtocolList_clear(self)

    def get_allocator(self):
        return _byteblower.IPv6CPProtocolList_get_allocator(self)

    def pop_back(self):
        return _byteblower.IPv6CPProtocolList_pop_back(self)

    def erase(self, *args):
        return _byteblower.IPv6CPProtocolList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_IPv6CPProtocolList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.IPv6CPProtocolList_push_back(self, x)

    def front(self):
        return _byteblower.IPv6CPProtocolList_front(self)

    def back(self):
        return _byteblower.IPv6CPProtocolList_back(self)

    def assign(self, n, x):
        return _byteblower.IPv6CPProtocolList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.IPv6CPProtocolList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.IPv6CPProtocolList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.IPv6CPProtocolList_reserve(self, n)

    def capacity(self):
        return _byteblower.IPv6CPProtocolList_capacity(self)
    __swig_destroy__ = _byteblower.delete_IPv6CPProtocolList
    __del__ = lambda self: None
IPv6CPProtocolList_swigregister = _byteblower.IPv6CPProtocolList_swigregister
IPv6CPProtocolList_swigregister(IPv6CPProtocolList)

class Layer3Configuration(AbstractObject):
    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Layer3Configuration, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Layer3Configuration, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PortGet(self):
        return _byteblower.Layer3Configuration_PortGet(self)
    if _newclass:
        IsValidLayer3Address = staticmethod(_byteblower.Layer3Configuration_IsValidLayer3Address)
    else:
        IsValidLayer3Address = _byteblower.Layer3Configuration_IsValidLayer3Address
Layer3Configuration_swigregister = _byteblower.Layer3Configuration_swigregister
Layer3Configuration_swigregister(Layer3Configuration)

def Layer3Configuration_IsValidLayer3Address(inAddress):
    return _byteblower.Layer3Configuration_IsValidLayer3Address(inAddress)
Layer3Configuration_IsValidLayer3Address = _byteblower.Layer3Configuration_IsValidLayer3Address

class IPv4Configuration(Layer3Configuration):
    """

    Provides an interface for the IPv4 configuration on a ByteBlower port.

    """

    __swig_setmethods__ = {}
    for _s in [Layer3Configuration]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPv4Configuration, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer3Configuration]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IPv4Configuration, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ServerGet(self):
        return _byteblower.IPv4Configuration_ServerGet(self)

    def GetByteBlowerPort(self):
        return _byteblower.IPv4Configuration_GetByteBlowerPort(self)

    def IpSet(self, inIPv4Address):
        """

        Sets the IP address of the ByteBlower port.

        :param ipAddress: IP address string. You can use "slash notation"
                          (e.g. 10.1.1.2/24) to simulateously specify the address and
                          netmask.

        Example

        This example sets the IP address on a ByteBlower port.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_IpSet(self, inIPv4Address)


    def IpGet(self):
        """

        Retrieves the Ip address of the ByteBlower port.

        :return: The IP address of the ByteBlower port.

        Example

        This example returns the IP address on a ByteBlower port.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_IpGet(self)


    def GatewaySet(self, inGateway):
        """

        Sets the default gateway of the ByteBlower port.

        :param gateway: Gateway address string

        Example

        This example sets the gateway of the ByteBlower port.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_GatewaySet(self, inGateway)


    def GatewayGet(self):
        """

        Returns the default gateway of the ByteBlower port.

        :return:  Default gateway of the ByteBlower port.

        Example

        This example gets the gateway of the ByteBlower port.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_GatewayGet(self)


    def NetmaskSet(self, inNetMask):
        """

        Sets the netmask of the ByteBlower port.

        :param netmask: Netmask address string

        Example

        This example sets the netmask of the ByteBlower port.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_NetmaskSet(self, inNetMask)


    def NetmaskGet(self):
        """

        Gets the netmask of the ByteBlower port.

        :return:  Netmask of the ByteBlower port.

        Example

        This example gets the netmask of the ByteBlower port.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_NetmaskGet(self)


    def ProtocolArp(self, inIPAddress):
        """

        Performs MAC address resolution for a given IP address.

        Sends an ARP request for the specified IP address, and returns the answer if an
        answer is  received.

        .. note:: This call does not make use of the an ARP cache. If you are only
                  interested in resolving an IP then please use :meth:`Resolve` which
                  also makes use of the ARP cache.

        :param ipAddress: IPv4 address to resolve

        :return: Resolved MAC address

        :raises: InvalidDestination - When an unusable IP address was given.

        :raises: ARPTimeout - When the address could not be resolved.

        Example

        This example gets the MAC address for an IP address.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ProtocolArp(self, inIPAddress)


    def ProtocolArpAsync(self, inIPAddress):
        """

        Starts MAC address resolution for a given IP address.

        .. versionadded:: 2.2.0

        Sends an ARP request for the specified IP address, and returns immediately. To
        obtain the results of the ARP resolution, you can use :meth:`ProtocolArp`.

        .. note:: This call does not make use of the an ARP cache. If you are only
                  interested in resolving an IP then please use :meth:`ResolveAsync`
                  which also makes use of the ARP cache.

        :param ipAddress: IPv4 address to resolve

        :raises: InvalidDestination - When an unusable IP address was given.

        Example

        This example triggers ARP resolution gets the MAC address for an IP address.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ProtocolArpAsync(self, inIPAddress)


    def ProtocolGratuitousArpRequest(self):
        """

        Sends a Gratuitous ARP (GARP) request.

        .. versionadded:: 2.5.0

        The GARP Request can be used for host presence announcement. This way, other
        devices on the network can learn the Layer2 and Layer3 information of the host.
        This GARP Request is preferred over the GARP Reply

        Example

        This example sends a Gratuitous ARP request

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ProtocolGratuitousArpRequest(self)


    def ProtocolGratuitousArpReply(self):
        """

        Sends a Gratuitous ARP (GARP) request.

        .. versionadded:: 2.5.0

        The GARP Request can be used for host presence announcement. This way, other
        devices on the network can learn the Layer2 and Layer3 information of the host

        Example

        This example sends a Gratuitous ARP request

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ProtocolGratuitousArpReply(self)


    def Resolve(self, inIPAddress):
        """

        Resolve the MAC address for a given IP address.

        The ByteBlower server stores an ARP cache per ByteBlower port. Resolving the IP
        for a port will search the ARP cache first. If no entry was found then an
        actual ARP request is performed. An entry in the ARP cache remains valid for
        120 seconds.

        :param ipAddress: IPv4 address to resolve

        :return: Resolved MAC address

        :raises: InvalidDestination - When an unusable IP address was given.

        :raises: ARPTimeout - When the address could not be resolved.

        Example

        This example gets the MAC address for an IP address.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_Resolve(self, inIPAddress)


    def ResolveAsync(self, inIPAddress):
        """

        Start MAC address resolution for a given destination IP address.

        .. versionadded:: 2.2.0

        The ByteBlower server stores an ARP cache per ByteBlower port. Resolving the IP
        for a port will search the ARP cache first. If no entry was found then an
        actual ARP request is performed. An entry in the ARP cache remains valid for
        120 seconds.

        This methods initiates the MAC address resolution. To obtain the actual results
        of the address resolution, please use :meth:`Resolve`.

        :param ipaddress: IPv4 address to resolve

        :raises: InvalidDestination - When an unusable IP address was given.

        Example

        This example triggers address resolution gets the MAC address for the given IP address.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ResolveAsync(self, inIPAddress)


    def ProtocolIcmpGet(self):
        return _byteblower.IPv4Configuration_ProtocolIcmpGet(self)

    def ProtocolDhcpGet(self):
        """

        Returns the DHCP protocol.

        :return: :class:`DHCPv4Protocol`

        Example

        This example gets the DHCP protocol object.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ProtocolDhcpGet(self)


    def ProtocolIgmpGet(self):
        """

        Returns the IGMP protocol.

        :return: Object of type Layer4.Igmp.

        Example

        This example gets the IGMP protocol object.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.IPv4Configuration_ProtocolIgmpGet(self)

    if _newclass:
        IsValidLayer3Address = staticmethod(_byteblower.IPv4Configuration_IsValidLayer3Address)
    else:
        IsValidLayer3Address = _byteblower.IPv4Configuration_IsValidLayer3Address
IPv4Configuration_swigregister = _byteblower.IPv4Configuration_swigregister
IPv4Configuration_swigregister(IPv4Configuration)

def IPv4Configuration_IsValidLayer3Address(inAddress):
    return _byteblower.IPv4Configuration_IsValidLayer3Address(inAddress)
IPv4Configuration_IsValidLayer3Address = _byteblower.IPv4Configuration_IsValidLayer3Address

class IPv6Configuration(Layer3Configuration):
    """

    A class representing the IPv6 protocol that allows managing IPv6 settings,
    running IPv6 commands and accessing attached protocols.

    Each ByteBlowerPort must be configured with a layer 3 protocol through the
    method :meth:`ByteBlowerPort.Layer3IPv6Set`. If the IPv6 protocol is selected,
    this object is returned.
    Through it, the IPv6 protocol instance on that port can be configured.

    It provides the following functionality:

    - Configure and read various IPv6 settings and values such as the IP address.
    - Execute IPv6 commands such as resolving IPv6 addresses (through NDP).
    - Access protocols attached to the IPv6 protocol such as DHCPv6 and ICMPv6 on
      which other settings can be configured and other commands can be executed.


    """

    __swig_setmethods__ = {}
    for _s in [Layer3Configuration]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPv6Configuration, name, value)
    __swig_getmethods__ = {}
    for _s in [Layer3Configuration]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IPv6Configuration, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IpManualAdd(self, inIPv6Address):
        """

        Adds a manual IPv6 address to the port.

        .. versionadded:: 2.1.0

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:
        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method adds such a manual IP address to the port. Note this method also
        adds the prefix derived from the specified address to the list of on-link
        prefixes.

        If the IPv6 protocol is not yet initialized, calling this method the first time
        will do so. This initialization causes the host's link-local address to be
        generated and looks for router advertisements to set the default gateway. If no
        router advertisement occurs, the gateway is set to the null address (::).

        :param address: The IPv6 address you want to add. The IPv6 address may be
                        written in any valid IPv6 addressing format. For example,
                        removing leading zeros within a group, compressing adjacent
                        groups of zeros, .... A custom prefix length can be provided by
                        appending this argument with `/<prefix length>`, where
                        *<prefix length>* can be a number between 0 and 128.
                        If no such prefix length is appended, the default length of 64
                        is taken.

        Example

        This examples adds a global address address using default prefix length 64.

        .. code-block:: python
           :emphasize-lines: 2

            bbPort1_l3 = port1.Layer3IPv6Set()
            bbPort1_l3.IpManualAdd('3000:3128::24/64')


        """
        return _byteblower.IPv6Configuration_IpManualAdd(self, inIPv6Address)


    def IpManualRemove(self, inIPv6Address):
        """

        Removes a specified manually added IP address from this port.

        .. versionadded:: 2.1.0

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:

        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method removes the specified IPv6 address from the port if it was added
        manually before. If the address was not added manually, nothing is done.

        :param address: The IPv6 address you want to add. The IPv6 address may be
                        written in any valid IPv6 addressing format. For example,
                        removing leading zeros within a group, compressing adjacent
                        groups of zeros, .... No prefix length suffix (e.g. '/64')
                        may be included!

        Example

        This example removes the specified address from the port if it was previously
        added.

        .. code-block:: python
           :emphasize-lines: 1

            port_layer3_config.IpManualRemove('3000:3128::23/64')



        """
        return _byteblower.IPv6Configuration_IpManualRemove(self, inIPv6Address)


    def IpManualClear(self):
        """

        Removes all manually added IP addresses from this port.

        .. versionadded:: 2.1.0

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:

        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method removes all addresses in the first category.

        Example

        This example removes all manually added addresses from the port.

        .. code-block:: python
           :emphasize-lines: 2

            port_layer3_config = self.port.Layer3IPv6Get()
            port_layer3_config.IpManualClear()


        """
        return _byteblower.IPv6Configuration_IpManualClear(self)


    def IpManualGet(self):
        """

        Returns all IPv6 addresses that where manually added by the user.

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:

        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method returns all manual IPv6 addresses on the port.

        Every time this getter is called, IPv6 synchronizes its state by looking for
        router advertisements. For example, if a router advertisements is found for the
        first time when calling this method, the gateway property will be set updated
        automatically.

        :return: A list of manually added IPv6 addresses is returned. These addresses
                 are returned using the full (i.e. uncompressed) representation and
                 appended with their prefix lengths (see example). An empty list
                 (i.e. empty string) is returned if no addresses were added yet.

        :raises: ByteBlower.Protocol.Unavailable - This protocol is not initialized
                 until a first IP is set (by adding an IP address manually, performing
                 SLAAC or performing DHCP). Calling this method before that is done
                 causes this exception.

        Example

        .. code-block:: python
           :emphasize-lines: 2
           :caption: Prints a list of manual IPv6 addresses

            port_layer3_config = self.port.Layer3IPv6Get()
            list = port_layer3_config.IpManualGet()
            for ip in list:
                print(ip)


        """
        return _byteblower.IPv6Configuration_IpManualGet(self)


    def IpStatelessGet(self):
        """

        Returns all IPv6 addresses that where obtained by stateless autoconfiguration.

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:
        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method returns all SLAAC IPv6 addresses on the port. They are configured
        by calling the :meth:`StatelessAutoconfiguration` function.

        Every time this getter is called, IPv6 synchronizes its state by looking for
        router advertisements. For example, if a router advertisements is found for the
        first time when calling this method, the gateway property will be set updated
        automatically.

        :return: A list of IPv6 addresses obtained during stateless autoconfiguration
                 (SLAAC) is returned. These addresses are returned using the full (i.e.
                 uncompressed) representation and appended with their prefix lengths
                 (see example). An empty list (i.e. empty string) is returned if no
                 autoconfiguration was performed yet or if it did not provided any IP
                 addresses.

        :raises: ByteBlower.Protocol.Unavailable - This protocol is not initialized
                 until a first IP is set (by adding an IP address manually, performing
                 SLAAC or performing DHCP). Calling this method before that is done
                 causes this exception.

        Example

        .. code-block:: python
           :emphasize-lines: 2
           :caption: prints the list of SLAAC-obtained IPv6 addresses

            bbPort1_l3.StatelessAutoconfiguration()
            statelessList = bbPort1_l3.IpStatelessGet()
            for ips in statelessList:
                print(ips)


        """
        return _byteblower.IPv6Configuration_IpStatelessGet(self)


    def IpDhcpGet(self):
        """

        Returns all IPv6 addresses that where obtained by the DHCPv6 protocol.

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:

        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method returns all DHCP IPv6 addresses on the port. They are configured by
        retrieving the DHCP protocol using :meth:`ProtocolDhcpGet` and executing
        :meth:`.DHCPv6Protocol.Perform`.

        Every time this getter is called, IPv6 synchronizes its state by looking for
        router advertisements. For example, if a router advertisements is found for the
        first time when calling this method, the gateway property will be set updated
        automatically.

        :return: A list of IPv6 addresses obtained during DHCP is returned. These
                 addresses are returned using the full (i.e. uncompressed)
                 representation and appended with their prefix lengths (see example).
                 An empty list (i.e. empty string) is returned if no DHCP was performed
                 yet or if it did not provided any IP addresses.

        :raises: ByteBlower.Protocol.Unavailable - This protocol is not initialized
                 until a first IP is set (by adding an IP address manually, performing
                 SLAAC or performing DHCP). Calling this method before that is done
                 causes this exception.

        Example

        .. code-block:: python
           :emphasize-lines: 2
           :caption: prints a list of DHCP-obtained IPv6 addresses.

            dhcpList = bbPort1_l3.IpDhcpGet()
            for ip_dhcp in dhcpList:
                print(ip_dhcp)


        """
        return _byteblower.IPv6Configuration_IpDhcpGet(self)


    def GatewaySet(self, inGateway):
        return _byteblower.IPv6Configuration_GatewaySet(self, inGateway)

    def GatewayGet(self):
        return _byteblower.IPv6Configuration_GatewayGet(self)

    def GatewayAdvertisedGet(self):
        """

        Returns the current (preferred) gateway of this IPv6 protocol, set either
        manually or by performing DHCP or SLAAC.

        .. versionadded:: 2.1.0

        The first time an IP address is added (either manually or by performing DHCP or
        SLAAC) the preferred gateway is also automatically detected. From that moment
        on, it can be retrieved by this method.

        When no gateway is found when the IP is set (manually, through DHCP or SLAAC)
        the gateway is set to the null address (::). Every time this getter is called,
        IPv6 will look for router advertisements. If one is found, it will be updated
        automatically.

        Once the preferred gateway is set using :meth:`GatewayManualSet`, this value
        remains the preferred gateway until it is explicitly replaced. Performing DHCP
        or SLAAC again will not replace the manually set value. This may change in the
        future.

        :raises: ByteBlower.Protocol.Unavailable - This protocol is not initialized
                 until a first IP is set (by adding an IP address manually, performing
                 SLAAC or performing DHCP). Calling this method before that is done
                 causes this exception.

        Example

        This example retrieves the current gateway.

        .. code-block:: python
           :emphasize-lines: 3

            port_layer3_config = self.port.Layer3IPv6Get()
            for link in port_layer3_config.GatewayAdvertisedGet():
                print(link)


        """
        return _byteblower.IPv6Configuration_GatewayAdvertisedGet(self)


    def IpLinkLocalGet(self):
        """

        Returns the linklocal address which is based on the MAC address of the port.

        An IPv6 host can have multiple IPv6 addresses at the same time. ByteBlower
        divides these addresses in four categories:
        - manually added addresses
        - addresses obtained through the DHCP protocol
        - addresses obtained using stateless address autoconfiguration (SLAAC)
        - linklocal addresses.

        This method returns the link-local IPv6 address on the port. It uses the
        dedicated fe80::/64 prefix as the first half of the address and the modified
        EUI-64 number (based on the Ethernet MAC address) as the last half of the
        address.

        Every time this getter is called, IPv6 synchronizes its state by looking for
        router advertisements. For example, if a router advertisements is found for the
        irst time when calling this method, the gateway property will be set updated
        automatically.

        :return: The linklocal IPv6 address is returned. This address does always
                 exist, even if no IPv6 gateway is present. The address is returned
                 using the full (i.e. uncompressed) representation. The prefix length
                 suffix ('/64') is omitted!

        :raises: ByteBlower.Protocol.Unavailable - This protocol is not initialized
                 until a first IP is set (by adding an IP address manually, performing
                 SLAAC or performing DHCP). Calling this method before that is done
                 causes this exception.

        Example

        This example returns the link-local address of a port.

        .. code-block:: python
           :emphasize-lines: 3

            bbPort1_l3 = port1.Layer3IPv6Set()
            print(bbPort1_l3.IpLinkLocalGet())


        """
        return _byteblower.IPv6Configuration_IpLinkLocalGet(self)


    def StatelessAutoconfiguration(self):
        """

        Performs stateless address autoconfiguration (SLAAC) to configure IPv6 with,
        among others, a global IPv6 address.

        The stateless address autoconfiguration (SLAAC) is done in an asynchronous
        manner. It works through the IPv6 Neighbor Discovery Protocol (NDP). It creates
        an IP address based on the prefix information from incoming router
        advertisements (first 64 bits) and the hosts MAC address (last 64 bits).

        .. note:: SLAAC and the NDP is also used to create the link-local IP address.
                  This address has a fixed prefix (fe80::/64) and the same host part.
                  This address is immediately generated when the IPv6 protocol is
                  initialized and is not part of this call.

        If the IPv6 protocol is not yet initialized, calling this method the first time
        will do so. This initialization sets the link-local address described above and
        listens for router advertisements to set the default gateway. If no router
        advertisement occurs, the gateway is set to the null address (::).

        When no routing advertisement is found, no address is added.

        Example

        This example performs stateless address autoconfiguration on this host.

        .. code-block:: python
           :emphasize-lines: 3

            bbPort1_l3 = port1.Layer3IPv6Set()
            bbPort1_l3.StatelessAutoconfiguration()


        """
        return _byteblower.IPv6Configuration_StatelessAutoconfiguration(self)


    def StatelessAutoconfigurationAsync(self):
        """

        Performs stateless address autoconfiguration (SLAAC) to configure IPv6 with,
        among others, a global IPv6 address.

        .. versionadded:: 2.3.0

        This is a asynchronous call so it will return immediately. If you want to wait
        until it has finished then call the :meth:`StatelessAutoconfiguration` method
        after having called this method. This will also rethrow any exceptions that may
        have occured on the server side.

        Returns immediately.

        :return: This method will return nothing and return immediately.

        Example

        This example performs stateless address autoconfiguration on this host.

        .. code-block:: python
           :emphasize-lines: 1

            port_layer3_config.StatelessAutoconfigurationAsync()

        """
        return _byteblower.IPv6Configuration_StatelessAutoconfigurationAsync(self)


    def NeighborDiscovery(self, inIPv6Address):
        """

        Resolves a destination IPv6 address by explicitly performing Neighbor Discovery.

        To use the neighbor cache first when resolving an IPv6 address, execute the
        :meth:`Resolve` method. This may return significantly faster then this method.

        :param address: The IPv6 address that must be resolved. The IPv6 address may be
                        written in any valid IPv6 addressing format. For example,
                        removing leading zeros within a group, compressing adjacent
                        groups of zeros, ...
                        No pre	fix length suffix (e.g. '/64') may be included!

        :return: The layer 2 MAC address found for the provided IPv6 address.

        :raises: ByteBlower.Protocol.Arp.NoReply - When nobody replies to the
                 Neighbour Discovery request (i.e. neither the host itself or a
                 forwarding router), this exception is thrown.

        Example

        This simple example resolves a link-local IPv6 address. This example clearly
        shows that the host part of a link-local address is based on its layer 2
        MAC address.

        .. code-block:: python
           :emphasize-lines: 1

            port_layer3_config.NeighborDiscovery('fe80:0000:0000:0000:02ff:25ff:fe00:0001')


        """
        return _byteblower.IPv6Configuration_NeighborDiscovery(self, inIPv6Address)


    def Resolve(self, inIPv6Address):
        """

        Resolves a destination IPv6 address by looking in the neighbour cache or
        performing Neighbor Discovery.

        To force this host to perform the Neighbor Discovery algorithm and thus bypass
        the cache, execute the :meth:`ProtocolNeighborDiscovery` method.

        :param address: The IPv6 address that must be resolved. The IPv6 address may be
                        written in any valid IPv6 addressing format. For example,
                        removing leading zeros within a group, compressing adjacent
                        groups of zeros, .... No prefix length suffix (e.g. '/64') may
                        be included!

        :return: The layer 2 MAC address found for the provided IPv6 address.

        :raises: ByteBlower.Protocol.Arp.NoReply - When the item is not present in the
                 neighbor cache and nobody replies to the Neighbour Discovery request
                 (i.e. neither the host itself or a forwarding router), this exception
                 is thrown.

        Example

        This simple example resolves a link-local IPv6 address. This example clearly
        shows that the host part of a link-local address is based on its layer 2 MAC
        address.

        .. code-block:: python
           :emphasize-lines: 4

            dhcpv6 = port_l3.ProtocolDhcpGet()
            dhcpv6.Perform()
            port = port_l3.IpDhcpGet()
            dst_mac = self.port_1.Layer3IPv6Get().Resolve(port)


        """
        return _byteblower.IPv6Configuration_Resolve(self, inIPv6Address)


    def SelectSourceAddressFor(self, destination_ip):
        """

        Selects an appropriate IPv6 source address for a given destination address.

        The ByteBlower implements source address selection according to the rules
        specified in RFC 6724 Section 5.

        :param address: The destination address for which we want to select an
                        appropriate source address.

        :return: The appropriate source address for the given destination address.

        Example

        Here we select a source address for a given IPv6 destination. The dst_ip
        and src_ip variables are strings representing an IPv6 address.

        .. code-block:: python
           :emphasize-lines: 4
            src_ip = ipv6.SelectSourceAddressFor(dst_ip)

        """
        return _byteblower.IPv6Configuration_SelectSourceAddressFor(self, destination_ip)


    def ProtocolIcmpGet(self):
        return _byteblower.IPv6Configuration_ProtocolIcmpGet(self)

    def ProtocolDhcpGet(self):
        """

        Returns the DHCPv6 protocol attached to this protocol through which DHCP can
        be performed.

        See :class:`.DHCPv6Protocol` for more configuration options.
        To actually perform DHCP, execute the :meth:`.DHCPv6Protocol.Perform` method on
        the returned object.

        If the IPv6 protocol is not yet initialized, performing DHCP the first time
        will do so. This initialization causes the host's link-local address to be
        generated and looks for router advertisements to set the default gateway. If no
        router advertisement occurs, the gateway is set to the null address (::) and no
        address is set.

        :return: :class:`.DHCPv6Protocol`

        Example

        This example returns the DHCP object.

        .. code-block:: python
           :emphasize-lines: 3

            port_layer3_config = self.port.Layer3IPv6Get()
            protocolDhcp = port_layer3_config.ProtocolDhcpGet()


        """
        return _byteblower.IPv6Configuration_ProtocolDhcpGet(self)


    def ProtocolMldGet(self):
        return _byteblower.IPv6Configuration_ProtocolMldGet(self)
    if _newclass:
        IsValidLayer3Address = staticmethod(_byteblower.IPv6Configuration_IsValidLayer3Address)
    else:
        IsValidLayer3Address = _byteblower.IPv6Configuration_IsValidLayer3Address
IPv6Configuration_swigregister = _byteblower.IPv6Configuration_swigregister
IPv6Configuration_swigregister(IPv6Configuration)

def IPv6Configuration_IsValidLayer3Address(inAddress):
    return _byteblower.IPv6Configuration_IsValidLayer3Address(inAddress)
IPv6Configuration_IsValidLayer3Address = _byteblower.IPv6Configuration_IsValidLayer3Address

ModifierType_GrowingSize = _byteblower.ModifierType_GrowingSize
ModifierType_RandomSize = _byteblower.ModifierType_RandomSize
ModifierType_MultiBurst = _byteblower.ModifierType_MultiBurst
ModifierType_NormalDistributionTiming = _byteblower.ModifierType_NormalDistributionTiming
class AbstractModifier(AbstractObject):
    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AbstractModifier, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AbstractModifier, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetByteBlowerStream(self):
        return _byteblower.AbstractModifier_GetByteBlowerStream(self)

    def GetModifierType(self):
        return _byteblower.AbstractModifier_GetModifierType(self)
AbstractModifier_swigregister = _byteblower.AbstractModifier_swigregister
AbstractModifier_swigregister(AbstractModifier)

class StreamGrowingSizeModifier(_object):
    """

    A frame size modifier which will increase the size of the frame between a minimum and maximum value.

    .. deprecated 2.3.0
       This functionality is replaced by the :class:`.FrameSizeModifierGrowing`,
       see :meth:`.Frame.ModifierSizeGrowingSet` for more information.

    ByteBlower allows different modifiers on a flow.
    Some modifiers work on the timing parameters of a frame, others on the size
    or content. The :class:`StreamGrowingSizeModifier` is a modifier which modifies
    the size of the frames added to the :class:`.Stream` on which this Modifier is
    added.

    A :class:`.StreamGrowingSizeModifier` will increment the frame size with a
    configured amount of bytes. The following parameters can be configured:

    Minimum size
        the minimum frame size. This size will be used when the Stream is started.

    Maximum size
        the maximum frame size. It this limit isreached, the modifier will return
        to the minimum size again.

    Step size
        the amount of bytes the size will increase. By default, a frame will grow
        with one byte but this parameter allows larger step sizes.

    Iteration
        this paramter defines the number of times the same frame size is iterated
        before increasing to the next frame size.

    So, a stream with a StreamModifierGrowingSize installed, will start sending
    frames with a *<Minimum size>* size, will send this size *<Iteration>* times,
    increase the size with *<Step size>* bytes until the *<Maximum size>* is
    reached.

    If the maximum size is reached, the next size is calculated as follows:

        *<next size>* = *<Minimum size>*
                      + ( *<current size>* + *<Step size>* - *<Maximum size>* )

    All sizes define a frame size, excluding the 4 bytes Ethernet checksum.

    The frame size modifier will change the sizes of the Frames added to the
    stream. It the original frame size is longer, the size will truncated to
    the requested frame size. If automatic checksum calculations have been enabled
    on the Frame, they will be recalculated. This depends on the configuration of
    the Frame. See the Frame documentation on how this can be done.

    If the original frame size of a Frame is too short, the Frame will be padded
    with zero-value bytes.

    If multiple frames are added to a TxStream which is configured with a
    StreamModifierGrowingSize, the frames are sent alternately, while the modifier
    is applied on all of them. E.g.

        {Frame A , size X},
        {Frame B, size X},
        {Frame A, size X+1},
        {Frame B, size X+1}, ...

    ..note:: It is possible that the maximum size is never reached. Depending on
             both the *<Step size>* and the TxStream configuration
             (NumberOfFrames), the maximum size will never be used.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamGrowingSizeModifier, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StreamGrowingSizeModifier, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def MaximumGet(self):
        """

        Method to get the current configured maximum frame size.

        :return: The maximum frame size which will be used for a growing size flow.

        Example

        This example show how to retrieve the current maximum frame size.

        .. code-block:: python
           :emphasize-lines: 1

        	print(growingSizeModifier.MaximumGet())



        """
        return _byteblower.StreamGrowingSizeModifier_MaximumGet(self)


    def MaximumSet(self, inMaxSize):
        """

        Sets the maximum size of a Frame of a growing size flow. This defines the
        maximum frame size of the stream.

        :param maximum: Maximum byte length of the Frame.
                        This value must be at least 61 bytes, and maximum 8192. The
                        value must also be bigger than the *<Minimum size>* configured.
                        Default: `1514`

        :raises: python_error - Maximum too big or too small.

        Example

        This example will set the maximum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

        	growingSizeModifier.MaximumSet(128)



        """
        return _byteblower.StreamGrowingSizeModifier_MaximumSet(self, inMaxSize)


    def MinimumGet(self):
        """

        Method to get the current configured minimum frame size.

        :return: The minimum frame size which will be used for a growing size flow.

        Example

        This example show how to retrieve the current minimum frame size.

        .. code-block:: python
           :emphasize-lines: 1

        	print(growingSizeModifier.MinimumGet())



        """
        return _byteblower.StreamGrowingSizeModifier_MinimumGet(self)


    def MinimumSet(self, inMinSize):
        """

        Sets the Minimum size of a Frame of a growing size flow.

        This defines the minimal frame size of the stream. This frame size will be used
        when a Tx.Stream is started.

        :param minimum: Minimum byte length of the Frame. This value must be at least
                        60 bytes, and maximum 8191. The value must also be less than
                        the *<Maximum size>* configured.    Default: `60`

        :raises: python_error: Minimum too small or too big.

        Example

        This example will set the minimum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

        	print(growingSizeModifier.MinimumSet(128))



        """
        return _byteblower.StreamGrowingSizeModifier_MinimumSet(self, inMinSize)


    def StepGet(self):
        """

        Method to get the current configured step size.

        :return: The step size which will be used for a growing size flow.

        Example

        This example show how to retrieve the current step size.

        .. code-block:: python
           :emphasize-lines: 1

        	print(growingSizeModifier.StepGet())



        """
        return _byteblower.StreamGrowingSizeModifier_StepGet(self)


    def StepSet(self, inStep):
        """

        Sets the number of bytes a frame will grow in one step.

        Each time the modifier needs to adapt the size of the frame, the size will be
        incremented with *<Step size>* bytes.

        :param step: This parameter defines the amount of bytes the frame will grow.
                     Default: `1`

        :raises: python_error - An error is returned when the value is less than 1.

        Example

        This example demonstrates a step size of 10 bytes:

        .. code-block:: python
           :emphasize-lines: 1

        	growingSizeModifier.StepSet(10)



        """
        return _byteblower.StreamGrowingSizeModifier_StepSet(self, inStep)


    def IterationGet(self):
        """

        Method to get the current configured iteration.

        :return: The iteration which will be used for a growing size flow.

        Example

        This example show how to retrieve the current iteration.

        .. code-block:: python
           :emphasize-lines: 1

        	print(growingSizeModifier.IterationGet())



        """
        return _byteblower.StreamGrowingSizeModifier_IterationGet(self)


    def IterationSet(self, inIteration):
        """

        Sets the number of times the same frame size will be used.

        A Frame can be sent with the same frame size multiple times before the size is
        increased to the next value. This parameter defines the iteration count.

        :param iteration: Number of times the same frame size will be used before the
                          frame size is increased to the next value.   Default: `1`

        Example

        This example demonstrates an iteration of 10, before going to the next frame
        size.

        .. code-block:: python
           :emphasize-lines: 1

        	growingSizeModifier.IterationSet(10)


        """
        return _byteblower.StreamGrowingSizeModifier_IterationSet(self, inIteration)


    def ReCommitValues(self, inFrame):
        return _byteblower.StreamGrowingSizeModifier_ReCommitValues(self, inFrame)
StreamGrowingSizeModifier_swigregister = _byteblower.StreamGrowingSizeModifier_swigregister
StreamGrowingSizeModifier_swigregister(StreamGrowingSizeModifier)

class MultipleBurstModifier(AbstractModifier):
    """



    """

    __swig_setmethods__ = {}
    for _s in [AbstractModifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MultipleBurstModifier, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractModifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MultipleBurstModifier, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def InterBurstGapGet(self):
        """

        Returns the time (ns) between the end of start of the next burst.

        Example

        Get the gap between 2 bursts

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MultipleBurstModifier_InterBurstGapGet(self)


    def InterBurstGapSet(self, inInterBurstGap):
        """

        Sets the time (ns) between the end of one burst and the start of the next burst.

        :param interburstgap: The gap between 2 burst in ns

        Example

        Set the gap at 1ms

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO

        Set the gap at 10ms

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MultipleBurstModifier_InterBurstGapSet(self, inInterBurstGap)


    def BurstSizeGet(self):
        """

        Retrieves the number of frames in one burst.

        :return: Returns the number of frames in one burst

        Example

        retrieve the burstsize

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MultipleBurstModifier_BurstSizeGet(self)


    def BurstSizeSet(self, inBurstSize):
        """

        Sets the number of frames to send in one burst.

        :param burstsize: the size of the burst

        Example

        Set the burstsize to 100

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.MultipleBurstModifier_BurstSizeSet(self, inBurstSize)

MultipleBurstModifier_swigregister = _byteblower.MultipleBurstModifier_swigregister
MultipleBurstModifier_swigregister(MultipleBurstModifier)

class NormalDistributionTimingModifier(AbstractModifier):
    """



    """

    __swig_setmethods__ = {}
    for _s in [AbstractModifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NormalDistributionTimingModifier, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractModifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NormalDistributionTimingModifier, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def VarianceSet(self, inVariance):
        """

        Sets the variance of the normal distribution

        """
        return _byteblower.NormalDistributionTimingModifier_VarianceSet(self, inVariance)


    def VarianceGet(self):
        """

        Retrieves the variance of the normal distribution

        :return:  Returns the number of frames in one burst

        """
        return _byteblower.NormalDistributionTimingModifier_VarianceGet(self)

NormalDistributionTimingModifier_swigregister = _byteblower.NormalDistributionTimingModifier_swigregister
NormalDistributionTimingModifier_swigregister(NormalDistributionTimingModifier)

class StreamRandomSizeModifier(_object):
    """

    A frame size modifier which will change the size of the frame randomly between
    a minimum and maximum value.

    .. deprecated:: 2.3.0
       This functionality is replaced by the :class:`.FrameSizeModifierRandom`, see
       :meth:`.Frame.ModifierSizeRandomSet` for more information.

    ByteBlower allows different modifiers on a flow. Some modifiers work on the
    timing parameters of a frame, others on the size or content. The
    StreamModifierRandomSize is a modifier which modifies the size of the frames
    added to the Stream on which this Modifier is added.

    A StreamModifierRandomSize will change the frame size randomly. The following
    parameters can be configured:

    Minimum size
        the minimum frame size.

    Maximum size
        the maximum frame size.

    So, a stream with a StreamModifierRandomSize installed, will start sending
    frames with a size randomly chosen between *<Minimum size>* size and
    *<Maximum size>* size. Each time a frame is sent, a new size is selected.

    All sizes are without the additional 4 bytes Ethernet checksum.

    The frame size modifier will change the sizes of the Frames added to the
    stream. If the original frame size is bigger, the size will truncated to the
    requested frame size. If automatic checksum calculations have been enabled on
    the Frame, they will be recalculated. This depends on the configuration of the
    Frame. See the :class:`Frame` documentation on how this can be done.

    If the original frame size of a Frame is too short, the Frame will be padded
    with zero-value bytes.

    If multiple frames are added to a TxStream which is configured with a
    StreamModifierRandomSize, the frames are sent alternately, while the modifier
    is applied on all of them.


    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamRandomSizeModifier, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StreamRandomSizeModifier, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def MinimumSet(self, inMinimum):
        """

        Sets the Minimum size of a Frame of a flow with StreamModifierRandomSize.

        This defines the minimal frame size of the stream.

        :param minimum: Minimum byte length of the Frame. This value must be at least
                        60 bytes, and maximum 8191. The value must also be less than
                        the *<Maximum size>* configured.    Default: `60`

        :raises: python_error: Minimum too small or too big.

        Example

        This example will set the minimum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

        	RandomSizeModifier.MinimumSet(128)



        """
        return _byteblower.StreamRandomSizeModifier_MinimumSet(self, inMinimum)


    def MinimumGet(self):
        """

        Method to get the currently configured minimum frame size.

        :return:  The minimum frame size which will be used for a random size flow.

        Example

        This example show how to retrieve the current minimum frame size.

        .. code-block:: python
           :emphasize-lines: 1

        	print(RandomSizeModifier.MinimumGet())



        """
        return _byteblower.StreamRandomSizeModifier_MinimumGet(self)


    def MaximumSet(self, inMaximum):
        """

        Sets the Maximum size of a Frame of a flow with StreamModifierRandomSize.

        This defines the maximum frame size of the stream.

        :param maximum: Maximum byte length of the Frame. This value must be at least
                        61 bytes, and maximum 8192. The value must also be bigger than
                        the *<Minimum size>* configured.   Default: `1514`

        :raises: python_error: Maximum too small or too big.

        Example

        This example will set the maximum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

        	RandomSizeModifier.MaximumSet(128)



        """
        return _byteblower.StreamRandomSizeModifier_MaximumSet(self, inMaximum)


    def MaximumGet(self):
        """

        Method to get the current configured maximum frame size.

        :return: The maximum frame size which will be used for a random size flow.

        Example

        This example show how to retrieve the current maximum frame size.

        .. code-block:: python
           :emphasize-lines: 3

           	print(RandomSizeModifier.MaximumGet())



        """
        return _byteblower.StreamRandomSizeModifier_MaximumGet(self)


    def ReCommitValues(self, inFrame):
        return _byteblower.StreamRandomSizeModifier_ReCommitValues(self, inFrame)
StreamRandomSizeModifier_swigregister = _byteblower.StreamRandomSizeModifier_swigregister
StreamRandomSizeModifier_swigregister(StreamRandomSizeModifier)

class FrameFieldModifier(AbstractObject):
    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameFieldModifier, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FrameFieldModifier, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def FrameGet(self):
        return _byteblower.FrameFieldModifier_FrameGet(self)

    def OffsetGet(self):
        return _byteblower.FrameFieldModifier_OffsetGet(self)

    def OffsetSet(self, inOffset):
        return _byteblower.FrameFieldModifier_OffsetSet(self, inOffset)

    def LengthGet(self):
        return _byteblower.FrameFieldModifier_LengthGet(self)

    def LengthSet(self, inLength):
        return _byteblower.FrameFieldModifier_LengthSet(self, inLength)
FrameFieldModifier_swigregister = _byteblower.FrameFieldModifier_swigregister
FrameFieldModifier_swigregister(FrameFieldModifier)

class FrameFieldModifierIncremental(FrameFieldModifier):
    """

    A frame field modifier which will increase the value of the frame field between a minimum and maximum value.

    ByteBlower allows different modifiers on a Frame. Some modifiers work on the
    size of a frame, others content. The :class:`.FrameFieldModifierIncremental`
    is a modifier which modifies a certain field in the frame content.

    A frame field is a number of subsequent bytes in the frame content. The value
    is defined as host-ordering signed integer and will be written to the frame
    content as network-ordering signed integer.

    A FrameFieldModifierIncremental will increment the value in a frame field with
    a configured amount. The following parameters can be configured:

    1. Parameters related to the location of the field in the frame:

       Field offset
           Offset of the field counted in bytes from the start of the frame.

       Field length
           Length of the field counted in bytes. Minimum: 1Byte. Maximum: 8Bytes (
           depends on server version).

       The field cannot overwrite the 4 bytes Ethernet checksum. The allowed range
       for offset is 0 ... *<ByteBlowerPort MDL>*.


       - When the field offset is greater or equal than the actual frame size,
         nothing will be written to the frame.

       - When the field offset is smaller than the actual frame size, but the
         field offset + field length exceeds the frame size.
         Then the LSB part of the field will be written to the frame.

       Please note that in both cases the field value
       will still move on to the next value.

    2. Parameters related to the value written to the field:

       Minimum value
           The minimum field value.

       Maximum value
           The maximum field value.

       Value step
           The amount the value will increase. By default, the value will grow with
           one but this parameter allows larger value steps. The step can be
           positive or negative but cannot be zero.

       Initial value
           This field value will bewritten to the frame contents when the
           :class:`.Stream` is started.

       The field value range is defined by the minimum and maximum value (both
       valuesinclusive).

       - Positive value step
         A frame with a FrameFieldModifierIncremental installed, will start
         sending frames with field value *<Initial value>*, increase the value
         with *<Value step>* until the *<Maximum value>* is reached.

         When maximum value is reached, the modifier will return to the minimum
         value again. So if the *<Maximum value>* is reached, the next value will
         be the *<Minimum value>*.

       - Negative value step
         A frame with a FrameFieldModifierIncremental installed, will start sending
         frames with field value *<Initial value>*, increase the value with (the
         *negative*) *<Value step>* (thus *decrease* the value) until the
         *<Minimum value>* is reached.

         When the minimum value is reached, the modifier will return to the maximum
         value again. So if the *<Minimum value>* is reached, the next value will
         be the *<Maximum value>*.

    .. note:: When the *<Initial value>* is smaller than the *<Minimum value>*
              when the stream is started, then the minimum value will be used as
              initial value. When the *<Initial value>* is greater than the
              *<Maximum value>* when the stream is started, then the maximum value
              will be used as initial value.

    .. note:: If automatic checksum and/or length calculations have been enabled
              on the Frame and the frame field overlaps one or more of those. Then
              the automatic fields will overrule the field modifier value. This
              depends on the configuration of the Frame. See the Frame
              documentation on how this can be done.

    .. note:: It is possible that the maximum value is never reached. Depending on
              the *<Value step>* and the Stream configuration (*<NumberOfFrames>*),
              the maximum value will never be reached.

    .. versionadded:: 2.3.0

    .. code-block:: python
       :emphasize-lines: 2

        frameModifierIncr = frame.ModifierFieldIncrementalAdd()
        frameModifierIncr.MinimumSet(500)

    """

    __swig_setmethods__ = {}
    for _s in [FrameFieldModifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameFieldModifierIncremental, name, value)
    __swig_getmethods__ = {}
    for _s in [FrameFieldModifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FrameFieldModifierIncremental, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def OffsetGet(self):
        """

        Method to get the current configured field offset within the frame content.

        The field offset is the absolute offset from the start of the frame.

        :return: The field offset which will be used for this incremental value field
                 modifier.

        Example

        This example shows how to retrieve the current field offset.

        .. code-block:: python
           :emphasize-lines: 1

        	print(frameModifierIncr.OffsetGet())

        """
        return _byteblower.FrameFieldModifierIncremental_OffsetGet(self)


    def OffsetSet(self, inOffset):
        """

        Sets the offset of the frame field within the frame content.

        :param offset: Offset of the frame field within the frame content. This value
                       is relative to the start of the frame. The value must be greater
                       or equal than zero and must be smaller than the ByteBlowerPort
                       MDL
                       Default: `56`

        :raises: :exc:`.ConfigError` When the field offset is out of valid range.

        Example

        This example will set the offset to 88.

        .. code-block:: python
           :emphasize-lines: 1

            frameModifierIncr.OffsetSet(88)

        """
        return _byteblower.FrameFieldModifierIncremental_OffsetSet(self, inOffset)


    def LengthGet(self):
        """

        Method to get the current configured field length.

        :return: The field length which will be used for this incremental value field
                 modifier.

        Example

        This example shows how to retrieve the current field length.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameModifierIncr.LengthGet())

        """
        return _byteblower.FrameFieldModifierIncremental_LengthGet(self)


    def LengthSet(self, inLength):
        """

        Sets the length of the frame field.

        :param length: Length of the frame field. The value must be greater than zero
                       and smaller than 8 (as for server version 2.3.x)
                       Default: `2`

        :raises: :exc:`.ConfigError`  When the field length is not supported by the server.

        Example

        This example will set the field length to 4.

        .. code-block:: python
           :emphasize-lines: 1

        	frameModifierIncr.LengthSet(4)

        """
        return _byteblower.FrameFieldModifierIncremental_LengthSet(self, inLength)


    def InitialValueGet(self):
        """

        Method to get the current configured initial field value.

        :return: The initial field value which will be used for this incremental value
                 field modifier.

        Example

        This example shows how to retrieve the current initial field value.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameModifierIncr.InitialValueGet())

        """
        return _byteblower.FrameFieldModifierIncremental_InitialValueGet(self)


    def InitialValueSet(self, inInitialValue):
        """

        Sets the initial value of the frame field.

        This value will be used when a Tx.Stream is started.

        :param initial: Initial value of the frame field. When the initial value is
                        smaller than the *<Minimum value>* when the stream is started,
                        then the minimum value will be used as initial value. When the
                        initial value is greater than the *<Maximum value>* when the
                        stream is started, then the maximum value will be used as
                        initial value.
                        Default: `0`

        Example

        This example will set the initial value to 1024.

        .. code-block:: python
           :emphasize-lines: 1

            frameModifierIncr.InitialValueSet(1024)


        """
        return _byteblower.FrameFieldModifierIncremental_InitialValueSet(self, inInitialValue)


    def MinimumGet(self):
        """

        Method to get the current configured minimum field value.

        :return: The minimum field value which will be used for this incremental value
                 field modifier.

        Example

        This example shows how to retrieve the current minimum field value.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameModifierIncr.MinimumGet())

        """
        return _byteblower.FrameFieldModifierIncremental_MinimumGet(self)


    def MinimumSet(self, inMinValue):
        """

        Sets the Minimum value of the frame field for an incremental value field modifier.

        :param minimum: Minimum value for the frame field. This value is limited to
                        64-bit signed integer range. The value must always be less than
                        the *<Maximum value>* configured.
                        Default: `0`

        :raises: :exc:`.ConfigError` Minimum too small or too big.

        Example

        This example will set the minimum value to 512.

        .. code-block:: python
           :emphasize-lines: 1

            frameModifierIncr.MinimumSet(512)

        """
        return _byteblower.FrameFieldModifierIncremental_MinimumSet(self, inMinValue)


    def MaximumGet(self):
        """

        Method to get the current configured maximum field value.

        :return: The maximum field value which will be used for this incremental value
                 field modifier.

        Example

        This example shows how to retrieve the current maximum field value.

        .. code-block:: python
           :emphasize-lines: 1

        	print(frameModifierIncr.MaximumGet())

        """
        return _byteblower.FrameFieldModifierIncremental_MaximumGet(self)


    def MaximumSet(self, inMaxValue):
        """

        Sets the maximum value of the frame field for an incremental value field modifier.

        :param maximum: Maximum value for the frame field. This value is limited to
                        64-bit signed integer range. The value must always be greater
                        than the *<Minimum value>* configured.
                        Default: `65535`

        :raises: :exc:`.ConfigError` Maximum too big or too small.

        Example

        This example will set the maximum value to 16383 bytes.

        .. code-block:: python
           :emphasize-lines: 1

            frameModifierIncr.MaximumSet(16383)

        """
        return _byteblower.FrameFieldModifierIncremental_MaximumSet(self, inMaxValue)


    def StepGet(self):
        """

        Method to get the current configured value step.

        :return: The value step which will be used for an incremental value field
                 modifier.

        Example

        This example shows how to retrieve the current value step.

        .. code-block:: python
           :emphasize-lines: 1

        	print(frameModifierIncr.StepGet())

        """
        return _byteblower.FrameFieldModifierIncremental_StepGet(self)


    def StepSet(self, inStep):
        """

        Sets the value a field value will grow in one step.

        Each time the modifier needs to adapt the value of the frame field, it will be
        incremented with *<Value step>*.

        :param step: This parameter defines the amount the field value will grow. This
                     value can be positive or negative.
                     Default: `1`

        :raises: :exc:`.ConfigError`  An error is returned when the value is zero.

        Example

        This example demonstrates a value step of 10:

        .. code-block:: python
           :emphasize-lines: 1

            frameModifierIncr.StepSet(10)

        This example demonstrates a negative value step of 2:

        .. code-block:: python
           :emphasize-lines: 1

            frameModifierIncr.StepSet(-2)


        """
        return _byteblower.FrameFieldModifierIncremental_StepSet(self, inStep)

FrameFieldModifierIncremental_swigregister = _byteblower.FrameFieldModifierIncremental_swigregister
FrameFieldModifierIncremental_swigregister(FrameFieldModifierIncremental)

class FrameFieldModifierRandom(FrameFieldModifier):
    """

    A frame field modifier which will change the field value of the frame randomly
    between a minimum and maximum value.

    ByteBlower allows different modifiers on a Frame. Some modifiers work on the
    size of a frame, others content. The FrameFieldModifierRandom is a modifier
    which modifies a certain field in the frame content.

    A frame field is a number of subsequent bytes in the frame content. The value
    is defined as host-ordering signed integer and will be written to the frame
    content as network-ordering signed integer.

    A FrameFieldModifierRandom will change the value in the frame field randomly.
    The following parameters can be configured:

    1. Parameters related to the location of the field in the frame:

       Field offset
           Offset of the field counted in bytes from the start of the frame.

       Field length
           Length of the field counted in  bytes. Minimum: 1Byte. Maximum: 8Bytes
           (depends on server version).

       The field cannot overwrite the 4 bytes Ethernet checksum. The allowed range
       for offset is 0 ... *<ByteBlowerPort MDL>*.

       - When the field offset is greater or equal than the actual frame size,
         nothing will be written to the frame.

       - When the field offset is smaller than the actual frame size, but the
         field offset + field length exceeds the frame size.

         Then the LSB part of the field will be written to the frame.

       Please note that in both cases the field value will still move on to the next value.

    2. Parameters related to the value written to the field:

       Minimum value
           The minimum field value.

       Maximum value
           The maximum field value.

       The field value range is defined by the minimum and maximum value (both
       values inclusive).

       So, a frame with a FrameFieldModifierRandom installed, will start sending
       frames with field values randomly chosen between *<Minimum value>* and
       *<Maximum value>*. Each time a frame is sent, a new value is selected.

    .. note:: If automatic checksum and/or length calculations have been enabled on
              the Frame and the frame field overlaps one or more of those. Then the
              automatic fields will overrule the field modifier value. This depends
              on the configuration of the Frame. See the :class:`.Frame`
              documentation on how this can be done.

    .. versionadded:: 2.3.0

    """

    __swig_setmethods__ = {}
    for _s in [FrameFieldModifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameFieldModifierRandom, name, value)
    __swig_getmethods__ = {}
    for _s in [FrameFieldModifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FrameFieldModifierRandom, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def OffsetGet(self):
        """

        Method to get the current configured field offset within the frame content.

        The field offset is the absolute offset from the start of the frame.

        :return: The field offset which will be used for this random value field
                 modifier.

        Example

        This example shows how to retrieve the current field offset.

        .. code-block:: python
           :emphasize-lines: 1

        	print(frameModifierRnd.OffsetGet())

        """
        return _byteblower.FrameFieldModifierRandom_OffsetGet(self)


    def OffsetSet(self, inOffset):
        """

        Sets the offset of the frame field within the frame content.

        :param offset: Offset of the frame field within the frame content. This value
                       is relative to the start of the frame. The value must be greater
                       or equal than zero and must be smaller than the ByteBlowerPort
                       MDL
                       Default: `56`

        :raises: :exc:`.ConfigError` When the field offset is out of valid range.

        Example

        This example will set the offset to 88.

        .. code-block:: python
           :emphasize-lines: 1

        	frameModifierRnd.OffsetSet(88)

        """
        return _byteblower.FrameFieldModifierRandom_OffsetSet(self, inOffset)


    def LengthGet(self):
        """

        Method to get the current configured field length.

        :return: The field length which will be used for this random value field
                 modifier.

        Example

        This example shows how to retrieve the current field length.

        .. code-block:: python
           :emphasize-lines: 1

        	print(frameModifierRnd.LengthGet())

        """
        return _byteblower.FrameFieldModifierRandom_LengthGet(self)


    def LengthSet(self, inLength):
        """

        Sets the length of the frame field.

        :param length: Length of the frame field. The value must be greater than zero
                       and smaller than 8 (as for server version 2.3.x)
                       Default: `2`

        :raises: :exc:`.ConfigError` When the field length is not supported by the server.

        Example

        This example will set the field length to 4.

        .. code-block:: python
           :emphasize-lines: 1

        	frameModifierRnd.LengthSet(4)

        """
        return _byteblower.FrameFieldModifierRandom_LengthSet(self, inLength)


    def MinimumGet(self):
        """

        Method to get the current configured minimum field value.

        :return: The minimum field value which will be used for this random value field
                 modifier.

        Example

        This example shows how to retrieve the current minimum field value.

        .. code-block:: python
           :emphasize-lines: 1

        	print(frameModifierRnd.MinimumGet())

        """
        return _byteblower.FrameFieldModifierRandom_MinimumGet(self)


    def MinimumSet(self, inMinValue):
        """

        Sets the Minimum value of the frame field for a random value field modifier.

        :param minimum: Minimum value for the frame field. This value is limited to
                        64-bit signed integer range. The value must always be less than
                        the *<Maximum value>* configured.
                        Default: `0`

        :raises: :exc:`.ConfigError` Minimum too small or too big.

        Example

        This example will set the minimum value to 512.

        .. code-block:: python
           :emphasize-lines: 1

        	frameModifierRnd.MinimumSet(512)

        """
        return _byteblower.FrameFieldModifierRandom_MinimumSet(self, inMinValue)


    def MaximumGet(self):
        """

        Method to get the current configured maximum field value.

        :return: The maximum field value which will be used for this random value field
                 modifier.

        Example

        This example shows how to retrieve the current maximum field value.

        .. code-block:: python
           :emphasize-lines: 1

        	print(frameModifierRnd.MaximumGet())

        """
        return _byteblower.FrameFieldModifierRandom_MaximumGet(self)


    def MaximumSet(self, inMaxValue):
        """

        Sets the maximum value of the frame field for a random value field modifier.

        :param maximum: Maximum value for the frame field. This value is limited to
                        64-bit signed integer range. Thevalue must always be greater
                        than the *<Minimum value>* configured.
                        Default: `65535`

        :raises: :exc:`.ConfigError` Maximum too big or too small.

        Example

        This example will set the maximum value to 16383 bytes.

        .. code-block:: python
           :emphasize-lines: 1

        	frameModifierRnd.MaximumSet(16383)

        """
        return _byteblower.FrameFieldModifierRandom_MaximumSet(self, inMaxValue)

FrameFieldModifierRandom_swigregister = _byteblower.FrameFieldModifierRandom_swigregister
FrameFieldModifierRandom_swigregister(FrameFieldModifierRandom)

class FrameSizeModifierResultSnapshot(AbstractRefreshableResult):
    """

    A collection of statistics containing the results of a frame size modifier.

    There are currently 2 frame size modifiers available:

    - The :class:`FrameSizeModifierGrowing`, which is the Growing Size modifier
    - The :class:`FrameSizeModifier.Random`, which is the Random Size modifier.

    Example

    This example shows how to retrieve the number of packets handled by a
    FrameSizeModifierGrowing

    .. code-block:: python

    	resultSnapshot = sizeModifierRandom.ResultGet()
    	print(resultSnapshot.PacketCountGet())

    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameSizeModifierResultSnapshot, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FrameSizeModifierResultSnapshot, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.TimestampGet())

        """
        return _byteblower.FrameSizeModifierResultSnapshot_TimestampGet(self)


    def TimestampFirstGet(self):
        """

        Gets the timestamp [NS] of the first packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the first transmitted packet in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.TimestampFirstGet())

        """
        return _byteblower.FrameSizeModifierResultSnapshot_TimestampFirstGet(self)


    def TimestampLastGet(self):
        """


        Gets the timestamp [NS] of the last packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the last transmitted packet in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.TimestampLastGet())

        """
        return _byteblower.FrameSizeModifierResultSnapshot_TimestampLastGet(self)


    def ByteCountGet(self):
        """

        Returns the number of transmitted bytes.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.ByteCountGet())

        """
        return _byteblower.FrameSizeModifierResultSnapshot_ByteCountGet(self)


    def FramesizeMaximumGet(self):
        """

        Returns the size of the biggest transmitted frame.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        .. code-block:: 1
           :emphasize-lines: 2

            print(snapshot.FramesizeMaximumGet())

        """
        return _byteblower.FrameSizeModifierResultSnapshot_FramesizeMaximumGet(self)


    def FramesizeMinimumGet(self):
        """

        Returns the size of the smallest transmitted frame.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.FramesizeMinimumGet())

        """
        return _byteblower.FrameSizeModifierResultSnapshot_FramesizeMinimumGet(self)


    def PacketCountGet(self, *args):
        """

        Returns the number of transmitted packets.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.PacketCountGet())


        Returns the number of transmitted packets.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.PacketCountGet())

        """
        return _byteblower.FrameSizeModifierResultSnapshot_PacketCountGet(self, *args)


    def PacketCountBelowMinimumGet(self):
        return _byteblower.FrameSizeModifierResultSnapshot_PacketCountBelowMinimumGet(self)

    def PacketCountAboveMaximumGet(self):
        return _byteblower.FrameSizeModifierResultSnapshot_PacketCountAboveMaximumGet(self)

    def IntervalDurationGet(self):
        """

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.IntervalDurationGet())

        """
        return _byteblower.FrameSizeModifierResultSnapshot_IntervalDurationGet(self)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp when the counters of this object where last refreshed.

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(snapshot.RefreshTimestampGet())

        """
        return _byteblower.FrameSizeModifierResultSnapshot_RefreshTimestampGet(self)

FrameSizeModifierResultSnapshot_swigregister = _byteblower.FrameSizeModifierResultSnapshot_swigregister
FrameSizeModifierResultSnapshot_swigregister(FrameSizeModifierResultSnapshot)

class FrameSizeModifier(AbstractObject):
    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameSizeModifier, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FrameSizeModifier, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    DEFAULT_MIN_SIZE = _byteblower.FrameSizeModifier_DEFAULT_MIN_SIZE
    DEFAULT_MAX_SIZE = _byteblower.FrameSizeModifier_DEFAULT_MAX_SIZE

    def ResultGet(self):
        return _byteblower.FrameSizeModifier_ResultGet(self)

    def FrameGet(self):
        return _byteblower.FrameSizeModifier_FrameGet(self)
FrameSizeModifier_swigregister = _byteblower.FrameSizeModifier_swigregister
FrameSizeModifier_swigregister(FrameSizeModifier)

class FrameSizeModifierGrowing(FrameSizeModifier):
    """

    A frame size modifier which will increase the size of the frame between a minimum and maximum value.

    .. versionadded:: 2.3.0

    ByteBlower allows different modifiers on a Frame. Some modifiers work on the
    size of a frame, others content. The :class:`FrameSizeModifierGrowingSize` is a
    modifier which modifies the size of the frame.

    A FrameSizeModifierGrowingSize will increment the frame size with a configured
    amount of bytes. The following parameters can be configured:

    Minimum size
        the minimum frame size. This size will be used when the Stream is started.

    Maximum size
        the maximum frame size. It this limit is reached, the modifier will return
        to the minimum size again.

    Step size
        the amount of bytes the size will increase. By default, a frame will grow
        with one byte but this parameter allows larger step sizes.

    Iteration
        this parameter defines the number of times the same frame size is iterated
        before increasing to the next frame size.

    So, a frame with a FrameSizeModifierGrowingSize installed, will start sending
    frames with a *<Minimum size>* size, will send this size *<Iteration>* times,
    increase the size with *<Step size>* bytes until the *<Maximum size>* is
    reached.

    If the maximum size is reached, the next size is calculated as follows:

        *<next size>* = *<Minimum size>* + ( *<current size>* + *<Step size>* - *<Maximum size>* )

    All sizes define a frame size, excluding the 4 bytes Ethernet checksum.

    The frame size modifier will change the size of the Frame. If the original
    frame size is longer, the size will truncated to the requested frame size. If
    automatic checksum calculations have been enabled on the Frame, they will be
    recalculated. This depends on the configuration of the Frame. See the
    :class:`.Frame` documentation on how this can be done.

    If the original frame size of a Frame is too short, the Frame will be padded
    with zero-value bytes.

    .. note:: It is possible that the maximum size is never reached. Depending on
              both the  *<Step size>* and the Stream configuration
              (NumberOfFrames), the maximum size will never be used.
    Example

    This example will set the minimum frame size to 128 bytes.

    .. code-block:: python
       :emphasize-lines: 2

    	sizeModifierGrowing = frame.ModifierSizeGrowingSet()
        sizeModifierGrowing.MinimumSet(128)

    """

    __swig_setmethods__ = {}
    for _s in [FrameSizeModifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameSizeModifierGrowing, name, value)
    __swig_getmethods__ = {}
    for _s in [FrameSizeModifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FrameSizeModifierGrowing, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    DEFAULT_ITERATION = _byteblower.FrameSizeModifierGrowing_DEFAULT_ITERATION
    DEFAULT_STEP_SIZE = _byteblower.FrameSizeModifierGrowing_DEFAULT_STEP_SIZE

    def MaximumGet(self):
        """

        Method to get the current configured maximum frame size.

        :return: The maximum frame size which will be used for a growing size flow.

        Example

        This example shows how to retrieve the current maximum frame size.

        .. code-block:: python
           :emphasize-lines: 1

            print(sizeModifierGrowing.MaximumGet())

        """
        return _byteblower.FrameSizeModifierGrowing_MaximumGet(self)


    def MaximumSet(self, inMaxSize):
        """

        Sets the maximum size of a Frame of a growing size flow. This defines the
        maximum frame size of the stream.

        :param maximum: Maximum byte length of the Frame. This value must be at least
                        61 bytes, and maximum 8192. The value must also be bigger than
                        the *<Minimum size>* configured.
                        Default: `1514`

        :raises: python_error Maximum too big or too small.

        Example

        This example will set the maximum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

            sizeModifierGrowing.MaximumSet(128)

        """
        return _byteblower.FrameSizeModifierGrowing_MaximumSet(self, inMaxSize)


    def MinimumGet(self):
        """

        Method to get the current configured minimum frame size.

        :return: The minimum frame size which will be used for a growing size flow.

        Example

        This example shows how to retrieve the current minimum frame size.

        .. code-block:: python
           :emphasize-lines: 1

            print(sizeModifierGrowing.MinimumGet())

        """
        return _byteblower.FrameSizeModifierGrowing_MinimumGet(self)


    def MinimumSet(self, inMinSize):
        """

        Sets the Minimum size of a Frame of a growing size flow.

        This defines the minimal frame size of the stream. This frame size will be used
        when a Stream is started.

        :param minimum: Minimum byte length of the Frame. This value must be at least
                        60 bytes, and maximum 8191. The value must also be less than
                        the *<Maximum size>* configured.
                        Default: `60`

        :raises: python_error: Minimum too small or too big.

        Example

        This example will set the minimum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

            sizeModifierGrowing.MinimumSet(128)

        """
        return _byteblower.FrameSizeModifierGrowing_MinimumSet(self, inMinSize)


    def StepGet(self):
        """

        Method to get the current configured step size.

        :return: The step size which will be used for a growing size flow.

        Example

        This example shows how to retrieve the current step size.

        .. code-block:: python
           :emphasize-lines: 1

            print(sizeModifierGrowing.StepGet())

        """
        return _byteblower.FrameSizeModifierGrowing_StepGet(self)


    def StepSet(self, inStep):
        """

        Sets the number of bytes a frame will grow in one step.

        Each time the modifier needs to adapt the size of the frame, the size will be
        incremented with *<Step size>* bytes.

        :param step: This parameter defines the amount of bytes the frame will grow. Default: `1`

        :raises: python_error: An error is returned when the value is less than 1.

        Example

        This example demonstrates a step size of 10 bytes:

        .. code-block:: python
           :emphasize-lines: 1

            sizeModifierGrowing.StepSet(2)

        """
        return _byteblower.FrameSizeModifierGrowing_StepSet(self, inStep)


    def IterationGet(self):
        """

        Method to get the current configured iteration.

        :return:  The iteration which will be used for a growing size flow.

        Example

        This example shows how to retrieve the current iteration.

        .. code-block:: python
           :emphasize-lines: 1

            iteration = sizeModifierGrowing.IterationGet()

        """
        return _byteblower.FrameSizeModifierGrowing_IterationGet(self)


    def IterationSet(self, inIteration):
        """

        Sets the number of times the same frame size will be used.

        A Frame can be sent with the same frame size multiple times before the size is
        increased to the next value. This parameter defines the iteration count.

        :param iteration: Number of times the same frame size will be used before the
                          frame size is increased to the next value. Default: `1`

        Example

        This example demonstrates an iteration of 10, before going to the next frame
        size.

        .. code-block:: python
           :emphasize-lines: 1

            sizeModifierGrowing.IterationSet(10)

        """
        return _byteblower.FrameSizeModifierGrowing_IterationSet(self, inIteration)

FrameSizeModifierGrowing_swigregister = _byteblower.FrameSizeModifierGrowing_swigregister
FrameSizeModifierGrowing_swigregister(FrameSizeModifierGrowing)

class FrameSizeModifierRandom(FrameSizeModifier):
    """

    A frame size modifier which will change the size of the frame randomly between a minimum and maximum value.

    .. versionadded:: 2.3.0

    ByteBlower allows different modifiers on a Frame. Some modifiers work on the
    size of a frame, others content. The FrameModifierRandomSize is a modifier
    which modifies the size of the frame.

    A FrameModifierRandomSize will change the frame size randomly. The following
    parameters can be configured:

    Minimum size
        the minimum frame size.

    Maximum size
        the maximum frame size.

    So, a stream with a FrameModifierRandomSize installed, will start sending
    frames with a size randomly chosen between *<Minimum size>* size and
    *<Maximum size>* size. Each time a frame is sent, a new size is selected.

    All sizes are without the additional 4 bytes Ethernet checksum.

    The frame size modifier will change the sizes of the Frames added to the
    stream. If the original frame size is bigger, the size will truncated to the
    requested frame size. If automatic checksum calculations have been enabled on
    the Frame, they will be recalculated. This depends on the configuration of the
    Frame. See the :class:`.Frame` documentation on how this can be done.

    If the original frame size of a Frame is too short, the Frame will be padded
    with zero-value bytes.

    This example will set the maximum frame size to 128 bytes.

    .. code-block:: python

        sizeModifierRandom = frame.ModifierSizeRandomSet()
        sizeModifierRandom.MaximumSet(128)

    """

    __swig_setmethods__ = {}
    for _s in [FrameSizeModifier]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameSizeModifierRandom, name, value)
    __swig_getmethods__ = {}
    for _s in [FrameSizeModifier]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FrameSizeModifierRandom, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def StreamGet(self):
        return _byteblower.FrameSizeModifierRandom_StreamGet(self)

    def MinimumSet(self, inMinimum):
        """

        Sets the Minimum size of a Frame of a flow with FrameModifierRandomSize.

        This defines the minimal frame size of the stream.

        :param minimum: Minimum byte length of the Frame. This value must be at least
                        60 bytes, and maximum 8191. The value must also be less than
                        the *<Maximum size>* configured.
                        Default: `60`

        :raises: python_error: Minimum too small or too big.

        Example

        This example will set the minimum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

            sizeModifierRandom.MinimumSet(128)

        """
        return _byteblower.FrameSizeModifierRandom_MinimumSet(self, inMinimum)


    def MinimumGet(self):
        """

        Method to get the currently configured minimum frame size.

        :return: The minimum frame size which will be used for a random size flow.

        Example

        This example shows how to retrieve the current minimum frame size.

        .. code-block:: python
           :emphasize-lines: 1

            print(sizeModifierRandom.MinimumGet())

        """
        return _byteblower.FrameSizeModifierRandom_MinimumGet(self)


    def MaximumSet(self, inMaximum):
        """

        Sets the Maximum size of a Frame of a flow with FrameModifierRandomSize.

        This defines the maximum frame size of the stream.

        :param maximum: Maximum byte length of the Frame. This value must be at least
                        61 bytes, and maximum 8192. The value must also be bigger than
                        the *<Minimum size>* configured.
                        Default: `1514`

        :raises: python_error: Maximum too small or too big.

        Example

        This example will set the maximum frame size to 128 bytes.

        .. code-block:: python
           :emphasize-lines: 1

            sizeModifierRandom.MaximumSet(128)

        """
        return _byteblower.FrameSizeModifierRandom_MaximumSet(self, inMaximum)


    def MaximumGet(self):
        """

        Method to get the current configured maximum frame size.

        :return: The maximum frame size which will be used for a random size flow.

        Example

        This example shows how to retrieve the current maximum frame size.

        .. code-block:: python
           :emphasize-lines: 1

            print(sizeModifierRandom.MaximumGet())

        """
        return _byteblower.FrameSizeModifierRandom_MaximumGet(self)

FrameSizeModifierRandom_swigregister = _byteblower.FrameSizeModifierRandom_swigregister
FrameSizeModifierRandom_swigregister(FrameSizeModifierRandom)

class FrameResultData(AbstractObject):
    """



    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameResultData, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FrameResultData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(frameData.TimestampGet())

        """
        return _byteblower.FrameResultData_TimestampGet(self)


    def TimestampFirstGet(self):
        """

        Gets  the timestamp [NS] of the first packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                unavailable

        Example

        This example gets the timestamp [NS] of the first transmitted packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(frameData.TimestampFirstGet())

        """
        return _byteblower.FrameResultData_TimestampFirstGet(self)


    def TimestampLastGet(self):
        """

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the last transmitted packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(frameData.TimestampLastGet())

        """
        return _byteblower.FrameResultData_TimestampLastGet(self)


    def PacketCountGet(self):
        """

        Gets the transmitted packets.

        Example

        This example gets the transmitted packets

        .. code-block:: python
           :emphasize-lines: 1

            print(frameData.PacketCountGet())

        """
        return _byteblower.FrameResultData_PacketCountGet(self)


    def ByteCountGet(self):
        """

        Gets the current transmitted bytes.

        Example

        This example gets the transmitted bytes

        .. code-block:: python
           :emphasize-lines: 1

            print(frameData.ByteCountGet())

        """
        return _byteblower.FrameResultData_ByteCountGet(self)


    def FramesizeMaximumGet(self):
        """

        Gets the size (in bytes) of the largest frame transmitted in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the largest framesize transmitted in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameData.FramesizeMaximumGet())

        """
        return _byteblower.FrameResultData_FramesizeMaximumGet(self)


    def FramesizeMinimumGet(self):
        return _byteblower.FrameResultData_FramesizeMinimumGet(self)

    def IntervalDurationGet(self):
        """

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

        	print(frameData.IntervalDurationGet())

        """
        return _byteblower.FrameResultData_IntervalDurationGet(self)

FrameResultData_swigregister = _byteblower.FrameResultData_swigregister
FrameResultData_swigregister(FrameResultData)

class FrameResultSnapshot(AbstractRefreshableResult):
    """

    TODO

    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameResultSnapshot, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FrameResultSnapshot, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.TimestampGet())

        """
        return _byteblower.FrameResultSnapshot_TimestampGet(self)


    def TimestampFirstGet(self):
        """

        Gets the timestamp [NS] of the first packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the first transmitted packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.TimestampFirstGet())

        """
        return _byteblower.FrameResultSnapshot_TimestampFirstGet(self)


    def TimestampLastGet(self):
        """

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the last transmitted packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.TimestampLastGet())

        """
        return _byteblower.FrameResultSnapshot_TimestampLastGet(self)


    def PacketCountGet(self):
        """

        Gets the transmitted packets.

        Example

        This example gets the transmitted packets

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.PacketCountGet())

        """
        return _byteblower.FrameResultSnapshot_PacketCountGet(self)


    def ByteCountGet(self):
        """

        Gets the current transmitted bytes.

        Example

        This example gets the transmitted bytes

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.ByteCountGet())

        """
        return _byteblower.FrameResultSnapshot_ByteCountGet(self)


    def FramesizeMaximumGet(self):
        """

        Gets the size (in bytes) of the largest frame transmitted in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        .. versionadded:: 2.5.0

        Example

        This example gets the largest frame size transmitted in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.FramesizeMaximumGet())

        """
        return _byteblower.FrameResultSnapshot_FramesizeMaximumGet(self)


    def FramesizeMinimumGet(self):
        """

        Gets the size (in bytes) of the smallest frame transmitted in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        .. versionadded:: 2.5.0

        Example

        This example gets the smallest frame size transmitted in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.FramesizeMinimumGet())

        """
        return _byteblower.FrameResultSnapshot_FramesizeMinimumGet(self)


    def IntervalDurationGet(self):
        """

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

            print(frameSnapshot.IntervalDurationGet())

        """
        return _byteblower.FrameResultSnapshot_IntervalDurationGet(self)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp when the counters of this object where last refreshed.

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            frameSnapshot.RefreshTimestampGet()

        """
        return _byteblower.FrameResultSnapshot_RefreshTimestampGet(self)

FrameResultSnapshot_swigregister = _byteblower.FrameResultSnapshot_swigregister
FrameResultSnapshot_swigregister(FrameResultSnapshot)

class FrameResultSnapshotList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameResultSnapshotList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FrameResultSnapshotList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.FrameResultSnapshotList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.FrameResultSnapshotList___nonzero__(self)

    def __bool__(self):
        return _byteblower.FrameResultSnapshotList___bool__(self)

    def __len__(self):
        return _byteblower.FrameResultSnapshotList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.FrameResultSnapshotList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.FrameResultSnapshotList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.FrameResultSnapshotList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.FrameResultSnapshotList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.FrameResultSnapshotList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.FrameResultSnapshotList___setitem__(self, *args)

    def pop(self):
        return _byteblower.FrameResultSnapshotList_pop(self)

    def append(self, x):
        return _byteblower.FrameResultSnapshotList_append(self, x)

    def empty(self):
        return _byteblower.FrameResultSnapshotList_empty(self)

    def size(self):
        return _byteblower.FrameResultSnapshotList_size(self)

    def swap(self, v):
        return _byteblower.FrameResultSnapshotList_swap(self, v)

    def begin(self):
        return _byteblower.FrameResultSnapshotList_begin(self)

    def end(self):
        return _byteblower.FrameResultSnapshotList_end(self)

    def rbegin(self):
        return _byteblower.FrameResultSnapshotList_rbegin(self)

    def rend(self):
        return _byteblower.FrameResultSnapshotList_rend(self)

    def clear(self):
        return _byteblower.FrameResultSnapshotList_clear(self)

    def get_allocator(self):
        return _byteblower.FrameResultSnapshotList_get_allocator(self)

    def pop_back(self):
        return _byteblower.FrameResultSnapshotList_pop_back(self)

    def erase(self, *args):
        return _byteblower.FrameResultSnapshotList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_FrameResultSnapshotList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.FrameResultSnapshotList_push_back(self, x)

    def front(self):
        return _byteblower.FrameResultSnapshotList_front(self)

    def back(self):
        return _byteblower.FrameResultSnapshotList_back(self)

    def assign(self, n, x):
        return _byteblower.FrameResultSnapshotList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.FrameResultSnapshotList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.FrameResultSnapshotList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.FrameResultSnapshotList_reserve(self, n)

    def capacity(self):
        return _byteblower.FrameResultSnapshotList_capacity(self)
    __swig_destroy__ = _byteblower.delete_FrameResultSnapshotList
    __del__ = lambda self: None
FrameResultSnapshotList_swigregister = _byteblower.FrameResultSnapshotList_swigregister
FrameResultSnapshotList_swigregister(FrameResultSnapshotList)

class FrameResultDataList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameResultDataList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FrameResultDataList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.FrameResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.FrameResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.FrameResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.FrameResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.FrameResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.FrameResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.FrameResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.FrameResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.FrameResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.FrameResultDataList___setitem__(self, *args)

    def pop(self):
        return _byteblower.FrameResultDataList_pop(self)

    def append(self, x):
        return _byteblower.FrameResultDataList_append(self, x)

    def empty(self):
        return _byteblower.FrameResultDataList_empty(self)

    def size(self):
        return _byteblower.FrameResultDataList_size(self)

    def swap(self, v):
        return _byteblower.FrameResultDataList_swap(self, v)

    def begin(self):
        return _byteblower.FrameResultDataList_begin(self)

    def end(self):
        return _byteblower.FrameResultDataList_end(self)

    def rbegin(self):
        return _byteblower.FrameResultDataList_rbegin(self)

    def rend(self):
        return _byteblower.FrameResultDataList_rend(self)

    def clear(self):
        return _byteblower.FrameResultDataList_clear(self)

    def get_allocator(self):
        return _byteblower.FrameResultDataList_get_allocator(self)

    def pop_back(self):
        return _byteblower.FrameResultDataList_pop_back(self)

    def erase(self, *args):
        return _byteblower.FrameResultDataList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_FrameResultDataList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.FrameResultDataList_push_back(self, x)

    def front(self):
        return _byteblower.FrameResultDataList_front(self)

    def back(self):
        return _byteblower.FrameResultDataList_back(self)

    def assign(self, n, x):
        return _byteblower.FrameResultDataList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.FrameResultDataList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.FrameResultDataList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.FrameResultDataList_reserve(self, n)

    def capacity(self):
        return _byteblower.FrameResultDataList_capacity(self)
    __swig_destroy__ = _byteblower.delete_FrameResultDataList
    __del__ = lambda self: None
FrameResultDataList_swigregister = _byteblower.FrameResultDataList_swigregister
FrameResultDataList_swigregister(FrameResultDataList)

class FrameResultHistory(AbstractRefreshableResult):
    """

    Sender-side frame transmission result history.

    The history contains the sender information in time since the object is
    created or refreshed.

    .. note:: The information is not updated until :meth:`Refresh` is called

    A Frame history result object can be created via

    - Frame, using :meth:`.Frame.ResultHistoryGet`

    - FrameMobile, using :meth:`.FrameMobile.ResultHistoryGet`

    .. note:: See History result for more information

    .. versionadded:: 2.1.0

    Example

    Get the counters per *sampling interval* for the frame result history.

    .. code-block:: python
       :emphasize-lines: 1

        print(frameData.FrameResultHistory())

    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameResultHistory, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FrameResultHistory, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        """

        Removes the locally stored history snapshots.

        This can be used to save memory in long tests where the results are requested
        at regular intervals.

        .. warning:: Any interval or cumulative result object returned from this
                     history object before calling Clear will be destoyed and thus
                     become unusable.

        """
        return _byteblower.FrameResultHistory_Clear(self)


    def SamplingIntervalDurationGet(self):
        """

        Returns the duration of the interval used for the history snapshots.

        The returned duration is in nanoseconds

        :return: interval in nanoseconds used by the server

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.SamplingIntervalDurationGet())

        """
        return _byteblower.FrameResultHistory_SamplingIntervalDurationGet(self)


    def SamplingIntervalDurationSet(self, inDuration):
        """

        Sets the duration of one sampling interval.

        .. warning:: The previously collected historywill be invalidated.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

            frameHistory.SamplingIntervalDurationSet(1000)

        """
        return _byteblower.FrameResultHistory_SamplingIntervalDurationSet(self, inDuration)


    def SamplingBufferLengthGet(self):
        """

        Returns the number of the snapshots to keep in the history.

        :return: number of snapshots to keep in the history

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.SamplingBufferLengthGet())

        """
        return _byteblower.FrameResultHistory_SamplingBufferLengthGet(self)


    def SamplingBufferLengthSet(self, inCount):
        """

        Sets the number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

            frameHistory.SamplingBufferLengthSet(100)

        """
        return _byteblower.FrameResultHistory_SamplingBufferLengthSet(self, inCount)


    def CumulativeGet(self):
        """

        Returns a list of available accumulated results.

        :return: :class:`FrameResultDataList`

        Example

        This example gets the available accumulated results

        .. code-block:: python
           :emphasize-lines: 1

            historyList = frameHistory.CumulativeGet()

        """
        return _byteblower.FrameResultHistory_CumulativeGet(self)


    def IntervalGet(self):
        """

        Returns a list of available interval results.

        :return: :class:`FrameResultDataList`

        Example

        This example gets the available interval results

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.IntervalGet().DescriptionGet())

        """
        return _byteblower.FrameResultHistory_IntervalGet(self)


    def CumulativeLengthGet(self):
        """

        Returns the size of the cumulative list.

        :return:  The length of the cumulative list

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(frameHistory.CumulativeLengthGet())

        """
        return _byteblower.FrameResultHistory_CumulativeLengthGet(self)


    def IntervalLengthGet(self):
        """

        Returns the size of the interval list.

        :return:  The length of the interval list

        Example

        .. code-block:: python
           :emphasize-lines: 2

            print(frameHistory.IntervalLengthGet())

        """
        return _byteblower.FrameResultHistory_IntervalLengthGet(self)


    def CumulativeGetByIndex(self, index):
        """

        Returns a list of available cumulative counters.

        :return: :class:`FrameResultData`

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 2

            print(frameHistory.CumulativeGetByIndex(0))

        """
        return _byteblower.FrameResultHistory_CumulativeGetByIndex(self, index)


    def IntervalGetByIndex(self, index):
        """

        Returns a list of available interval counters.

        :return: :class:`FrameResultData`

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.IntervalGetByIndex(0).DescriptionGet())



        """
        return _byteblower.FrameResultHistory_IntervalGetByIndex(self, index)


    def CumulativeGetByTime(self, timestamp):
        """

        Returns a single item of the cumulative list using a timestamp nanoseconds.

        :return: :class:`FrameResultData`

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

            print(CumulativeGetByTime(timestamp))

        """
        return _byteblower.FrameResultHistory_CumulativeGetByTime(self, timestamp)


    def IntervalGetByTime(self, timestamp):
        """

        Returns a single item of the interval list using a timestamp in nanoseconds.

        :return: :class:`.FrameResultData`

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.IntervalGetByTime(timestamp))

        """
        return _byteblower.FrameResultHistory_IntervalGetByTime(self, timestamp)


    def CumulativeLatestGet(self):
        """

        Returns latest closed item of the cumulative list.

        :return: :class:`FrameResultData`

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1


            print(frameHistory.CumulativeLatestGet())

        """
        return _byteblower.FrameResultHistory_CumulativeLatestGet(self)


    def IntervalLatestGet(self):
        """

        Returns the latest closed item of the interval list.

        :return: :class:`.FrameResultData`

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.IntervalLatestGet().DescriptionGet())

        """
        return _byteblower.FrameResultHistory_IntervalLatestGet(self)


    def RefreshTimestampGet(self):
        """

        Returns the latest timestamp when the history was refreshed.

        :return:  Timestamp in nanoseconds (since epoch)

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(frameHistory.RefreshTimestampGet())

        """
        return _byteblower.FrameResultHistory_RefreshTimestampGet(self)

FrameResultHistory_swigregister = _byteblower.FrameResultHistory_swigregister
FrameResultHistory_swigregister(FrameResultHistory)

class Frame(AbstractObject):
    """

    Class: Frame

    A ByteBlower Frame is an object representing a Frame which can be used in a
    :class:`Stream` for transmission by a ByteBlower Port.

    A Frame is used in stateless traffic testing. It will be sent by a
    ByteBlowerPort. For each Frame, different options can be enabled:

    1. Tagging

       - Sequence: Defines if a sequence number must be set. This is used for
         out-of-sequence detection.

       - Timestamping: Defines if the timestamp of transmission must be set in the
         frame. This is used for latency measurements.

    2. Checksumming

       - L3: IPv4/IPv6 automatic header checksumming.

       - L4: UDP/TCP automatic checksumming.

    3. Length field correction

       - L3: Automatic correction of the IPv4 length field. This is usefull when
         using a FrameSizeModifier.

       - L7: Automatic correction of the UDP/TCP length field. This is usefull
         when using a FrameSizeModifier.

    Also the frame can be modified during the test
    using modifiers:

    1. Field

       - Incremental: A field in the frame will be incremented every time the frame
         is sent out. The field's position and size is configurable.

       - Random: A field in the frame will be a random value every time the frame
         is sent out. The field's position and size is configurable.

    2. Size

       - GrowingSize: The frame will grow between a minimum and a maximum value.
         When the maximum value is reached, the frame resizes to the given minimum.

       - RandomSize: The frame will have a different size every time it is sent
         out. The sizes will be random between a given minimum and maximum size.


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Frame, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Frame, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def BytesSet(self, frameString):
        """

        A method which sets the content of a Frame in a hexadecimal format.

        This method will change the content of a Frame. A ByteBlower Frame is an
        Ethernet Frame excluding the four CRC bytes. The value can be in different
        formats, e.g.

        1. 0x01 0x02 0x03 0x04 0x05 ...

        2. 0001020304050607

        3. 00 01 02 03 04 05 ...

        .. note:: You can call this method even during transmission of a flow, the
                  value will be updated in real-time.

        :raises: ByteBlower.Exception.ConfigError - when the value does contain
                 non-hexadecimal characters or when the length is not even.

        :param bytes: Bytes can be of any of the formats mentioned above.
                      The length must be at least 60 bytes

        :raises: :exc:`.ConfigError` when the frame is too small (<60 bytes) or when
                 the frame is too big (>8192)

        Example

        .. code-block:: python
           :caption: Set the content for a frame

           # Layer2 (without CRC) size.
           frame_size = 1000  # bytes

           # Add a frame
           frame = stream.FrameAdd()

           # create some payload, we need scapy for that

           # frame_size is ethernet length, we substract the length of the
           # ethernet, IP and UDP header
           payload = 'a' * (frame_size - 42)

           from scapy.layers.inet import Raw
           scapy_udp_payload = Raw(payload.encode('ascii', 'strict'))

           payload_array = bytearray(bytes(scapy_udp_payload))

           # The API expects a 'str', so we need to make a string of the payload
           payload_str = ''.join((format(b, '02x') for b in payload_array)

           frame.BytesSet(payload_str)


        """
        return _byteblower.Frame_BytesSet(self, frameString)


    def BytesGet(self):
        """

        A method which returns the current content of a Frame in a hexadecimal format.

        This method will return the current content of a Frame. A ByteBlower Frame is an
        Ethernet Frame, excluding the frame check sequence ( aka CRC ).

        .. note:: The real content of a Frame can differ if Modifiers such as the
                  FrameSizeModifier are applied on the Flow containing this Frame.

        :return: This method returns the content in a hexadecimal string. All bytes are
                 concatenated into one string.

        Example

        The current content of a frame can be requested like this:

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.BytesGet())

        """
        return _byteblower.Frame_BytesGet(self)


    def FrameTagTimeGet(self):
        """

        Returns the FrameTagTx object related to the timestamp injection for this frame.

        Each frame can be enabled to have a timestamp inserted into the frame.

        The :class:`FrameTagTx` object which is returned by this method represents the
        current configuration of the TimeTag injection. This object can be used to
        configure the TimeTag injection.

        For more detailed information about Frame tagging, you can also take a look at
        ByteBlower API Knowledgebase: Background: Adding FrameTags to your ByteBlower
        frame - structure and behaviour

        .. warning:: On older ByteBlower servers, this requires a lot of resources, so
                     this option must be used with care.

        .. versionadded:: 1.8.18

        :return: :class:`.FrameTagTx` object for TimeTag injection of this frame.

        Example

        In this example, we will retrieve the FrameTagTx object for the TimeTag:

        .. code-block:: python
           :emphasize-lines: 3

           print(frame.FrameTagTimeGet().DescriptionGet())

        """
        return _byteblower.Frame_FrameTagTimeGet(self)


    def FrameTagSequenceGet(self):
        """

        Returns the FrameTag.Tx object related to the sequence number injection for this frame.

        Each frame can be enabled to have a sequence number inserted into the frame.

        The :class:`.FrameTagTx` object which is returned by this method represents
        the current configuration of the SequenceTag injection. This object can be
        used to configure the SequenceTag injection.

        .. warning:: On older ByteBlower servers, this requires a lot of resources, so
                     this option must be used with care.

        .. versionadded:: 1.8.18

        :return: :class:`.FrameTagTx`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(frame.FrameTagSequenceGet().DescriptionGet())


        """
        return _byteblower.Frame_FrameTagSequenceGet(self)


    def L3AutoChecksumEnable(self, value):
        """

        Enable or disable the automatic checksum calculation of the Layer3 header of this frame.

        This method provides the possibility to automatically recalculate the Layer3
        checksum. Currently, only IPv4 is supported ( IPv6 has no header checksum ).
        This calculation will be done at the server side, just before transmitting the
        frame.

        By default, the Layer3 checksum will not be calculated automatically.

        .. warning:: On the ByteBlower 1000 series, this feature requires a lot of
                     resources.

        .. note:: This features is especially handy when combining a frame with a
                  modifier like the FrameSizeModifier or with a FrameTag. In such a
                  situation, the length or content of the Frame will change each time
                  the frame has been sent, so the checksum must be calculated at the
                  server side.

        Default value: Disabled

        :raises: ByteBlower.Exception.InvalidValue - when the value is not True or False

        :param enable: bool: True will enable the automatic Layer3 checksum
                       calculation. False will disable the automatic Layer3 checksum
                       calculation.

        Example

        This example will enable the automatic Layer3 checksum calculation:

        .. code-block:: python
           :emphasize-lines: 1

           frame.L3AutoChecksumEnable(True)

        """
        return _byteblower.Frame_L3AutoChecksumEnable(self, value)


    def L3AutoChecksumGet(self):
        """

        Method returning the current configuration of the automatic checksum calculation option.

        This method returns the current configuration of the automatic Layer3 checksum
        calculation.

        See :meth:`.Frame.L3AutoChecksumEnable` on how to enable this feature.

        Default value: Disabled

        :return: True if enabled, False if disabled.

        Example

        This examples shows the result when the Layer3 automatic checksum calculation
        option is enabled:

        .. code-block:: python
           :emphasize-lines: 1

        	print(frame.L3AutoChecksumGet())

        """
        return _byteblower.Frame_L3AutoChecksumGet(self)


    def L3AutoLengthEnable(self, value):
        """

        Enable or disable the automatic Layer3 header length field calculation of this frame.

        This method provides the possibility to automatically recalculate the Layer3
        length field. This calculation will be done at the server side, just before
        transmitting the frame.

        Default value: Disabled

        .. warning:: On the ByteBlower 1000 series, this feature requires a lot of
                     resources.

        .. note:: This features is especially handy when combining a frame with a
                  modifier like the :class:`.FrameSizeModifier`. In such a situation,
                  the length of the Frame can change each time the frame has been sent,
                  so the length field must be adapted at the server side.

        :raises: ByteBlower.Exception.InvalidValue - when the value is not true or
                 false

        :param enable: bool: True will enable the automatic Layer3 length field
                       adaption. False will disable the automatic Layer3 length field
                       adaption.

        Example

        This example will enable the automatic Layer3 length field adaption: This
        example will disable the automatic Layer3 length field adaption:

        .. code-block:: python
           :emphasize-lines: 1

        	frame.L3AutoLengthEnable(True)

        """
        return _byteblower.Frame_L3AutoLengthEnable(self, value)


    def L3AutoLengthGet(self):
        """

        Method returning the current configuration of the automatic Layer3 length field adaption option.

        This method returns the current configuration of the automatic Layer3 length
        field adaption.

        See :meth:`.Frame.L3AutoLengthEnable` on how to enable this option.

        Default value: Disabled

        :return: True if enabled, False if disabled.

        Example

        This examples shows the result when the automatic Layer3 length field
        adaption option is enabled:

        .. code-block:: python
        	:emphasize-lines: 1

        	print(frame.L3AutoLengthGet())


        """
        return _byteblower.Frame_L3AutoLengthGet(self)


    def L4AutoChecksumEnable(self, value):
        """

        Enable or disable the automatic Layer4 checksum calculation of this frame.

        This method provides the possibility to automatically recalculate the Layer4
        (UDP or TCP) checksum. This calculation will be done at the server side, just
        before transmitting the frame.

        Default value: Disabled

        .. warning:: On the ByteBlower 1000 series, this feature requires a lot of
                     resources.

        .. note:: This features is especially handy when combining a frame with a
                  modifier like the FrameSizeModifier or FrameTag. In such a situation,
                  the length or content of the Frame can change each time the frame has
                  been sent, so the checksum must be recalculated at the server side.

        :raises: ByteBlower.Exception.InvalidValue - when the value is not true or false

        :param enable: bool: True will enable the automatic Layer4 checksum
                       calculation. False will enable the automatic Layer4 checksum
                       calculation.

        Example

        This example will enable the automatic Layer4 checksum calculation:  This
        example will disable the automatic Layer3 checksum calculation:

        .. code-block:: python
           :emphasize-lines: 1

        	frame.L4AutoChecksumEnable(True)


        """
        return _byteblower.Frame_L4AutoChecksumEnable(self, value)


    def L4AutoChecksumGet(self):
        """

        Method returning the current configuration of the automatic Layer4 checksum recalculation option.

        This method returns the current configuration of the automatic Layer4 checksum
        recalculation.

        See :meth:`.Frame.L4AutoChecksumEnable` on how to enable this option.

        Default value: Disabled

        :return: True if enabled, False if disabled.

        Example

        This examples shows the result when the automatic Layer4 checksum recalculation
        option is enabled:

        .. code-block:: python
           :emphasize-lines: 1

        	print(frame.L4AutoChecksumGet()

        """
        return _byteblower.Frame_L4AutoChecksumGet(self)


    def L4AutoLengthEnable(self, value):
        """

        Enable or disable the automatic Layer4 header length field calculation of this frame.

        This method provides the possibility to automatically recalculate the Layer4
        (UDP or TCP) length field. This calculation will be done at the server side,
        just before transmitting the frame.

        Default value: Disabled

        .. warning:: On the ByteBlower 1000 series, this feature requires a lot of resources.

        .. note:: This features is especially handy when combining a frame with a
                  modifier like the FrameSizeModifier. In such a situation, the length
                  of the Frame can change each time the frame has been sent, so the
                  length field must be adapted at the server side.

        :raises: ByteBlower.Exception.InvalidValue - when the value is not true or
                 false

        :param enable: bool: True will enable the automatic Layer4 length field
                       adaption.  False will enable the automatic Layer4 length field
                       adaption.

        Example

        This example will enable the automatic Layer4 length field adaption:

        .. code-block:: python
           :emphasize-lines: 1

           frame.L4AutoLengthEnable(True)

        """
        return _byteblower.Frame_L4AutoLengthEnable(self, value)


    def L4AutoLengthGet(self):
        """

        Method returning the current configuration of the automatic Layer4 length field adaption option.

        This method returns the current configuration of the automatic Layer4 length
        field adaption.

        See :meth:`L4AutoLengthEnable` on how to enable this option.

        Default value: Disabled

        :return: True if enabled, False if disabled.

        Example

        This examples shows the result when the automatic Layer4 length field adaption
        option is enabled:

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.L4AutoLengthGet())

        """
        return _byteblower.Frame_L4AutoLengthGet(self)


    def StreamGet(self):
        return _byteblower.Frame_StreamGet(self)

    def SetL3AutoChecksum(self, b):
        return _byteblower.Frame_SetL3AutoChecksum(self, b)

    def SetL3AutoLength(self, set):
        return _byteblower.Frame_SetL3AutoLength(self, set)

    def SetL4AutoChecksum(self, set):
        return _byteblower.Frame_SetL4AutoChecksum(self, set)

    def SetL4AutoLength(self, set):
        return _byteblower.Frame_SetL4AutoLength(self, set)

    def IsL3AutoChecksumEnabled(self):
        return _byteblower.Frame_IsL3AutoChecksumEnabled(self)

    def IsL3AutoLengthEnabled(self):
        return _byteblower.Frame_IsL3AutoLengthEnabled(self)

    def IsL4AutoChecksumEnabled(self):
        return _byteblower.Frame_IsL4AutoChecksumEnabled(self)

    def IsL4AutoLengthEnabled(self):
        return _byteblower.Frame_IsL4AutoLengthEnabled(self)

    def ModifierFieldIncrementalAdd(self):
        """

        Adds an incremental frame field modifier.

        .. versionadded:: 2.5.0

        :return:  :class:`FrameFieldModifierIncremental`

        Example

        This example adds an incremental value frame field modifier.

        .. code-block:: python
           :emphasize-lines: 1

           frame.ModifierFieldIncrementalAdd()

        """
        return _byteblower.Frame_ModifierFieldIncrementalAdd(self)


    def ModifierFieldIncrementalGet(self):
        """

        Returns the active incremental frame field modifier(s).

        .. versionadded:: 2.5.0

        :return: :class:`FrameFieldModifierIncremental`

        Example

        This example retrieves the current applied field modifiers.

        .. code-block:: python
           :emphasize-lines: 1

        	print(frame.ModifierFieldIncrementalGet()[0].DescriptionGet())

        """
        return _byteblower.Frame_ModifierFieldIncrementalGet(self)


    def ModifierFieldIncrementalDestroy(self, inModifier):
        return _byteblower.Frame_ModifierFieldIncrementalDestroy(self, inModifier)

    def ModifierFieldRandomAdd(self):
        """

        Adds a random frame field modifier.

        .. versionadded:: 2.5.0

        :return: :class:`.FrameFieldModifierRandom`

        Example

        This example adds a random value frame field modifier.

        .. code-block:: python
           :emphasize-lines: 1

        	frameFieldModifierRandom = frame.ModifierFieldRandomAdd()

        """
        return _byteblower.Frame_ModifierFieldRandomAdd(self)


    def ModifierFieldRandomGet(self):
        """

        Returns the active random frame field modifier(s).

        .. versionadded:: 2.5.0

        :return: :class:`FrameFieldModifierRandom`

        Example

        This example retrieves the current applied field modifiers.

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.ModifierFieldRandomGet()[0].DescriptionGet())

        """
        return _byteblower.Frame_ModifierFieldRandomGet(self)


    def ModifierFieldRandomDestroy(self, inModifier):
        return _byteblower.Frame_ModifierFieldRandomDestroy(self, inModifier)

    def ModifierSizeGet(self):
        return _byteblower.Frame_ModifierSizeGet(self)

    def ModifierSizeGrowingSet(self):
        """

        Sets a growing frame size modifier.

        .. versionadded:: 2.5.0

        :return: :class:`FrameSizeModifierGrowing`

        Example

        This example sets a growing size frame modifier.

        .. code-block:: python
           :emphasize-lines: 1

           growSizeMod = frame.ModifierSizeGrowingSet()


        """
        return _byteblower.Frame_ModifierSizeGrowingSet(self)


    def ModifierSizeRandomSet(self):
        """

        Sets a random frame size modifier.

        .. versionadded:: 2.5.0

        :return: :class:`.FrameSizeModifierRandom`

        Example

        This example sets a random size frame modifier.

        .. code-block:: python
           :emphasize-lines: 1

        	frame.ModifierSizeRandomSet()

        """
        return _byteblower.Frame_ModifierSizeRandomSet(self)


    def ModifierSizeGrowingGet(self):
        """

        Returns the active frame growing size modifier.

        .. versionadded:: 2.5.0

        :return: :class:`FrameSizeModifierGrowing`.

        Example

        This example gets the current applied growing size modifier

        .. code-block:: python
           :emphasize-lines: 1

        	print(frame.ModifierSizeGrowingGet().DescriptionGet())

        """
        return _byteblower.Frame_ModifierSizeGrowingGet(self)


    def ModifierSizeRandomGet(self):
        """

        Returns the active frame random size modifier.

        .. versionadded:: 2.5.0

        :return: :class:`.FrameSizeModifierRandom`

        Example

        This example gets the current applied size modifier. E.g. the random

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.ModifierSizeRandomGet().DescriptionGet())

        """
        return _byteblower.Frame_ModifierSizeRandomGet(self)


    def ModifierSizeGrowingDestroy(self, arg2):
        return _byteblower.Frame_ModifierSizeGrowingDestroy(self, arg2)

    def ModifierSizeRandomDestroy(self, arg2):
        return _byteblower.Frame_ModifierSizeRandomDestroy(self, arg2)

    def ResultClear(self):
        """

        Resets the current transmit counters to zero.

        .. versionadded:: 2.1.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

           frame.resultClear()

        """
        return _byteblower.Frame_ResultClear(self)


    def ResultGet(self):
        """

        Returns the current transmit counters.

        :return: :class:`.FrameResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(frame.ResultGet().DescriptionGet())

        """
        return _byteblower.Frame_ResultGet(self)


    def ResultHistoryGet(self):
        """



        """
        return _byteblower.Frame_ResultHistoryGet(self)

Frame_swigregister = _byteblower.Frame_swigregister
Frame_swigregister(Frame)

class FrameMobile(AbstractObject):
    """

    A FrameMobile is an object that configures the payload of a frame belonging to a StreamMobile object.

    A FrameMobile object is used for frame blasting. It is configured by a
    :class:`.StreamMobile` object and will be transmitted by the WirelessEndpoint.

    .. versionadded:: 2.6.0

    Example

    This example will show how to add a frame to a stream and configure the payload.

    .. code-block:: python
       :emphasize-lines: 3

    	frame = stream.FrameAdd()
    	frame_tag = frame.FrameTagTimeGet()

    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameMobile, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FrameMobile, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def FrameTagTimeGet(self):
        """

        Returns the FrameTagTx object related to the timestamp injection for this frame.

        Each frame can be enabled to have a timestamp inserted into the frame.

        The :class:`.FrameTagTx` object which is returned by this method represents the
        current configuration of the TimeTag injection. This object can be used to
        configure the TimeTag injection.

        For more detailed information about Frame tagging, you can also take a look at
        ByteBlower API Knowledgebase: Background: Adding FrameTags to your ByteBlower
        frame - structure and behaviour

        .. warning:: this requires extra resources, so this option must be used with
                     care.

        .. versionadded:: 2.6.0

        :return: :class:`.FrameTagTx`.

        Example

        In this example, we will retrieve the FrameTagTx object for the TimeTag:

        .. code-block:: python
           :emphasize-lines: 1

        	frame_tag = frame.FrameTagTimeGet()

        """
        return _byteblower.FrameMobile_FrameTagTimeGet(self)


    def PayloadSet(self, payloadString):
        """

        A method which sets the payload of a frame.

        This method will change the payload of the frame. The value can be in different
        formats, e.g.

        1.  0x01 0x02 0x03 0x04 0x05 ...

        2.  0001020304050607

        3.  00 01 02 03 04 05 ...

        :param bytes: Bytes can be of any of the above formats

        Example

        The content of a frame can be set like this:

        .. code-block:: python
           :emphasize-lines: 1

        	frame.PayloadSet('0001020304050607')

        """
        return _byteblower.FrameMobile_PayloadSet(self, payloadString)


    def PayloadGet(self):
        """

        A method which returns the payload of a frame.

        This method will return the UDP payload of the frame in a hexadecimal format.

        :return: This method returns the content in a hexadecimal string. All bytes are
                 concatenated into one string.

        Example

        The current content of a frame can be requested like this:

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.PayloadGet())

        """
        return _byteblower.FrameMobile_PayloadGet(self)


    def StreamGet(self):
        return _byteblower.FrameMobile_StreamGet(self)

    def ResultClear(self):
        """

        Clears the transmit counters.

        This method will clear the transmit counters for this frame.

        .. code-block:: python
           :emphasize-lines: 1

        	frame.ResultClear()

        """
        return _byteblower.FrameMobile_ResultClear(self)


    def ResultGet(self):
        """

        Returns the transmit counters.

        :return: :class:`FrameResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(frame.ResultGet().DescriptionGet())

        """
        return _byteblower.FrameMobile_ResultGet(self)


    def ResultHistoryGet(self):
        """

        Returns the current transmit history counters.
        :return: an object representing the frame result history
        :rtype: :class:`.FrameResultHistory`

        """
        return _byteblower.FrameMobile_ResultHistoryGet(self)

FrameMobile_swigregister = _byteblower.FrameMobile_swigregister
FrameMobile_swigregister(FrameMobile)

class FrameTag(AbstractObject):
    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameTag, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FrameTag, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def TypeGet(self):
        return _byteblower.FrameTag_TypeGet(self)

    def FormatGet(self):
        return _byteblower.FrameTag_FormatGet(self)

    def FormatStringGet(self):
        return _byteblower.FrameTag_FormatStringGet(self)

    def MetricsGet(self):
        return _byteblower.FrameTag_MetricsGet(self)

    def PositionGet(self):
        return _byteblower.FrameTag_PositionGet(self)

    def PositionSet(self, newPosition):
        return _byteblower.FrameTag_PositionSet(self, newPosition)

    def FormatDestroy(self):
        return _byteblower.FrameTag_FormatDestroy(self)

    def MetricsDestroy(self):
        return _byteblower.FrameTag_MetricsDestroy(self)
FrameTag_swigregister = _byteblower.FrameTag_swigregister
FrameTag_swigregister(FrameTag)

class FrameTagTx(FrameTag):
    """

    The FrameTagTx class describes the transmit configuration of a Tag in a Frame.

    ByteBlower supports optional tagging of frames. Such a tag can have different
    formats, locations, ...
    These parameters can be set and retrieved using this class.

    Currently, two different types of FrameTags are supported:

    SequenceTag
        is used for out of sequence detection and contains a frame counter value.
        The server automatically increments it for each frame sent in the stream.

    TimeTag
        is used for latency measurements and contains a timestamp value. The server
        automatically determines it by looking at its clock for each frame sent in
        the stream.

    Adding tags is a very powerful and flexible feature of ByteBlower. Please have
    a look at ByteBlower API Knowledgebase: Background: Adding FrameTags to your
    ByteBlower frame - structure and behaviour for a very detailed explanation.

    To perform latency measurements or out of sequence detection, configuration
    needs to be done both at TX and RX side:

    - At the TX side

      we need to add the FrameTag(s) to the Frame object.

    - At the RX side

      we need to create the appropriate receiver(s) on the incoming packets. This
      causes the server to read a tag from the received frames and interpret them
      (e.g. by calculating latency based on the timestamps).

    """

    __swig_setmethods__ = {}
    for _s in [FrameTag]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameTagTx, name, value)
    __swig_getmethods__ = {}
    for _s in [FrameTag]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FrameTagTx, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PositionGet(self):
        """

        The current configured location of the tag within the Frame.

        A user can choose where in a the Frame a tag will be placed (TX) or looked for
        (RX).

        This position is configured relative to the end of the frame in units of bytes.
        This eliminates the complexity caused by VLAN tagging or other protocols that
        may influence the header structure of a frame.

        The meaning of the position value is shown like this:

            |                                                 |      Position
            |                                                 | <---------------------|
            +-------------------------------------------------+-----+-----------------+
            |                                                 | TAG |                 |
            +-------------------------------------------------+-----+-----------------+

        If no position is specified by the user, the server sert (TX) or look for (RX)
        the tag at a default location.

        This method returns the current configured value for this position.

        Default value

        - At the TX side, the default position places the tag at the end of the frame,
          without overlapping with other enabled tags.

        - At the RX side, the default position is the length of the tag. This means the
          RX side guesses the location of the tag to be at the very end of the frame.
          Note that this guess is incorrect if multiple tags are enabled on a single
          frame!

        :return: Current configured position. If nothing was specified, the default
                 position chosen by the server is returned.

        Example

        This example will return the position of a sequence tag:

        .. code-block:: python
           :emphasize-lines: 1

            print(frameTagtx.PositionGet())

        """
        return _byteblower.FrameTagTx_PositionGet(self)


    def PositionSet(self, newPosition):
        """

        Sets the location of the tag in the Frame.

        A user can choose where in a the Frame a tag will be placed (TX) or looked for
        (RX).

        This position is configured relative to the end of the frame in units of bytes.
        This eliminates the complexity caused by VLAN tagging or other protocols that
        may influence the header structure of a frame.

        The meaning of the position value is shown like this:
            |                                                 |        Position
            |                                                 | <---------------------|
            +-------------------------------------------------+-----------------------+
            |                                                 | TAG |                 |
            +-------------------------------------------------+-----------------------+

        If no position is specified by the user, the server sert (TX) or look for (RX)
        the tag at a default location.

        This method allows the user to configure this value.

        :param position: The new value of the position. This value must be between
                         *<taglength>* and *<framelength>*.

        Example

        This example will sets the position of a sequence tag:

        .. code-block:: python
           :emphasize-lines: 1

            frameTagtx.PositionSet(9)

        """
        return _byteblower.FrameTagTx_PositionSet(self, newPosition)


    def Enable(self, set):
        """

        Method to enable the tag on the Frame.

        This will activate the tag on the Frame, and apply its configuration. As long
        as this method is not called, the tag will not be active.

        .. note:: the configuration of other enabled frames may change when this frame is
                  disabled.

        Default value: Disabled

        Example

        To enable the sequence tag on frame, one can do:

        .. code-block:: python
           :emphasize-lines: 1

            print(frameTagtx.Enable())

        """
        return _byteblower.FrameTagTx_Enable(self, set)


    def IsEnabled(self):
        """

        Method which will return whether a tag is activated or not.

        This method is used to retrieve the current state of the tag. If this tag is
        activated/enabled, true is returned. Otherwise, this method will return false.

        Default value: Disabled

        :return:  True if enabled, false if disabled.

        Example

        To see if a timestamp tag is enabled on a frame, this code can be used:

        .. code-block:: python
           :emphasize-lines: 2

        	frameTagtx = frame.FrameTagSequenceGet()
            print(frameTagtx.IsEnabled())

        """
        return _byteblower.FrameTagTx_IsEnabled(self)


    def PositionAutomaticSet(self):
        """

        This method will use the automatic position for
        the tag.

        ByteBlower is very flexible in positioning the tag, and the combination of
        different tags. If the position of the tag is not important, the automatic
        positioning of tags is the easiest way for the user.

        .. note:: The automatic position is used by default. This method is only useful
                  when you want to reset positions that were previously set by the user.

        Automatic placement of FrameTags has multiple advantages:

        1. it shields the API user from the complexity described above

        2. it makes sure the requirements are respected:

           the position will always be larger than the tag length and multiple tags
           will never overlap

        3. it places the tags as close towards the end as possible to allow tagging
           small frames without overwriting frame headers

        Tags are automatically placed at the end of the frame. If both Tags are enabled
        and have an automatic position, the SequenceTag is placed in front of the
        TimeTag.

        If a tag has an explicit position, this is always respected. The automatic
        position will adapt to it as follows:

        1. If there is enough place after the fixed tag to fit the automatic tag, the
           automatic tag is placed behind it (at the end of the frame).

        2. If there is not enough place after the fixed tag to fit the automatic tag,
           the automatic tag is placed right in front of the fixed tag.

        Default value: Enabled

        Example

        In this example, we will reset the position of the sequence tag to automatic.

        .. code-block:: python
           :emphasize-lines: 1

            frameTagtx.PositionAutomaticSet()

        """
        return _byteblower.FrameTagTx_PositionAutomaticSet(self)

FrameTagTx_swigregister = _byteblower.FrameTagTx_swigregister
FrameTagTx_swigregister(FrameTagTx)

class FrameTagFormat(AbstractObject):
    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameTagFormat, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FrameTagFormat, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TypeGet(self):
        return _byteblower.FrameTagFormat_TypeGet(self)

    def TimeStampFormatGet(self):
        return _byteblower.FrameTagFormat_TimeStampFormatGet(self)

    def SequenceNumberFormatGet(self):
        return _byteblower.FrameTagFormat_SequenceNumberFormatGet(self)

    def FormatStringGet(self):
        return _byteblower.FrameTagFormat_FormatStringGet(self)
FrameTagFormat_swigregister = _byteblower.FrameTagFormat_swigregister
FrameTagFormat_swigregister(FrameTagFormat)

class FrameTagMetrics(AbstractObject):
    """

    Class which represents the metrics of a FrameTag.

    The metrics of a tag are parameters describing the length and byte alignment of
    a frame.

    The metrics can only be read, because they are determined by the tag format and
    the server type.

    .. code-block:: python
       :emphasize-lines: 2

    	metric = frameTagtx.MetricsGet()
        print(metric.AlignmentGet())

    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameTagMetrics, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FrameTagMetrics, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def LengthGet(self):
        """

        Returns the length of the tag.

        The number of bytes in a Frame that will be overwritten by this tag.

        .. note:: This byte range does not need to be contiguous! More specifically,
                  if the tag alignment is larger than one, a single byte containing
                  the offset to the aligned tag may be stored separately.

        :return: The length of the tag in bytes.

        Example

        This example shows the how to retrieve the length of a sequence tag:

        .. code-block:: python
           :emphasize-lines: 1

            print(metric.LengthGet())

        """
        return _byteblower.FrameTagMetrics_LengthGet(self)


    def AlignmentGet(self):
        """

        Returns the alignment value for this tag.

        Some frame tags must be aligned with the start of a frame. This means the tag
        must start at a multiple of *<x>* bytes within a frame, where *<x>* is the
        alignment value. The default value is one.

        Frame alignment requirements are caused by hardware limitations as a new tag
        must be included in every frame that is sent.

        :return: The alignment value of this tag.

        Example

        This example illustrates how the alingment value of a timestamp tag can be retrieved;

        .. code-block:: python
           :emphasize-lines: 1

            print(metric.AlignmentGet())

        """
        return _byteblower.FrameTagMetrics_AlignmentGet(self)


    def FrameTagGet(self):
        return _byteblower.FrameTagMetrics_FrameTagGet(self)
FrameTagMetrics_swigregister = _byteblower.FrameTagMetrics_swigregister
FrameTagMetrics_swigregister(FrameTagMetrics)

class FrameTagRx(FrameTag):
    """

    The FrameTagRx class describes the receive configuration of a Tag in a Frame.

    ByteBlower supports optional tagging of frames. Such a tag can have different
    formats, locations, ... These parameters can be set and retrieved using this
    class.

    Currently, two different types of FrameTags are supported:

    - Sequence Number: A tag which contains the sequence number within the stream.
    - Timestamp: A tag containing the timestamp this frame has left the transmit
      interface.

    Adding tags is a very powerful and flexible feature of ByteBlower. Please have
    a look at ByteBlower API Knowledgebase:
    Background: Adding FrameTags to your ByteBlower frame - structure and behaviour
    for a detailed explanation.

    This class is represents the :class:`.FrameTag` configuration at the receiving
    side of the flow.

    In typical situations this configuration must not be changed.

    """

    __swig_setmethods__ = {}
    for _s in [FrameTag]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameTagRx, name, value)
    __swig_getmethods__ = {}
    for _s in [FrameTag]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FrameTagRx, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PositionGet(self):
        """

        Returns the current configured location of the tag within the Frame.

        A user can choose where in a the Frame a tag will be placed (TX) or looked
        for (RX).

        This position is configured relative to the end of the frame in units of bytes.
        This eliminates the complexity caused by VLAN tagging or other protocols that
        may influence the header structure of a frame.

        The meaning of the position value is shown like this:

            |                                                               Position
            |                                                | <---------------------|
            +------------------------------------------------+----------------+------+
            |                                                | TAG            |      |
            +------------------------------------------------+----------------+------+

        If no position is specified by the user, the server sert (TX) or look for (RX)
        the tag at a default location.

        This method returns the current configured value for this position.

        Default value

        - At the TX side, the default position places the tag at the end of the frame,
          without overlapping with other enabled tags.
        - At the RX side, the default position is the length of the tag. This means the
          RX side guesses the location of the tag to be at the very end of the frame.
          Note that this guess is incorrect if multiple tags are enabled on a single frame!

        :return: Current configured position. If nothing was specified, the default
                 position chosen by the server is returned.

        Example

        This example will return the position of a
        sequence tag:

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO

        """
        return _byteblower.FrameTagRx_PositionGet(self)


    def PositionSet(self, newPosition):
        """

        Sets the location of the tag in the Frame.

        A user can choose where in a the Frame a tag will be placed (TX) or looked for
        (RX).

        This position is configured relative to the end of the frame in units of bytes.
        This eliminates the complexity caused by VLAN tagging or other protocols that
        may influence the header structure of a frame.

        The meaning of the position value is shown like this:

            |                                                               Position
            |                                                | <---------------------|
            +------------------------------------------------+---------------+-------+
            |                                                | TAG           |       |
            +------------------------------------------------+---------------+-------+

        If no position is specified by the user, the server sert (TX) or look for (RX)
        the tag at a default location.

        This method allows the user to configure this value.

        :param position: The new value of the position. This value must be between
                         *<taglength>* and *<framelength>*.

        Example

        This example will sets the position of a sequence tag:

        TODO


        """
        return _byteblower.FrameTagRx_PositionSet(self, newPosition)


    def FormatSet(self, fromFrameTagFormat):
        return _byteblower.FrameTagRx_FormatSet(self, fromFrameTagFormat)

    def FormatSetFromString(self, formatString):
        """

        Method to set the format by name.

        This method allows to set the format by name.

        See also: :meth:`.FrameTagRx.FormatStringGet` for details on the tag formats.

        :param format: This defines the format of the tag, the following format strings
                       are currently  supported:

                       TimeStamp-Microseconds_CRC Timestamp in microseconds followed by a
                       CRC. Not supported since 2.9.0
                       TimeStamp-10Nanoseconds Timestamp in nanoseconds.
                       SequenceNumber-0_CRC Sequence number followed by a CRC.

        Example

        In this example, we set the format of the timestamp to 10 nanoseconds.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO

        """
        return _byteblower.FrameTagRx_FormatSetFromString(self, formatString)


    def FormatDefaultSet(self):
        """

        Sets the format to the native, default format.

        This method sets the format to the default value.
        The default value depends on server type:

        For sequence tags, the default value is the same for all systems
        *<SequenceNumber-0_CRC>*.

        For time tags, the default value is *<TimeStamp-10Nanoseconds>*. However, on
        1000 series servers with a software version before 1.10.18, the
        *<TimeStamp-Microseconds_CRC>* format is used instead.

        :raises: ByteBlower.Rx.Counter.Unsupported -  The format string is a valid
                 value, but is not supported by the server.
        :raises: <python_error> - The format string is not a valid value.

        Example
        In this example, we restore the format of a sequence tag to the default format:

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO

        """
        return _byteblower.FrameTagRx_FormatDefaultSet(self)


    def MetricsSet(self, fromFrameTagMetrics):
        """

        Sets the metric of the tag.

        This method allows to copy the metrics of a FrameTagTx to the receive side of a flow.

        Note that it is often better to copy the complete TX tag configuration to the
        receive side of a flow. See :meth:`LatencyBasic.FrameTagSet` for an example.

        :param metrics: This parameter is an object of type :class:`.FrameTagMetrics` .

        Example

        This example demonstrates how you can set the metrics of a frame on the
        receiving object. The configuration is simply copied from the TX side.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO

        """
        return _byteblower.FrameTagRx_MetricsSet(self, fromFrameTagMetrics)


    def MetricsDefaultSet(self):
        """

        Sets the metrics to the default values.

        This method restores the metrics to the default value.

        Currently, both the sequence tag and time tag have metrics with an alignment of
        1 bytes and a size of 8 bytes on all servers types and versions.

        Example

        This example restores the default metrics of a sequence tag.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO

        """
        return _byteblower.FrameTagRx_MetricsDefaultSet(self)


    def PositionDefaultSet(self):
        """

        This restores the position to the default value.

        This method restores the default value for the position. By default, the tag is
        put at the end of the frame. This will restore the position of the receiving
        object to its default.

        Example

        This example restores the position of the sequence tag to the default value.

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO

        """
        return _byteblower.FrameTagRx_PositionDefaultSet(self)

FrameTagRx_swigregister = _byteblower.FrameTagRx_swigregister
FrameTagRx_swigregister(FrameTagRx)

class Trigger(Rx):
    __swig_setmethods__ = {}
    for _s in [Rx]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Trigger, name, value)
    __swig_getmethods__ = {}
    for _s in [Rx]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Trigger, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
Trigger_swigregister = _byteblower.Trigger_swigregister
Trigger_swigregister(Trigger)

class TriggerBasicResultSnapshot(AbstractRefreshableResult):
    """

    Receive-side trigger result set.  

    The result set contains the trigger information of since the object is created
     or refreshed.  

    .. note:: The information is not updated until :meth:`Refresh` is called  

    .. note:: See What's new in API v2 for more information.  

    A basic trigger result snapshot object can be created via a 
    :class:`.TriggerBasic`, using :meth:`.TriggerBasic.ResultGet`  

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.  

    .. code-block:: python

    	result = trigger.ResultGet()
    	print(result.PacketCountGet())



    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TriggerBasicResultSnapshot, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TriggerBasicResultSnapshot, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].  

        :return: Timestamp of snapshot in nanoseconds  

        Example

        This example gets the snapshot timestamp [NS].  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.TimestampGet())



        """
        return _byteblower.TriggerBasicResultSnapshot_TimestampGet(self)


    def TimestampFirstGet(self):
        """

        Gets the timestamp [NS] of the first packet in this snapshot.  

        :return: Timestamp of the first received packet in nanoseconds  

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.TimestampFirstGet())


        """
        return _byteblower.TriggerBasicResultSnapshot_TimestampFirstGet(self)


    def TimestampLastGet(self):
        """

        Gets the timestamp [NS] of the last packet in this snapshot.  

        Example

        This example gets the timestamp [NS] of the last received packet in this 
        snapshot  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.TimestampLastGet())


        """
        return _byteblower.TriggerBasicResultSnapshot_TimestampLastGet(self)


    def PacketCountGet(self):
        """

        Gets the received packet count.  

        :return:  received packets  

        Example

        This example gets the received packet counter  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.PacketCountGet())



        """
        return _byteblower.TriggerBasicResultSnapshot_PacketCountGet(self)


    def ByteCountGet(self):
        """

        Gets the current received bytes counter.  

        :return:  received bytes  

        Example

        This example gets the received bytes counter  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.ByteCountGet())


        """
        return _byteblower.TriggerBasicResultSnapshot_ByteCountGet(self)


    def FramesizeMaximumGet(self):
        """

        Gets the size (in bytes) of the largest frame received in this snapshot.  

        :return: Largest received frame size in bytes of this snapshot  

        .. versionadded:: 2.5.0  

        Example

        This example gets the largest frame size received in this snapshot.  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.FramesizeMaximumGet())


        """
        return _byteblower.TriggerBasicResultSnapshot_FramesizeMaximumGet(self)


    def FramesizeMinimumGet(self):
        """

        Gets the size (in bytes) of the smallest frame received in this snapshot.  

        :return: Smallest received frame size in bytes of this snapshot  

        .. versionadded:: 2.5.0  

        Example

        This example gets the smallest frame size received in this snapshot.  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.FramesizeMinimumGet())


        """
        return _byteblower.TriggerBasicResultSnapshot_FramesizeMinimumGet(self)


    def IntervalDurationGet(self):
        """

        Gets the *configured* duration of this results snapshot [NS].  

        .. versionadded:: 2.3.0  

        Example

        This example gets interval duration of this result snapshot [NS]  

        .. code-block:: python
           :emphasize-lines: 1

           print(result.IntervalDurationGet())



        """
        return _byteblower.TriggerBasicResultSnapshot_IntervalDurationGet(self)


    def RefreshTimestampGet(self):
        return _byteblower.TriggerBasicResultSnapshot_RefreshTimestampGet(self)
TriggerBasicResultSnapshot_swigregister = _byteblower.TriggerBasicResultSnapshot_swigregister
TriggerBasicResultSnapshot_swigregister(TriggerBasicResultSnapshot)

class TriggerBasicResultData(AbstractObject):
    """

    Receive-side trigger result set.  

    The result set contains the trigger information of since the object is created
     or refreshed.

    .. note:: See What's new in API v2 for more information.  

    A basic trigger result data snapshot object can be created via a 
    :class:`.TriggerBasicResultHistory`, using 
    :meth:`.TriggerBasic.ResultHistoryGet`

    .. note:: The information is not updated until 
              :meth:`.TriggerBasicResultHistory.Refresh` is called  

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or 
    destination port 67.  

    .. code-block:: python
       :emphasize-lines: 3

    	port = bbServer.PortCreate('trunk-1-2')
    	trigger = port.RxTriggerBasicAdd()
    	bpf_filter = 'udp port 67'
    	  trigger.FilterSet(bpf_filter)
    	historyResult = trigger.ResultHistoryGet()
    	resultData = historyResult.CumulativeLatestGet()



    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TriggerBasicResultData, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TriggerBasicResultData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].  

        Example

        This example gets the snapshot timestamp [NS].  

        .. code-block:: python
           :emphasize-lines: 1

        	print(dataResult.TimestampGet())


        """
        return _byteblower.TriggerBasicResultData_TimestampGet(self)


    def TimestampFirstGet(self):
        """

        Gets the timestamp [NS] of the first packet in this snapshot.  

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable  

        Example

        This example gets the timestamp [NS] of the first received packet in this 
        snapshot 


        .. code-block:: python
           :emphasize-lines: 1

        	print(dataResult_Get.TimestampFirstGet())


        """
        return _byteblower.TriggerBasicResultData_TimestampFirstGet(self)


    def TimestampLastGet(self):
        """

        Gets the current timestamp [NS] of the last packet in this snapshot.  

        Example

        This example gets the timestamp [NS] of the last received packet in this 
        snapshot  

        .. code-block:: python
           :emphasize-lines: 1

           	print(dataResult_Get.TimestampLastGet())


        """
        return _byteblower.TriggerBasicResultData_TimestampLastGet(self)


    def PacketCountGet(self):
        """

        Gets the received packet count.  

        Example

        This example gets the received packet counter  

        .. code-block:: python
           :emphasize-lines: 1

           	print(dataResult_Get.PacketCountGet())


        """
        return _byteblower.TriggerBasicResultData_PacketCountGet(self)


    def ByteCountGet(self):
        """

        Gets the current received bytes counter.  

        Example

        This example gets the received bytes counter  

        .. code-block:: python
           :emphasize-lines: 1

        	print(dataResult.ByteCountGet())


        """
        return _byteblower.TriggerBasicResultData_ByteCountGet(self)


    def FramesizeMaximumGet(self):
        """

        Gets the size (in bytes) of the largest frame received in this snapshot.  

        :return: Largest received frame size in bytes of this snapshot  

        .. versionadded:: 2.5.0  

        Example

        This example gets the largest frame size received in this snapshot.  

        .. code-block:: python
           :emphasize-lines: 1

        	print(dataResult.FramesizeMaximumGet())



        """
        return _byteblower.TriggerBasicResultData_FramesizeMaximumGet(self)


    def FramesizeMinimumGet(self):
        """

        Gets the size (in bytes) of the smallest frame received in this snapshot.  

        :return: Smallest received frame size in bytes of this snapshot  

        .. versionadded:: 2.5.0  

        Example

        This example gets the smallest frame size received in this snapshot.  

        .. code-block:: python
           :emphasize-lines: 1

        	print(dataResult.FramesizeMinimumGet())


        """
        return _byteblower.TriggerBasicResultData_FramesizeMinimumGet(self)


    def IntervalDurationGet(self):
        """

        Gets the *configured* duration of this results snapshot [NS].  

        .. versionadded:: 2.3.0  

        Example

        This example gets interval duration of this result snapshot [NS] 

        .. code-block:: python
           :emphasize-lines: 1

           	print(dataResult_Get.IntervalDurationGet())


        """
        return _byteblower.TriggerBasicResultData_IntervalDurationGet(self)


    def TypeGet(self):
        return _byteblower.TriggerBasicResultData_TypeGet(self)
TriggerBasicResultData_swigregister = _byteblower.TriggerBasicResultData_swigregister
TriggerBasicResultData_swigregister(TriggerBasicResultData)

class TriggerBasicResultDataList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TriggerBasicResultDataList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TriggerBasicResultDataList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TriggerBasicResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TriggerBasicResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TriggerBasicResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.TriggerBasicResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TriggerBasicResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TriggerBasicResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TriggerBasicResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TriggerBasicResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TriggerBasicResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TriggerBasicResultDataList___setitem__(self, *args)

    def pop(self):
        return _byteblower.TriggerBasicResultDataList_pop(self)

    def append(self, x):
        return _byteblower.TriggerBasicResultDataList_append(self, x)

    def empty(self):
        return _byteblower.TriggerBasicResultDataList_empty(self)

    def size(self):
        return _byteblower.TriggerBasicResultDataList_size(self)

    def swap(self, v):
        return _byteblower.TriggerBasicResultDataList_swap(self, v)

    def begin(self):
        return _byteblower.TriggerBasicResultDataList_begin(self)

    def end(self):
        return _byteblower.TriggerBasicResultDataList_end(self)

    def rbegin(self):
        return _byteblower.TriggerBasicResultDataList_rbegin(self)

    def rend(self):
        return _byteblower.TriggerBasicResultDataList_rend(self)

    def clear(self):
        return _byteblower.TriggerBasicResultDataList_clear(self)

    def get_allocator(self):
        return _byteblower.TriggerBasicResultDataList_get_allocator(self)

    def pop_back(self):
        return _byteblower.TriggerBasicResultDataList_pop_back(self)

    def erase(self, *args):
        return _byteblower.TriggerBasicResultDataList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_TriggerBasicResultDataList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.TriggerBasicResultDataList_push_back(self, x)

    def front(self):
        return _byteblower.TriggerBasicResultDataList_front(self)

    def back(self):
        return _byteblower.TriggerBasicResultDataList_back(self)

    def assign(self, n, x):
        return _byteblower.TriggerBasicResultDataList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.TriggerBasicResultDataList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.TriggerBasicResultDataList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.TriggerBasicResultDataList_reserve(self, n)

    def capacity(self):
        return _byteblower.TriggerBasicResultDataList_capacity(self)
    __swig_destroy__ = _byteblower.delete_TriggerBasicResultDataList
    __del__ = lambda self: None
TriggerBasicResultDataList_swigregister = _byteblower.TriggerBasicResultDataList_swigregister
TriggerBasicResultDataList_swigregister(TriggerBasicResultDataList)

class TriggerBasicResultHistory(AbstractRefreshableResult):
    """

    Receive-side trigger result history.  

    The history contains the trigger information in time since the object is 
    created or refreshed.  

    .. note:: The information is not updated until :meth:`Refresh` is called  

    .. note:: See History result for more information  

    A basic trigger history result object can be created via a 
    :class:`.TriggerBasic`, using :meth:`.TriggerBasic.ResultHistoryGet` 

    .. versionadded:: 2.1.0  

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or 
    destination port 67.  

    .. code-block:: python
       :emphasize-lines: 3

       from byteblowerll.byteblower import ByteBlower
       server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
       # TODO


    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TriggerBasicResultHistory, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TriggerBasicResultHistory, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        """

        Clear the history.  

        With each :meth:`Refresh` interval and cumulative counters are transferred from
        Server to the Client. To remove all counter-objects in this history, you can
        execute this method. Both Interval and Cumulative counter lists will be
        cleared.

        Example

        Clear the History.  

        .. code-block:: python
           :emphasize-lines: 1

        	historyResult.Clear()


        """
        return _byteblower.TriggerBasicResultHistory_Clear(self)


    def CumulativeGet(self):
        """

        Returns a list of available cumulative counters.  

        Each result object contains cumulative counters at a certain point in time. 
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`

        :return: :class:`.TriggerBasicResultDataList` containing the Cumulative counters

        Example

        This example gets the available cumulative results  

        .. code-block:: python
           :emphasize-lines: 1

           print(historyResult.CumulativeGet()[0].DescriptionGet())


        """
        return _byteblower.TriggerBasicResultHistory_CumulativeGet(self)


    def CumulativeGetByIndex(self, index):
        """

        Returns a single item of the cumulative list.  

        :param index: index

        :return: :class:`.TriggerBasicResultData` cumulative counter object at the 
                 specified index 

        Example

        This example gets the available cumulative counters at index 1  

        .. code-block:: python
           :emphasize-lines: 1

           print(historyResult.CumulativeGetByIndex(0).DescriptionGet())


        """
        return _byteblower.TriggerBasicResultHistory_CumulativeGetByIndex(self, index)


    def CumulativeLengthGet(self):
        """

        Returns the size of the cumulative list.  

        :return: The length of the cumulative list  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(historyResult.CumulativeLengthGet())


        """
        return _byteblower.TriggerBasicResultHistory_CumulativeLengthGet(self)


    def SamplingBufferLengthGet(self):
        """

        Number of samples to keep in the buffer.  

        The ByteBlower server has a buffer to keep some samples before they are 
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a 
        sample is closed, the oldest sample in the buffer will be removed.  

        :return: The length of the server sample buffer  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(historyResult.SamplingBufferLengthGet())


        """
        return _byteblower.TriggerBasicResultHistory_SamplingBufferLengthGet(self)


    def SamplingIntervalDurationGet(self):
        """

        Duration of one sampling interval in nanoseconds.  

        :return: Duration in nanoseconds  

        Example

        .. code-block:: python
           :emphasize-lines: 1


        	print(historyResult.SamplingIntervalDurationGet())


        """
        return _byteblower.TriggerBasicResultHistory_SamplingIntervalDurationGet(self)


    def SamplingIntervalDurationSet(self, inDuration):
        """

        Sets the duration of one sampling interval.  

        .. versionadded:: 2.3.0  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(historyResult.SamplingIntervalDurationSet())


        """
        return _byteblower.TriggerBasicResultHistory_SamplingIntervalDurationSet(self, inDuration)


    def SamplingBufferLengthSet(self, inLength):
        """

        Sets the number of samples to keep in the buffer.   

        The ByteBlower server has a buffer to keep some samples before they are 
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a 
        sample is closed, the oldest sample in the buffer will be removed.  

        .. versionadded:: 2.3.0  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	historyResult.SamplingBufferLengthSet(10)


        """
        return _byteblower.TriggerBasicResultHistory_SamplingBufferLengthSet(self, inLength)


    def IntervalGet(self):
        """

        Returns a list of available interval results.  

        Each result object contains interval counters at a certain point in time. 
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`    

        :return: :class:`.TriggerBasicResultDataList` containing the Interval counters 

        Example

        This example gets the available interval results  

        .. code-block:: python
           :emphasize-lines: 1

        	print(historyResult.IntervalGet()[0].DescriptionGet())


        """
        return _byteblower.TriggerBasicResultHistory_IntervalGet(self)


    def IntervalGetByIndex(self, index):
        """

        Returns a single item of the interval list.  

        :param index: index

        :return: :class:`.TriggerBasicResultData` interval counter object at the 
                 specified index

        Example

        This example gets the available interval counters at index 1  

        .. code-block:: python
           :emphasize-lines: 1

        	print(historyResult.IntervalGetByIndex(0).DescriptionGet())


        """
        return _byteblower.TriggerBasicResultHistory_IntervalGetByIndex(self, index)


    def IntervalLengthGet(self):
        """

        Returns the size of the interval list.  

        :return: The length of the interval list  

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(historyResult.IntervalLengthGet())


        """
        return _byteblower.TriggerBasicResultHistory_IntervalLengthGet(self)


    def RefreshTimestampGet(self):
        return _byteblower.TriggerBasicResultHistory_RefreshTimestampGet(self)

    def CumulativeGetByTime(self, timestamp):
        """

        Returns a single item of the cumulative list using a timestamp.  

        :param timestamp: timestamp in nanoseconds  

        :return: :class:`.TriggerBasicResultData`  

        .. versionadded:: 2.2.0  

        Example

        This example gets the cumulative counter at timestamp 1432805398000000000 ns  

        .. code-block:: python
           :emphasize-lines: 1

        	print(historyResult.CumulativeGetByTime(1432805398000000000).DescriptionGet())



        """
        return _byteblower.TriggerBasicResultHistory_CumulativeGetByTime(self, timestamp)


    def IntervalGetByTime(self, timestamp):
        """

        Returns a single item of the interval list using a timestamp.  

        :param timestamp: timestamp in nanoseconds  

        :return: :class:`.TriggerBasicResultData`  

        .. versionadded:: 2.2.0  

        Example

        This example gets the Interval counters at timestamp 1432805398000000000 ns  

        .. code-block:: python
           :emphasize-lines: 1

        	interval = historyResult.IntervalGetByTime(1432805398000000000)


        """
        return _byteblower.TriggerBasicResultHistory_IntervalGetByTime(self, timestamp)


    def CumulativeLatestGet(self):
        """

        Returns latest closed item of the cumulative list.  

        :return:  :class:`.TriggerBasicResultData`  

        .. versionadded:: 2.2.0  

        Example

        This example gets the latest closed Cumulative counter object  

        .. code-block:: python
           :emphasize-lines: 1

           print(historyResult.CumulativeLatestGet().DescriptionGet())


        """
        return _byteblower.TriggerBasicResultHistory_CumulativeLatestGet(self)


    def IntervalLatestGet(self):
        """

        Returns the latest closed item of the interval list.  

        :return: :class:`.TriggerBasicResultData`  

        .. versionadded:: 2.2.0  

        Example

        This example gets the latest closed Interval counter object  

        .. code-block:: python
           :emphasize-lines: 1

        	print(historyResult.IntervalLatestGet().DescriptionGet())


        """
        return _byteblower.TriggerBasicResultHistory_IntervalLatestGet(self)

TriggerBasicResultHistory_swigregister = _byteblower.TriggerBasicResultHistory_swigregister
TriggerBasicResultHistory_swigregister(TriggerBasicResultHistory)

class TriggerBasic(Trigger):
    """

    Receive-side packet processor which counts the incoming frames, matching a filter.

    This trigger is always active and starts counting frames as soon as it is
    created. Counting continues until the trigger is destructed.

    .. note:: The initial (empty) filter string accepts all incoming frames. See
              `meth``FilterSet` for filtering information.

    A basic trigger object can be created via a :class:`.ByteBlowerPort`, using
    :meth:`.ByteBlowerPort.RxTriggerBasicAdd`

    This trigger processes frames received on the ByteBlower interface where its
    parent ByteBlowerPort is located.

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.

    .. code-block:: python

    	port = bbServer.PortCreate('trunk-1-2')
    	trigger = port.RxTriggerBasicAdd()
    	bpf_filter = 'udp port 67'
    	trigger.FilterSet(bpf_filter)



    """

    __swig_setmethods__ = {}
    for _s in [Trigger]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TriggerBasic, name, value)
    __swig_getmethods__ = {}
    for _s in [Trigger]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TriggerBasic, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultGet(self):
        """

        Returns the current result counters.

        This method will return an object of :class:`.TriggerBasicResultSnapshot`.
        It will contain all the current Cumulative counters. To update the counters,
        call Refresh on :class:`.TriggerBasicResultSnapsho(`

        :return: The OID of the :class:`.TriggerBasicResultSnapshot` object.

        .. versionadded:: 2.1.0

        Example

        .. code-block:: python
           :emphasize-lines: 2

        	trigger = port.RxTriggerBasicAdd()
        	print(trigger.ResultGet().DescriptionGet())



        """
        return _byteblower.TriggerBasic_ResultGet(self)


    def ResultHistoryGet(self):
        """

        Returns the current History counters.

        This method returns a :class:`.TriggerBasicResultHistory` Object. This will
        contain the Cumulative and the Interval counters over time. Use this to create
        results over time.

        .. versionadded:: 2.1.0

        :return: :class:`.TriggerBasicResultHistory` object.

        Example

        .. code-block:: python
           :emphasize-lines: 2

        	trigger = port.RxTriggerBasicAdd()
        	print(trigger.ResultHistoryGet().DescriptionGet())


        """
        return _byteblower.TriggerBasic_ResultHistoryGet(self)


    def FilterSet(self, filter):
        """

        Sets a BPF filter on a RX object.

        ..note:: Configuring a new filter string does reset the counter values which
                 were triggered by a previous filter string. Also the earlier collected
                 history is invalidated.

        :param bpfString: Valid BPF filter string. For creating valid BPF filter
                          strings, please have a look at
                          http://www.tcpdump.org/#documentation
                          for more information.

        :raises: ByteBlower.Rx.* - When the {server-side} RX object could not be
                 resolved.
        :raises: ByteBlower.Rx.Filter.CompilationFailed - When an invalid BPF filter
                 string is given.
        :raises: ByteBlower.InvalidFilter - When an invalid BPF filter string is given.

        Example

        This will filter only UDP traffic.  Set the filter on packets that match:
        - source and destination IPv4 address
        - UDP traffic with given destination and source UDP port
        - (layer2) frame length (without CRC!)

        .. code-block:: python
           :emphasize-lines: 3

        	trigger = port.RxTriggerBasicAdd()
        	bpf_filter = 'ip dst 1.1.1.2 and udp port 4096'
        	trigger.FilterSet(bpf_filter)


        """
        return _byteblower.TriggerBasic_FilterSet(self, filter)


    def FilterGet(self):
        """

        Returns the current installed BPF filter string.

        The filter string can be configured using :meth:`FilterSet`

        :return: The current BPF filter string

        Example

        Suppose we configured the trigger with filter string:
        where `$ipv4_1` and `$ipv4_2` are :class:`IPv4Configuration` and
        `$frameSize` is the (layer2) size of the frames (without CRC!). The
        BPF filter string would then become for example:

        .. code-block:: python
           :emphasize-lines: 4

        	trigger = port.RxTriggerBasicAdd()
        	bpf_filter = 'ip dst 1.1.1.2 and udp port 4096'
        	trigger.FilterSet(bpf_filter)	
        	print(trigger.FilterGet())


        """
        return _byteblower.TriggerBasic_FilterGet(self)


    def ResultClear(self):
        """

        Resets the counter values to zero.

        .. versionadded:: 2.1.0

        Example

        .. code-block:: python
           :emphasize-lines: 2

        	trigger = port.RxTriggerBasicAdd()
        	trigger.ResultClear()


        """
        return _byteblower.TriggerBasic_ResultClear(self)

TriggerBasic_swigregister = _byteblower.TriggerBasic_swigregister
TriggerBasic_swigregister(TriggerBasic)

class TriggerBasicMobile(Trigger):
    """

    Receive-side packet processor on a WirelessEndpoint that counts all incoming
    frames that match a filter.

    All triggers are started after calling :meth:`.WirelessEndpoint.Start` on the
    parent WirelessEndpoint object.

    A basic trigger object can be created by calling
    :meth:`.WirelessEndpoint:RxTriggerBasicAdd`

    .. versionadded:: 2.6.0

    Example

    .. code-block:: python
       :emphasize-lines: 3

       from byteblowerll.byteblower import ByteBlower
       server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
       # TODO


    """

    __swig_setmethods__ = {}
    for _s in [Trigger]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TriggerBasicMobile, name, value)
    __swig_getmethods__ = {}
    for _s in [Trigger]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TriggerBasicMobile, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultGet(self):
        """

        Returns the current result counters.

        This method will return an object of TriggerBasicResultSnapshot. It will
        contain all the current Cumulative counters. To update the counters, call
        :meth:`Refresh` on :class:`.TriggerBasicResultSnapshot`

        :return: :class:`.TriggerBasicResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(ResultHistoryGet.ResultGet())



        """
        return _byteblower.TriggerBasicMobile_ResultGet(self)


    def ResultHistoryGet(self):
        """

        Returns the current History counters.

        This method returns a TriggerBasicResultHistory Object. This will contain the
        Cumulative and the Interval counters over time. Use this to create results over
        time.

        :return: :class:`.TriggerBasicResultHistory` object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(triggerMobile.ResultHistoryGet())


        """
        return _byteblower.TriggerBasicMobile_ResultHistoryGet(self)


    def FilterSourceAddressGet(self):
        """

        Returns the source (source) address field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(ResultHistoryGet.FilterSourceAddressGet())



        """
        return _byteblower.TriggerBasicMobile_FilterSourceAddressGet(self)


    def FilterSourceAddressSet(self, inAddress):
        """

        Sets the source (source) address field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	ResultHistoryGet.FilterSourceAddressSet('1.1.1.1')


        """
        return _byteblower.TriggerBasicMobile_FilterSourceAddressSet(self, inAddress)


    def FilterUdpSourcePortGet(self):
        """

        Returns the source (source) port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(ResultHistoryGet.FilterUdpSourcePortGet())



        """
        return _byteblower.TriggerBasicMobile_FilterUdpSourcePortGet(self)


    def FilterUdpSourcePortSet(self, inPort):
        """

        Sets the source (source) port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1
        1
           triggerMobile.FilterUdpSourcePortSet(4096)



        """
        return _byteblower.TriggerBasicMobile_FilterUdpSourcePortSet(self, inPort)


    def FilterUdpDestinationPortGet(self):
        """

        Returns the destination (destination) port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(ResultHistoryGet.FilterUdpDestinationPortGet())



        """
        return _byteblower.TriggerBasicMobile_FilterUdpDestinationPortGet(self)


    def FilterUdpDestinationPortSet(self, inPort):
        """

        Sets the destination (destination) port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           triggerMobile.FilterUdpDestinationPortSet(4096)


        """
        return _byteblower.TriggerBasicMobile_FilterUdpDestinationPortSet(self, inPort)


    def DurationGet(self):
        """

        Returns the duration for which the trigger will be active.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(ResultHistoryGet.DurationGet())


        """
        return _byteblower.TriggerBasicMobile_DurationGet(self)


    def DurationSet(self, inDuration):
        """

        Sets the duration for which the trigger will be active.

        Configures how long the trigger will listen for incoming packets.

        Example

        Listen for 10 minutes

        .. code-block:: python
           :emphasize-lines: 1

        	triggerMobile.DurationSet(10000)



        """
        return _byteblower.TriggerBasicMobile_DurationSet(self, inDuration)


    def FilterGet(self):
        return _byteblower.TriggerBasicMobile_FilterGet(self)

    def FilterSet(self, arg2):
        return _byteblower.TriggerBasicMobile_FilterSet(self, arg2)

    def ResultClear(self):
        """

        Resets the counter values to zero and empties the ResultHistory.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	ResultHistoryGet.ResultClear()


        """
        return _byteblower.TriggerBasicMobile_ResultClear(self)

TriggerBasicMobile_swigregister = _byteblower.TriggerBasicMobile_swigregister
TriggerBasicMobile_swigregister(TriggerBasicMobile)

class TriggerSizeDistributionResultSnapshot(AbstractRefreshableResult):
    """

    Contains the results for the size distribution.


    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TriggerSizeDistributionResultSnapshot, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TriggerSizeDistributionResultSnapshot, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(snaphot.TimestampGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_TimestampGet(self)


    def TimestampFirstGet(self):
        """

        Gets the timestamp [NS] of the first received packet.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the first transmitted packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(snaphot.TimestampFirstGet())

        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_TimestampFirstGet(self)


    def TimestampLastGet(self):
        """

        Gets the current timestamp [NS] of the last received packet.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(snaphot.TimestampLastGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_TimestampLastGet(self)


    def ByteCountGet(self):
        """

        Gets the number of received bytes.

        .. code-block:: python
           :emphasize-lines: 1

        	print(snaphot.ByteCountGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_ByteCountGet(self)


    def FramesizeMaximumGet(self):
        """

        Gets the size (in bytes) of the largest frame received in this snapshot.

        :return: Largest received frame size in bytes of this snapshot

        .. versionadded:: 2.5.0

        Example

        This example gets the largest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

        	print(snaphot.FramesizeMaximumGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_FramesizeMaximumGet(self)


    def FramesizeMinimumGet(self):
        """

        Gets the size (in bytes) of the smallest frame received in this snapshot.

        :return: Smallest received frame size in bytes of this snapshot

        .. versionadded:: 2.5.0

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

        	print(snaphot.FramesizeMinimumGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_FramesizeMinimumGet(self)


    def PacketCountGet(self, *args):
        """

        Gets the number received packets. Or if provided with a size, the number of
        packets received of that size.

        .. code-block:: python
           :emphasize-lines: 1

        	print(snaphot.PacketCountGet())



        Gets the number received packets. Or if provided with a size, the number of
        packets received of that size.

        .. code-block:: python
           :emphasize-lines: 1

        	print(snaphot.PacketCountGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_PacketCountGet(self, *args)


    def PacketCountBelowMinimumGet(self):
        return _byteblower.TriggerSizeDistributionResultSnapshot_PacketCountBelowMinimumGet(self)

    def PacketCountAboveMaximumGet(self):
        """

        Gets number of received packets in this snapshot that are too big.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(snaphot.PacketCountAboveMaximumGet())


        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_PacketCountAboveMaximumGet(self)


    def RefreshTimestampGet(self):
        """



        """
        return _byteblower.TriggerSizeDistributionResultSnapshot_RefreshTimestampGet(self)

TriggerSizeDistributionResultSnapshot_swigregister = _byteblower.TriggerSizeDistributionResultSnapshot_swigregister
TriggerSizeDistributionResultSnapshot_swigregister(TriggerSizeDistributionResultSnapshot)

class TriggerSizeDistribution(Trigger):
    """

    Receive-side packet processor which counts the incoming frames, frame rate and
    frames per size, matching a filter.

    The size distribution trigger extends the basic trigger. It provides additional
    information like total number of bytes and frame rate. See :meth:`ResultGet`
    for more information.

    This trigger is always active and starts counting frames as soon as it is
    created. Counting continues until the trigger is destructed.

    .. note:: The initial (empty) filter string accepts all incoming frames. See
              :meth:`FilterSet` for filtering information.

    A size distribution trigger object can be created via a ByteBlowerPort, using
    :meth:`.ByteBlowerPort.RxTriggerSizeDistributionAdd`

    This trigger processes frames received on the ByteBlower interface where its
    parent ByteBlowerPort is located.

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 49576.

    .. code-block:: python

    	trig = port.RxTriggerSizeDistributionAdd()
    	trig.FilterSet('ip && dst port 49576')
    	...
    	print(trig.ResultGet().DescriptionGet())


    """

    __swig_setmethods__ = {}
    for _s in [Trigger]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, TriggerSizeDistribution, name, value)
    __swig_getmethods__ = {}
    for _s in [Trigger]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, TriggerSizeDistribution, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultGet(self):
        """

        Returns the :class:`.TriggerSizeDistributionResultSnapshot` for this trigger
        containing the current result counters.

        The snapshot contains byte counters and time values.

        :return: :class:`.TriggerSizeDistributionResultSnapshot`

        .. versionadded:: 2.1.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(trig.ResultGet().DescriptionGet())


        """
        return _byteblower.TriggerSizeDistribution_ResultGet(self)


    def ResultClear(self):
        """

        Resets the counter values to zero.

        .. versionadded:: 2.1.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

           trig.ResultClear()


        """
        return _byteblower.TriggerSizeDistribution_ResultClear(self)


    def FilterSet(self, inFilter):
        """

        Sets a BPF filter on a RX object.

        .. note:: Configuring a new filter string does not reset the counter values
                  which were triggered by a previous filter string.

        :param bpfstring: Valid BPF filter string. For creating valid BPF filter
                          strings, please have a look at
                          http://www.tcpdump.org/#documentation for more information.

        :raises: ByteBlower.Rx.* - When the {server-side} RX object could not be resolved.

        :raises: ByteBlower.Rx.Filter.CompilationFailed - When an invalid BPF filter
                 string is given.

        :raises: ByteBlower.InvalidFilter - When an invalid BPF filter string is given.

        Example

        .. code-block:: python
        	:emphasize-lines: 3

        	trig = port.RxTriggerSizeDistributionAdd()
        	# lets assume traffic is sent to UDP port 9000
        	trig.FilterSet('ip && dst port 9000')

        This will filter only UDP traffic.  Set the filter on packets that match:
        - source and destination IPv4 address
        - UDP traffic with given destination and source UDP port
        - (layer2) frame length (without CRC!)


        """
        return _byteblower.TriggerSizeDistribution_FilterSet(self, inFilter)


    def FilterGet(self):
        """

        Returns the current installed BPF filter string.

        The filter string can be configured using :meth:`FilterSet`

        :return: The current BPF filter string

        Example

        Suppose we configured the trigger with filter string:  where `$ipv4_1` and
        `$ipv4_2` are :class:`IPv4Configuration` objects and `$frameSize` is the
        (layer2) size of the frames (without CRC!). The BPF filter string would then
        become for example:

        .. code-block:: python
           :emphasize-lines: 2

           trig.FilterSet('ip && dst port 9000')
           print(trig.FilterGet())


        """
        return _byteblower.TriggerSizeDistribution_FilterGet(self)

TriggerSizeDistribution_swigregister = _byteblower.TriggerSizeDistribution_swigregister
TriggerSizeDistribution_swigregister(TriggerSizeDistribution)

class OutOfSequenceResultSnapshot(AbstractRefreshableResult):
    """

    Refreshable object containing the out-of-sequence results.

    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutOfSequenceResultSnapshot, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OutOfSequenceResultSnapshot, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 3

        	print(outOfSequenceResult.TimestampGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_TimestampGet(self)


    def TimestampFirstGet(self):
        """

        Gets the timestamp [NS] of the first packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceResult.TimestampFirstGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_TimestampFirstGet(self)


    def TimestampLastGet(self):
        """

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the last received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceResult.TimestampLastGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_TimestampLastGet(self)


    def PacketCountGet(self):
        """

        Gets the received packet count.

        Example

        This example gets the received packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceResult.PacketCountGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_PacketCountGet(self)


    def ByteCountGet(self):
        """

        Gets the current received bytes counter.

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceResult.ByteCountGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_ByteCountGet(self)


    def FramesizeMaximumGet(self):
        """

        Gets the size (in bytes) of the largest frame received in this snapshot.

        .. versionadded:: 2.6.4

        Example

        This example gets the largest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

         	print(outOfSequenceResult.FramesizeMaximumGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_FramesizeMaximumGet(self)


    def FramesizeMinimumGet(self):
        """

        Gets the size (in bytes) of the smallest frame received in this snapshot.

        .. versionadded:: 2.6.4

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceResult.FramesizeMinimumGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_FramesizeMinimumGet(self)


    def PacketCountOutOfSequenceGet(self):
        """

        Gets the received packet count which were out of sequence.

        Example

        This example gets the received out of sequence packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceResult.PacketCountOutOfSequenceGet())


        """
        return _byteblower.OutOfSequenceResultSnapshot_PacketCountOutOfSequenceGet(self)


    def PacketCountValidGet(self):
        """

        Gets the received packet count for packets which were not corrupted.

        Example

        This example gets the valid packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceResult.PacketCountValidGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_PacketCountValidGet(self)


    def PacketCountInvalidGet(self):
        """

        Gets the received packet count for the invalid/corrupted packets.

        Example

        This example gets the received invalid packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceResult.PacketCountInvalidGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_PacketCountInvalidGet(self)


    def PacketCountMissingGet(self):
        return _byteblower.OutOfSequenceResultSnapshot_PacketCountMissingGet(self)

    def BiggestSequenceNumberGapGet(self):
        return _byteblower.OutOfSequenceResultSnapshot_BiggestSequenceNumberGapGet(self)

    def IntervalDurationGet(self):
        """

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

         	print(outOfSequenceResult.IntervalDurationGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_IntervalDurationGet(self)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp when the counters of this object where last refreshed.

        .. note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(outOfSequenceResult.RefreshTimestampGet())



        """
        return _byteblower.OutOfSequenceResultSnapshot_RefreshTimestampGet(self)

OutOfSequenceResultSnapshot_swigregister = _byteblower.OutOfSequenceResultSnapshot_swigregister
OutOfSequenceResultSnapshot_swigregister(OutOfSequenceResultSnapshot)

class OutOfSequenceResultData(AbstractObject):
    """

    Non-refreshable object containing the out-of-sequence results.


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutOfSequenceResultData, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OutOfSequenceResultData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceresultData.TimestampGet())



        """
        return _byteblower.OutOfSequenceResultData_TimestampGet(self)


    def TimestampFirstGet(self):
        """

        Gets the timestamp [NS] of the first packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceresultData.TimestampFirstGet())



        """
        return _byteblower.OutOfSequenceResultData_TimestampFirstGet(self)


    def TimestampLastGet(self):
        """

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the last received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceresultData.PacketCountGet())


        """
        return _byteblower.OutOfSequenceResultData_TimestampLastGet(self)


    def PacketCountGet(self):
        """

        Gets the received packet count.

        Example

        This example gets the received packet counter

        .. code-block:: python
           :emphasize-lines: 1

           	print(outOfSequenceresultData.PacketCountGet())



        """
        return _byteblower.OutOfSequenceResultData_PacketCountGet(self)


    def ByteCountGet(self):
        """

        Gets the current received bytes counter.

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceresultData.ByteCountGet())



        """
        return _byteblower.OutOfSequenceResultData_ByteCountGet(self)


    def FramesizeMaximumGet(self):
        """

        Gets the size (in bytes) of the largest frame received in this snapshot.

        .. versionadded:: 2.6.4

        Example

        This example gets the largest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceresultData.FramesizeMaximumGet())



        """
        return _byteblower.OutOfSequenceResultData_FramesizeMaximumGet(self)


    def FramesizeMinimumGet(self):
        """

        Gets the size (in bytes) of the smallest frame received in this snapshot.

        :return:

        .. versionadded:: 2.6.4

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceresultData.FramesizeMinimumGet())



        """
        return _byteblower.OutOfSequenceResultData_FramesizeMinimumGet(self)


    def PacketCountOutOfSequenceGet(self):
        """

        Gets the received packet count which were out of sequence.

        Example

        This example gets the received out of sequence packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceresultData.PacketCountOutOfSequenceGet())



        """
        return _byteblower.OutOfSequenceResultData_PacketCountOutOfSequenceGet(self)


    def PacketCountValidGet(self):
        """

        Gets the received packet count which for packets which were not corrupted.

        Example

        This example gets the valid packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceresultData.PacketCountValidGet())



        """
        return _byteblower.OutOfSequenceResultData_PacketCountValidGet(self)


    def PacketCountInvalidGet(self):
        """

        Gets the received packet count for the invalid/corrupted packets.

        Example

        This example gets the received invalid packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceresultData.PacketCountInvalidGet())



        """
        return _byteblower.OutOfSequenceResultData_PacketCountInvalidGet(self)


    def PacketCountMissingGet(self):
        return _byteblower.OutOfSequenceResultData_PacketCountMissingGet(self)

    def BiggestSequenceNumberGapGet(self):
        return _byteblower.OutOfSequenceResultData_BiggestSequenceNumberGapGet(self)

    def IntervalDurationGet(self):
        """

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 3

        	print(outOfSequenceresultData.IntervalDurationGet())



        """
        return _byteblower.OutOfSequenceResultData_IntervalDurationGet(self)

OutOfSequenceResultData_swigregister = _byteblower.OutOfSequenceResultData_swigregister
OutOfSequenceResultData_swigregister(OutOfSequenceResultData)

class OutOfSequenceResultDataList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutOfSequenceResultDataList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OutOfSequenceResultDataList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.OutOfSequenceResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.OutOfSequenceResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.OutOfSequenceResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.OutOfSequenceResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.OutOfSequenceResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.OutOfSequenceResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.OutOfSequenceResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.OutOfSequenceResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.OutOfSequenceResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.OutOfSequenceResultDataList___setitem__(self, *args)

    def pop(self):
        return _byteblower.OutOfSequenceResultDataList_pop(self)

    def append(self, x):
        return _byteblower.OutOfSequenceResultDataList_append(self, x)

    def empty(self):
        return _byteblower.OutOfSequenceResultDataList_empty(self)

    def size(self):
        return _byteblower.OutOfSequenceResultDataList_size(self)

    def swap(self, v):
        return _byteblower.OutOfSequenceResultDataList_swap(self, v)

    def begin(self):
        return _byteblower.OutOfSequenceResultDataList_begin(self)

    def end(self):
        return _byteblower.OutOfSequenceResultDataList_end(self)

    def rbegin(self):
        return _byteblower.OutOfSequenceResultDataList_rbegin(self)

    def rend(self):
        return _byteblower.OutOfSequenceResultDataList_rend(self)

    def clear(self):
        return _byteblower.OutOfSequenceResultDataList_clear(self)

    def get_allocator(self):
        return _byteblower.OutOfSequenceResultDataList_get_allocator(self)

    def pop_back(self):
        return _byteblower.OutOfSequenceResultDataList_pop_back(self)

    def erase(self, *args):
        return _byteblower.OutOfSequenceResultDataList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_OutOfSequenceResultDataList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.OutOfSequenceResultDataList_push_back(self, x)

    def front(self):
        return _byteblower.OutOfSequenceResultDataList_front(self)

    def back(self):
        return _byteblower.OutOfSequenceResultDataList_back(self)

    def assign(self, n, x):
        return _byteblower.OutOfSequenceResultDataList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.OutOfSequenceResultDataList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.OutOfSequenceResultDataList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.OutOfSequenceResultDataList_reserve(self, n)

    def capacity(self):
        return _byteblower.OutOfSequenceResultDataList_capacity(self)
    __swig_destroy__ = _byteblower.delete_OutOfSequenceResultDataList
    __del__ = lambda self: None
OutOfSequenceResultDataList_swigregister = _byteblower.OutOfSequenceResultDataList_swigregister
OutOfSequenceResultDataList_swigregister(OutOfSequenceResultDataList)

class OutOfSequenceResultHistory(AbstractRefreshableResult):
    """

    Receive-side out-of-sequence result history.

    ..note:: The information is not updated until :meth:`Refresh` is called

    ..note:: See History result for more information

    A OutOfSequence history result object can be created via a
    :class:`OutOfSequence`, using :meth:`.OutOfSequence.ResultHistoryGet`

    .. versionadded:: 2.1.0

    Example

    Receive all frames and check sequence on "trunk-1-2" of some server, matching
    UDP source or destination port 67.

    .. code-block:: python
       :emphasize-lines: 3

       outOfSequence_trigger = port.RxOutOfSequenceBasicAdd()
       outOfSequence_trigger.FilterSet('udp port 4096')
       #...
       outOfSequenceHistoryResult= outOfSequence_trigger.ResultHistoryGet()

    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutOfSequenceResultHistory, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OutOfSequenceResultHistory, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        """

        Clear the history.

        With each :meth:`Refresh` interval and cumulative counters are transferred
        from Server to the Client. To remove all counter-objects in this history, you
        can execute this method. Both Interval and Cumulative counter lists will be
        cleared.

        Example

        Clear the History.

        .. code-block:: python
           :emphasize-lines: 1

        	outOfSequenceHistoryResult.Clear()


        """
        return _byteblower.OutOfSequenceResultHistory_Clear(self)


    def SamplingIntervalDurationGet(self):
        """

        Duration of one sampling interval in nanoseconds.

        :return:  Duration in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

                print(outOfSequenceHistoryResult.SamplingIntervalDurationGet())



        """
        return _byteblower.OutOfSequenceResultHistory_SamplingIntervalDurationGet(self)


    def SamplingBufferLengthGet(self):
        """

        Number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        :return: The length of the server sample buffer

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceHistoryResult.SamplingBufferLengthGet())



        """
        return _byteblower.OutOfSequenceResultHistory_SamplingBufferLengthGet(self)


    def SamplingIntervalDurationSet(self, inDuration):
        """

        Sets the duration of one sampling interval.

        .. warning:: The previously collected history will be invalidated.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceHistoryResult.SamplingIntervalDurationSet(1000000000))



        """
        return _byteblower.OutOfSequenceResultHistory_SamplingIntervalDurationSet(self, inDuration)


    def SamplingBufferLengthSet(self, inLength):
        """

        Sets the number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	outOfSequenceHistoryResult.SamplingBufferLengthGet(6)



        """
        return _byteblower.OutOfSequenceResultHistory_SamplingBufferLengthSet(self, inLength)


    def CumulativeGet(self):
        """

        Returns a list of available cumulative counters.

        Each result object contains cumulative counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.

        :return: :class:`.OutOfSequenceResultDataList` containing the Cumulative counters

        Example

        This example gets the available cumulative results

        .. code-block:: python
           :emphasize-lines: 1

                print(outOfSequenceHistoryResult.CumulativeGet()[0].DescriptionGet())



        """
        return _byteblower.OutOfSequenceResultHistory_CumulativeGet(self)


    def CumulativeGetByIndex(self, index):
        """

        Returns a single item of the cumulative list.

        :param index: index
        :type index: int

        :return: cumulative counter object at the specified index
        :rtype: :class:`.OutOfSequenceResultData`

        Example
        This example gets the available cumulative counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceHistoryResult.CumulativeGetByIndex(0).DescriptionGet())



        """
        return _byteblower.OutOfSequenceResultHistory_CumulativeGetByIndex(self, index)


    def CumulativeLengthGet(self):
        """

        Returns the size of the cumulative list.

        :return: The length of the cumulative list

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceHistoryResult.CumulativeLengthGet())



        """
        return _byteblower.OutOfSequenceResultHistory_CumulativeLengthGet(self)


    def IntervalGet(self):
        """

        Returns a list of available interval results.

        Each result object contains interval counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.

        :return: :class:`.OutOfSquenceResultDataList` containing the Interval counters

        Example

        This example gets the available interval results

        .. code-block:: python
           :emphasize-lines: 1ouo

        	print(outOfSequenceHistoryResult.IntervalGet()[0].DescriptionGet())



        """
        return _byteblower.OutOfSequenceResultHistory_IntervalGet(self)


    def IntervalGetByIndex(self, index):
        """

        Returns a single item of the interval list.

        :param index: index

        :return: :class:`.OutOfSequenceResultData` interval counter object at the
                 specified index

        Example

        This example gets the available interval counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceHistoryResult.IntervalGetByIndex(0).DescriptionGet())



        """
        return _byteblower.OutOfSequenceResultHistory_IntervalGetByIndex(self, index)


    def IntervalLengthGet(self):
        """

        Returns the size of the interval list.

        :return:  The length of the interval list

        Example

        .. code-block:: python
           :emphasize-lines: 1

                print(outOfSequenceHistoryResult.IntervalLengthGet())



        """
        return _byteblower.OutOfSequenceResultHistory_IntervalLengthGet(self)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp on the server when the current history was refreshed.

        This is the timestamp on the server when the last :meth:`Refresh` was called.

        :return: Timestamp in nanoseconds since epoch

        Example

        This example gets the Refresh timestamp

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceHistoryResult.RefreshTimestampGet())



        """
        return _byteblower.OutOfSequenceResultHistory_RefreshTimestampGet(self)


    def CumulativeGetByTime(self, timestamp):
        """

        Returns a single item of the cumulative list using a timestamp.

        :param timestamp: timestamp in nanoseconds

        :return: :class:`.OutOfSequenceResultData`

        .. versionadded:: 2.2.0

        Example

        This example gets the cumulative counter at timestamp 1432805398000000000 ns

        .. code-block:: python
           :emphasize-lines: 1

           print(outOfSequenceHistoryResult.CumulativeGetByTime(1432805398000000000).DescriptionGet())


        """
        return _byteblower.OutOfSequenceResultHistory_CumulativeGetByTime(self, timestamp)


    def IntervalGetByTime(self, timestamp):
        """

        Returns a single item of the interval list using a timestamp.

        :param timestamp: timestamp in nanoseconds

        :return: :class:`.OutOfSequenceResultData`

        .. versionadded:: 2.2.0

        Example

        This example gets the Interval counters at timestamp 1432805398000000000 ns

        .. code-block:: python
           :emphasize-lines: 1

        	interval = outOfSequenceHistoryResult.IntervalGetByTime(1432805398000000000)



        """
        return _byteblower.OutOfSequenceResultHistory_IntervalGetByTime(self, timestamp)


    def CumulativeLatestGet(self):
        """

        Returns latest closed item of the cumulative list.

        :return: :class:`OutOfSequenceResultData`

        .. versionadded:: 2.2.0

        Example

        This example gets the latest closed Cumulative counter object

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequenceHistoryResult.CumulativeLatestGet().DescriptionGet())


        """
        return _byteblower.OutOfSequenceResultHistory_CumulativeLatestGet(self)


    def IntervalLatestGet(self):
        """

        Returns the latest closed item of the interval list.

        :return: :class:`.OutOfSquenceResultData`

        .. versionadded:: 2.2.0

        Example

        This example gets the latest closed Interval counter object

        .. code-block:: python
           :emphasize-lines: 3

        	print(outOfSequenceHistoryResult.IntervalLatestGet())



        """
        return _byteblower.OutOfSequenceResultHistory_IntervalLatestGet(self)

OutOfSequenceResultHistory_swigregister = _byteblower.OutOfSequenceResultHistory_swigregister
OutOfSequenceResultHistory_swigregister(OutOfSequenceResultHistory)

class OutOfSequence(TaggedRx):
    """

    Receive-side packet processor which checks out-of-sequence on the incoming frames, matching a filter.

    This out-of-sequence detection is always active and starts processing frames as
    soon as it is created. Processing continues until the packet processor is
    destructed.

    The sequence number of a packet is obtained from an out-of-sequence tag in the
    frame. This tag is configured on the :class:`FrameTagTx`, which can be obtained
    via :meth:`.Frame.FrameTagSequenceGet`.

    .. note:: The initial (empty) filter string accepts all incoming frames. See
              :meth:`FilterSet` for filtering information.

    A basic out-of-sequence object can be created via a ByteBlowerPort, using
    :meth:`.ByteBlowerPort.RxOutOfSequenceBasicAdd`

    This packet processor processes frames received on the ByteBlower interface
    where its parent ByteBlowerPort is located.

    Example

    Receive all frames on "trunk-1-33" of some server, matching UDP source or
    destination port 123.

    .. code-block:: python
       :emphasize-lines: 3

       outOfSequence_trigger = port.RxOutOfSequenceBasicAdd()
       outOfSequence_trigger.FilterSet('udp port 4096')


    """

    __swig_setmethods__ = {}
    for _s in [TaggedRx]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutOfSequence, name, value)
    __swig_getmethods__ = {}
    for _s in [TaggedRx]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, OutOfSequence, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultClear(self):
        """

        Resets the counter values to zero and empties the ResultHistory.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	resultHistory = outOfSequence_trigger.ResultClear()



        """
        return _byteblower.OutOfSequence_ResultClear(self)


    def ResultGet(self):
        """

        Returns the current accumulated trigger results.

        :return: :class:`OutOfSequenceBasicResultSnapshot` - The resultSnapshot is
                 returned containing the accumulated trigger counters.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           	print(outOfSequence_trigger.ResultGet().DescriptionGet())



        """
        return _byteblower.OutOfSequence_ResultGet(self)


    def ResultHistoryGet(self):
        """

        Returns the history of the results.

        :return: The :class:`OutOfSequenceResultHistory` is returned containing the
                 accumulated and interval trigger counters of the last 5 seconds.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           resultHistory = outOfSequence_trigger.ResultHistoryGet()



        """
        return _byteblower.OutOfSequence_ResultHistoryGet(self)


    def FilterGet(self):
        """

        Returns the current installed BPF filter string.

        The filter string can be configured using :meth:`FilterSet`

        :return: The current BPF filter string

        Example

        Suppose we configured the trigger with filter string:  where `$ipv4_1` and
        `$ipv4_2` are :class:`IPv4Configuration` objects and `$frameSize` is the
        (layer2) size of the frames (without CRC!). The BPF filter string would then
        become for example:

        .. code-block:: python
           :emphasize-lines: 1

        	print(outOfSequence_trigger.FilterGet())


        """
        return _byteblower.OutOfSequence_FilterGet(self)


    def FilterSet(self, arg2):
        """

        Sets a BPF filter on a RX object.

        .. note:: Configuring a new filter string does reset the counter values which
                  were triggered by a previous filter string. Also the earlier
                  collected history is invalidated.

        :param bpfstring: Valid BPF filter string. For creating valid BPF filter
                          strings, please have a look at
                          http://www.tcpdump.org/#documentation for more
                          information.

        :raises: ByteBlower.Rx.* - When the {server-side} RX object could not be
                 resolved.

        :raises: ByteBlower.Rx.Filter.CompilationFailed - When an invalid BPF filter
                 string is given.

        :raises: ByteBlower.InvalidFilter - When an invalid BPF filter string is given.

        Example

        This will filter only UDP traffic.  Set the filter on packets that match:

        - source and destination IPv4 address
        - UDP traffic with given destination and source UDP port
        - (layer2) frame length (without CRC!)

        .. code-block:: python
           :emphasize-lines: 1

        	outOfSequence_trigger.FilterSet('ip dst 1.1.1.1 and udp port 4096')



        """
        return _byteblower.OutOfSequence_FilterSet(self, arg2)

OutOfSequence_swigregister = _byteblower.OutOfSequence_swigregister
OutOfSequence_swigregister(OutOfSequence)

class Latency(TaggedRx):
    __swig_setmethods__ = {}
    for _s in [TaggedRx]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Latency, name, value)
    __swig_getmethods__ = {}
    for _s in [TaggedRx]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Latency, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
Latency_swigregister = _byteblower.Latency_swigregister
Latency_swigregister(Latency)

class LatencyBasicResultSnapshot(AbstractRefreshableResult):
    """

    Receive-side latency result set.

    The result set contains the latency information of since the object is created
    or refreshed.

    ..note:: The information is not updated until :meth:`Refresh` is called

    .. note:: See What's new in API v2 for more information.

    A basic latency result snapshot object can be created via a
    :class:`.LatencyBasic`, using :meth:`.LatencyBasic.ResultGet`

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or destination
    port 67.

    .. code-block:: python

    	latencyTrigger = port.RxLatencyBasicAdd()
    	latency_result = latencyTrigger.ResultGet()


    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatencyBasicResultSnapshot, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LatencyBasicResultSnapshot, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_result.TimestampGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_TimestampGet(self)


    def TimestampFirstGet(self):
        """

        Gets the timestamp [NS] of the first packet in this snapshot.

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

           	print(latency_result.TimestampFirstGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_TimestampFirstGet(self)


    def TimestampLastGet(self):
        """

        Gets the current timestamp [NS] of the last packet in this snapshot.

        Example

        This example gets the timestamp [NS] of the last received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_result.TimestampLastGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_TimestampLastGet(self)


    def PacketCountGet(self):
        """

        Gets the received packet count.

        Example

        This example gets the received packet counter

        .. code-block:: python
           :emphasize-lines: 1

           	print(latency_result.PacketCountGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_PacketCountGet(self)


    def ByteCountGet(self):
        """

        Gets the current received bytes counter.

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_result.ByteCountGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_ByteCountGet(self)


    def FramesizeMaximumGet(self):
        """

        Gets the size (in bytes) of the largest frame received in this snapshot.

        .. versionadded:: 2.6.4

        Example

        This example gets the largest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_result.FramesizeMaximumGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_FramesizeMaximumGet(self)


    def FramesizeMinimumGet(self):
        """

        Gets the size (in bytes) of the smallest frame received in this snapshot.

        .. versionadded:: 2.6.4

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_result.FramesizeMaximumGet())


        """
        return _byteblower.LatencyBasicResultSnapshot_FramesizeMinimumGet(self)


    def PacketCountValidGet(self):
        """

        Gets the received packet count of valid packets.

        Example

        This example gets the received valid packet counter

        .. code-block:: python
           :emphasize-lines: 3

           	print(latency_result.PacketCountValidGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_PacketCountValidGet(self)


    def PacketCountInvalidGet(self):
        """

        Gets the received packet count of invalid packets.

        Example

        This example gets the received invalid packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_result.PacketCountInvalidGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_PacketCountInvalidGet(self)


    def LatencyMinimumGet(self):
        """

        Gets the minimum latency [ns] measured in this snapshot.

        Example

        This example gets the minimum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_result.LatencyMinimumGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_LatencyMinimumGet(self)


    def LatencyMaximumGet(self):
        """

        Gets the maximum latency [ns] measured in this snapshot.

        Example

        This example gets the maximum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_result.LatencyMaximumGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_LatencyMaximumGet(self)


    def LatencyAverageGet(self):
        """

        Gets the average latency [ns] measured in this snapshot.

        Example

        This example gets the average latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           	print(latency_result.LatencyAverageGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_LatencyAverageGet(self)


    def JitterGet(self):
        """

        Gets the jitter [ns] measured in this snapshot.

        The jitter is defined as the standard deviation of the measured latency.

        Example

        This example gets the jitter measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

           	print(latency_result.JitterGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_JitterGet(self)


    def IntervalDurationGet(self):
        """

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

           	print(latency_result.IntervalDurationGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_IntervalDurationGet(self)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp when the counters of this object where last refreshed.

        Example

        .. code-block:: python
           :emphasize-lines: 3

           	print(latency_result.RefreshTimestampGet())



        """
        return _byteblower.LatencyBasicResultSnapshot_RefreshTimestampGet(self)

LatencyBasicResultSnapshot_swigregister = _byteblower.LatencyBasicResultSnapshot_swigregister
LatencyBasicResultSnapshot_swigregister(LatencyBasicResultSnapshot)

class LatencyBasicResultData(AbstractObject):
    """

    Receive-side latency result set.

    The result set contains the latency information of since the object is created
    or refreshed.

    .. note:: See What's new in API v2 for more information.

    A basic trigger result data snapshot object can be created via a
    :class:`.LatencyBasicResultHistory`, using
    :meth:`.LatencyBasic.ResultHistoryGet`

    .. note:: The information is not updated until
              :meth:`.LatencyBasicResultHistory.Refresh` is called.

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.

    .. code-block:: python
       :emphasize-lines: 1

       latencyTrigger = port.RxLatencyBasicAdd()
       latencyTrigger.FilterSet('udp port 67')
       #...
       latencyResultData = latencyTrigger.ResultHistoryGet().CumulativeLatestGet()



    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatencyBasicResultData, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LatencyBasicResultData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(latencyResultData.TimestampGet())



        """
        return _byteblower.LatencyBasicResultData_TimestampGet(self)


    def TimestampFirstGet(self):
        """

        Gets the timestamp [NS] of the first packet in this snapshot.

        :raises: CounterUnavailable: When no frames are received, this counter is
                                     unavailable

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.TimestampFirstGet())



        """
        return _byteblower.LatencyBasicResultData_TimestampFirstGet(self)


    def TimestampLastGet(self):
        """

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :raises: CounterUnavailable: When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the last received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.TimestampLastGet())



        """
        return _byteblower.LatencyBasicResultData_TimestampLastGet(self)


    def PacketCountGet(self):
        """

        Gets the received packet count.

        Example

        This example gets the received packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.PacketCountGet())



        """
        return _byteblower.LatencyBasicResultData_PacketCountGet(self)


    def ByteCountGet(self):
        """

        Gets the current received bytes counter.

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.ByteCountGet())



        """
        return _byteblower.LatencyBasicResultData_ByteCountGet(self)


    def FramesizeMaximumGet(self):
        """

        Gets the size (in bytes) of the largest frame received in this snapshot.

        Example

        This example gets the largest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.FramesizeMaximumGet())



        """
        return _byteblower.LatencyBasicResultData_FramesizeMaximumGet(self)


    def FramesizeMinimumGet(self):
        """

        Gets the size (in bytes) of the smallest frame received in this snapshot.

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.FramesizeMinimumGet())



        """
        return _byteblower.LatencyBasicResultData_FramesizeMinimumGet(self)


    def PacketCountValidGet(self):
        """

        Gets the received packet count of valid packets.

        Example

        This example gets the received valid packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.PacketCountValidGet())



        """
        return _byteblower.LatencyBasicResultData_PacketCountValidGet(self)


    def PacketCountInvalidGet(self):
        """

        Gets the received packet count of invalid packets.

        Example

        This example gets the received invalid packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.PacketCountInvalidGet())



        """
        return _byteblower.LatencyBasicResultData_PacketCountInvalidGet(self)


    def LatencyMinimumGet(self):
        """

        Gets the minimum latency [ns] measured in this snapshot.

        Example

        This example gets the minimum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.LatencyMinimumGet())


        """
        return _byteblower.LatencyBasicResultData_LatencyMinimumGet(self)


    def LatencyMaximumGet(self):
        """

        Gets the maximum latency [ns] measured in this snapshot.

        Example

        This example gets the maximum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.LatencyMaximumGet())



        """
        return _byteblower.LatencyBasicResultData_LatencyMaximumGet(self)


    def LatencyAverageGet(self):
        """

        Gets the average latency [ns] measured in this snapshot.

        Example

        This example gets the average latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.LatencyAverageGet())



        """
        return _byteblower.LatencyBasicResultData_LatencyAverageGet(self)


    def JitterGet(self):
        """

        Gets the jitter [ns] measured in this snapshot.

        Example

        This example gets the jitter measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyResultData.JitterGet())



        """
        return _byteblower.LatencyBasicResultData_JitterGet(self)


    def IntervalDurationGet(self):
        """

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 3

        	print(latencyResultData.IntervalDurationGet())



        """
        return _byteblower.LatencyBasicResultData_IntervalDurationGet(self)

LatencyBasicResultData_swigregister = _byteblower.LatencyBasicResultData_swigregister
LatencyBasicResultData_swigregister(LatencyBasicResultData)

class LatencyBasicResultDataList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatencyBasicResultDataList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LatencyBasicResultDataList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.LatencyBasicResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.LatencyBasicResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.LatencyBasicResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.LatencyBasicResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.LatencyBasicResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.LatencyBasicResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.LatencyBasicResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.LatencyBasicResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.LatencyBasicResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.LatencyBasicResultDataList___setitem__(self, *args)

    def pop(self):
        return _byteblower.LatencyBasicResultDataList_pop(self)

    def append(self, x):
        return _byteblower.LatencyBasicResultDataList_append(self, x)

    def empty(self):
        return _byteblower.LatencyBasicResultDataList_empty(self)

    def size(self):
        return _byteblower.LatencyBasicResultDataList_size(self)

    def swap(self, v):
        return _byteblower.LatencyBasicResultDataList_swap(self, v)

    def begin(self):
        return _byteblower.LatencyBasicResultDataList_begin(self)

    def end(self):
        return _byteblower.LatencyBasicResultDataList_end(self)

    def rbegin(self):
        return _byteblower.LatencyBasicResultDataList_rbegin(self)

    def rend(self):
        return _byteblower.LatencyBasicResultDataList_rend(self)

    def clear(self):
        return _byteblower.LatencyBasicResultDataList_clear(self)

    def get_allocator(self):
        return _byteblower.LatencyBasicResultDataList_get_allocator(self)

    def pop_back(self):
        return _byteblower.LatencyBasicResultDataList_pop_back(self)

    def erase(self, *args):
        return _byteblower.LatencyBasicResultDataList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_LatencyBasicResultDataList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.LatencyBasicResultDataList_push_back(self, x)

    def front(self):
        return _byteblower.LatencyBasicResultDataList_front(self)

    def back(self):
        return _byteblower.LatencyBasicResultDataList_back(self)

    def assign(self, n, x):
        return _byteblower.LatencyBasicResultDataList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.LatencyBasicResultDataList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.LatencyBasicResultDataList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.LatencyBasicResultDataList_reserve(self, n)

    def capacity(self):
        return _byteblower.LatencyBasicResultDataList_capacity(self)
    __swig_destroy__ = _byteblower.delete_LatencyBasicResultDataList
    __del__ = lambda self: None
LatencyBasicResultDataList_swigregister = _byteblower.LatencyBasicResultDataList_swigregister
LatencyBasicResultDataList_swigregister(LatencyBasicResultDataList)

class LatencyBasicResultHistory(AbstractRefreshableResult):
    """

    Receive-side latency result history.

    The history contains the latency information in time since the object is
    created or refreshed.

    .. note:: The information is not updated until :meth:`Refresh` is called

    .. note:: See History result for more information

    A basic latency result snapshot object can be created via a
    :class:`.LatencyBasic`, using :meth:`.LatencyBasic.ResultHistoryGet`

    .. versionadded:: 2.1.0

    Example

    Receive all frames on "trunk-1-2" of some server

    .. code-block:: python

    	latencyTrigger = port.RxLatencyBasicAdd()
    	latency_historyResult.latencyTrigger.ResultHistoryGet()



    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatencyBasicResultHistory, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LatencyBasicResultHistory, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        """

        Clear the history.

        With each :meth:`Refresh` interval and cumulative counters are transferred from
        Server to the Client. To remove all counter-objects in this history, you can
        execute this method. Both Interval and Cumulative counter lists will be
        cleared.

        Example

        Clear the History.

        .. code-block:: python
           :emphasize-lines: 1

        	latency_historyResult.Clear()



        """
        return _byteblower.LatencyBasicResultHistory_Clear(self)


    def CumulativeGet(self):
        """

        Returns a list of available cumulative counters.

        Each result object contains cumulative counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.

        :return: :class:`.LatencyBasicResultDataList`

        Example

        This example gets the available cumulative results

        .. code-block:: python
           :emphasize-lines: 1

        	counterList = latency_historyResult.CumulativeGet()



        """
        return _byteblower.LatencyBasicResultHistory_CumulativeGet(self)


    def CumulativeGetByIndex(self, index):
        """

        Returns a single item of the cumulative list.

        :param index: index

        :return: :class:`.LatencyBasicResultData` cumulative counter object at the
                 specified index

        Example

        This example gets the available cumulative counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

           resultData = latency_historyResult.CumulativeGetByIndex(0)


        """
        return _byteblower.LatencyBasicResultHistory_CumulativeGetByIndex(self, index)


    def CumulativeLengthGet(self):
        """

        Returns the size of the cumulative list.

        :return:  The length of the cumulative list

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_historyResult.CumulativeLengthGet())


        """
        return _byteblower.LatencyBasicResultHistory_CumulativeLengthGet(self)


    def SamplingIntervalDurationGet(self):
        """

        Duration of one sampling interval in nanoseconds.

        :return:  Duration in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_historyResult.SamplingIntervalDurationGet())



        """
        return _byteblower.LatencyBasicResultHistory_SamplingIntervalDurationGet(self)


    def SamplingBufferLengthGet(self):
        """

        Number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        :return: The length of the server sample buffer

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_historyResult.SamplingBufferLengthGet())



        """
        return _byteblower.LatencyBasicResultHistory_SamplingBufferLengthGet(self)


    def SamplingIntervalDurationSet(self, inDuration):
        """

        Sets the duration of one sampling interval.

        .. warning :: The previously collected history will be invalidated.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latency_historyResult.SamplingIntervalDurationSet(1000000000)



        """
        return _byteblower.LatencyBasicResultHistory_SamplingIntervalDurationSet(self, inDuration)


    def SamplingBufferLengthSet(self, inLength):
        """

        Sets the number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	resultData = latency_historyResult.SamplingBufferLengthSet(6)


        """
        return _byteblower.LatencyBasicResultHistory_SamplingBufferLengthSet(self, inLength)


    def IntervalGet(self):
        """

        Returns a list of available interval results.

        Each result object contains interval counters at a certain point in time.
        Snapshots are taken at fixed time intervals. The interval duration can be
        obtained using :meth:`SamplingIntervalDurationGet`.

        :return: :class:`.LatencyBasicResultDataList` containing the Interval counters

        Example

        This example gets the available interval results

        .. code-block:: python
           :emphasize-lines: 3

        	listInterval = latency_historyResult.IntervalGet()


        """
        return _byteblower.LatencyBasicResultHistory_IntervalGet(self)


    def IntervalGetByIndex(self, index):
        """

        Returns a single item of the interval list.

        :param index: index

        :return: :class:`.LatencyBasicResultData` interval counter object at the
                 specified index

        Example

        This example gets the available interval counters at index 1

        .. code-block:: python
           :emphasize-lines: 1

        	latencyData = latency_historyResult.IntervalGetByIndex(0)


        """
        return _byteblower.LatencyBasicResultHistory_IntervalGetByIndex(self, index)


    def IntervalLengthGet(self):
        """

        Returns the size of the interval list.

        :return:  The length of the interval list

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_historyResult.IntervalLengthGet())



        """
        return _byteblower.LatencyBasicResultHistory_IntervalLengthGet(self)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp on the server when the current history was refreshed.

        This is the timestamp on the server when the last :meth:`Refresh` was called.

        :return: Timestamp in nanoseconds since epoch

        Example

        This example gets the Refresh timestamp

        .. code-block:: python
           :emphasize-lines: 1

        	print(latency_historyResult.RefreshTimestampGet())



        """
        return _byteblower.LatencyBasicResultHistory_RefreshTimestampGet(self)


    def CumulativeGetByTime(self, timestamp):
        """

        Returns a single item of the cumulative list using a timestamp.

        :param timestamp: timestamp  in nanoseconds

        :return: :class:`.LatencyBasicResultData`

        .. versionadded:: 2.2.0

        Example

        This example gets the cumulative counter at timestamp 1432805398000000000 ns

        .. code-block:: python
           :emphasize-lines: 3

           result_data = latency_historyResult.CumulativeGetByTime(timestamp)


        """
        return _byteblower.LatencyBasicResultHistory_CumulativeGetByTime(self, timestamp)


    def IntervalGetByTime(self, timestamp):
        """

        Returns a single item of the interval list using a timestamp.

        :param timestamp: timestamp in nanoseconds

        :return: :class:`.LatencyBasicResultData`

        .. versionadded:: 2.2.0

        Example

        This example gets the Interval counters at timestamp 1432805398000000000 ns

        .. code-block:: python
           :emphasize-lines: 1

        	interval = latency_historyResult.IntervalGetByTime(timestamp)



        """
        return _byteblower.LatencyBasicResultHistory_IntervalGetByTime(self, timestamp)


    def CumulativeLatestGet(self):
        """

        Returns latest closed item of the cumulative list.

        :return: :class:`.LatencyBasicResultData`

        .. versionadded:: 2.2.0

        Example

        This example gets the latest closed Cumulative counter object

        .. code-block:: python
           :emphasize-lines: 3

        	resultData = latency_historyResult.CumulativeLatestGet()


        """
        return _byteblower.LatencyBasicResultHistory_CumulativeLatestGet(self)


    def IntervalLatestGet(self):
        """

        Returns the latest closed item of the interval list.

        :return: :class:`.LatencyBasicResultData`

        .. versionadded:: 2.2.0

        Example

        This example gets the latest closed Interval counter object

        .. code-block:: python
           :emphasize-lines: 1

        	Interval = latency_historyResult.IntervalLatestGet()


        """
        return _byteblower.LatencyBasicResultHistory_IntervalLatestGet(self)

LatencyBasicResultHistory_swigregister = _byteblower.LatencyBasicResultHistory_swigregister
LatencyBasicResultHistory_swigregister(LatencyBasicResultHistory)

class LatencyBasic(Latency):
    """

    Receive-side packet processor which calculates latency on the incoming frames,
    matching a filter.

    The basic latency processor extends the basic trigger. It provides additional
    information like latency and jitter. See :meth:`ResultGet` for more
    information.

    This latency calculation is always active and starts processing frames as soon
    as it is created. Processing continues until the packet processor is destructed.

    The transmit time stamp of a packet is obtained from a time tag in the frame.
    This tag is configured on the :class:`.FrameTagTx`, which can be obtained via
    :meth:`.Frame.FrameTagTimeGet`.

    .. note:: The initial (empty) filter string accepts all incoming frames. See
              :meth:`FilterSet` for     filtering information.

    A basic latency object can be created via a ByteBlowerPort, using
    :meth:`.ByteBlowerPort.RxLatencyBasicAdd`

    This packet processor processes frames received on the ByteBlower interface
    where its parent ByteBlowerPort is located.

    Example

    Receive all frames on "trunk-1-45" of some server, matching UDP source or
    destination port 49523.

    .. code-block:: python
       :emphasize-lines: 3

    	latencyTrigger = port.RxLatencyBasicAdd()
    	latencyTrigger.FilterSet('ip dst 1.1.1.2 and udp port 4096')


    """

    __swig_setmethods__ = {}
    for _s in [Latency]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatencyBasic, name, value)
    __swig_getmethods__ = {}
    for _s in [Latency]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LatencyBasic, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultClear(self):
        """

        Resets the counter values to zero and empties the ResultHistory.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latencyTrigger.ResultClear()


        """
        return _byteblower.LatencyBasic_ResultClear(self)


    def ResultGet(self):
        """

        Returns the current result counters.

        :return: :class:`.LatencyBasicResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	result = latencyTrigger.ResultGet()



        """
        return _byteblower.LatencyBasic_ResultGet(self)


    def ResultHistoryGet(self):
        """

        Returns the current trigger history counters.

        :return: :class:`.LatencyBasicResultHistory`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	resultHistory = latencyTrigger.ResultHistoryGet()


        """
        return _byteblower.LatencyBasic_ResultHistoryGet(self)


    def FilterGet(self):
        """

        Returns the current installed BPF filter string.

        The filter string can be configured using :meth:`FilterSet`

        :return: The current BPF filter string

        Example

        Suppose we configured the trigger with filter string:  where `$ipv4_1` and
        `$ipv4_2` are :class:`IPv4Configuration` objects and `$frameSize` is the
        (layer2) size of the frames (without CRC!). The BPF filter string would then
        become for example:

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyTrigger.FilterGet())



        """
        return _byteblower.LatencyBasic_FilterGet(self)


    def FilterSet(self, arg2):
        """

        Sets a BPF filter on a RX object.

        ..note:: Configuring a new filter string does reset the counter values which
                 were triggered by a previous filter string. Also the earlier collected
                 history is invalidated.

        :param bpfString: Valid BPF filter string. For creating valid BPF filter
                          strings, please have a look at
                          http://www.tcpdump.org/#documentation for more information.

        :raises: ByteBlower.Rx.* - When the {server-side} RX object could not be
                 resolved.

        :raises: ByteBlower.Rx.Filter.CompilationFailed - When an invalid BPF filter
                 string is given.

        :raises: ByteBlower.InvalidFilter - When an invalid BPF filter string is given.

        Example

        This will filter only UDP traffic.  Set the filter on packets that match:

        - source and destination IPv4 address
        - UDP traffic with given destination and source UDP port
        - (layer2) frame length (without CRC!)

        .. code-block:: python
           :emphasize-lines: 3

        	latencyTrigger.FilterSet('ip dst 1.1.1.2 and udp port 4096')



        """
        return _byteblower.LatencyBasic_FilterSet(self, arg2)

LatencyBasic_swigregister = _byteblower.LatencyBasic_swigregister
LatencyBasic_swigregister(LatencyBasic)

class LatencyBasicMobile(Latency):
    """

    Receive-side packet processor which calculates latency on the incoming frames,
    matching a filter.

    .. versionadded:: 2.6.0

    The basic latency processor extends the basic trigger. It provides additional
    information like latency and jitter. See :meth:`ResultGet` for more
    information.

    The transmit time stamp of a packet is obtained from a time tag in the frame.
    This tag is configured on the :class:`FrameTagTx`, which can be obtained via
    :meth:`.Frame.FrameTagTimeGet`.

    A basic latency object can be created via a WirelessEndpoint, using
    :meth:`.WirelessEndpoint.RxLatencyBasicAdd`

    Example

    .. code-block:: python
       :emphasize-lines: 1

    	latencyTrigger = wirelessEndpoint.RxLatencyBasicAdd()
    	latencyTrigger.FilterUdpSourcePortSet(4096)


    """

    __swig_setmethods__ = {}
    for _s in [Latency]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatencyBasicMobile, name, value)
    __swig_getmethods__ = {}
    for _s in [Latency]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LatencyBasicMobile, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultClear(self):
        """

        Resets the counter values to zero and empties the ResultHistory.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latencyMobileTrigger.ResultClear()

        """
        return _byteblower.LatencyBasicMobile_ResultClear(self)


    def ResultHistoryGet(self):
        """

        Returns the current History counters.

        This method returns a :class:`.LatencyBasicResultHistory` Object. This will
        contain the Cumulative and the Interval counters over time. Use this to create
        results over time.

        :return: :class:`.LatencyBasicResultHistory`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	resultHistory = latencyMobileTrigger.ResultHistoryGet()

        """
        return _byteblower.LatencyBasicMobile_ResultHistoryGet(self)


    def ResultGet(self):
        """

        Returns the current result counters.

        This method will return an object of :class:`LatencyBasicResultSnapshot`.
        It will contain all the current Cumulative counters. To update the counters,
        call :meth:`LatencyBasicResultSnapthost.Refresh` on
        :class:`LatencyBasicResultSnapshot`

        :return: :class:`LatencyBasicResultSnapshot`

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	latencyMobileTrigger.ResultGet()


        """
        return _byteblower.LatencyBasicMobile_ResultGet(self)


    def FilterSourceAddressGet(self):
        """

        Returns the source address field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyMobileTrigger.FilterSourceAddressGet())


        """
        return _byteblower.LatencyBasicMobile_FilterSourceAddressGet(self)


    def FilterSourceAddressSet(self, inAddress):
        """

        Sets the source address field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latencyMobileTrigger.FilterSourceAddressSet('10.8.1.2')


        """
        return _byteblower.LatencyBasicMobile_FilterSourceAddressSet(self, inAddress)


    def FilterUdpSourcePortGet(self):
        """

        Returns the source port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyMobileTrigger.FilterUdpSourcePortGet())



        """
        return _byteblower.LatencyBasicMobile_FilterUdpSourcePortGet(self)


    def FilterUdpSourcePortSet(self, inPort):
        """

        Sets the source port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latencyMobileTrigger.FilterUdpSourcePortSet(4096)


        """
        return _byteblower.LatencyBasicMobile_FilterUdpSourcePortSet(self, inPort)


    def FilterUdpDestinationPortGet(self):
        """

        Returns the destination port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyMobileTrigger.FilterUdpDestinationPortGet())

        """
        return _byteblower.LatencyBasicMobile_FilterUdpDestinationPortGet(self)


    def FilterUdpDestinationPortSet(self, inPort):
        """

        Sets the destination port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latencyMobileTrigger.FilterUdpDestinationPortSet(4096)



        """
        return _byteblower.LatencyBasicMobile_FilterUdpDestinationPortSet(self, inPort)


    def DurationGet(self):
        """

        Returns the duration for which the trigger will be active.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyMobileTrigger.DurationGet())

        """
        return _byteblower.LatencyBasicMobile_DurationGet(self)


    def DurationSet(self, inDuration):
        """

        Sets the duration for which the trigger will be active.

        Configures how long the trigger will listen for incoming packets.

        Example

        Listen for 10 minutes

        .. code-block:: python
           :emphasize-lines: 1

        	latencyMobileTrigger.DurationSet(10*1000000000)

        """
        return _byteblower.LatencyBasicMobile_DurationSet(self, inDuration)


    def FilterGet(self):
        return _byteblower.LatencyBasicMobile_FilterGet(self)

    def FilterSet(self, arg2):
        return _byteblower.LatencyBasicMobile_FilterSet(self, arg2)
LatencyBasicMobile_swigregister = _byteblower.LatencyBasicMobile_swigregister
LatencyBasicMobile_swigregister(LatencyBasicMobile)

class LatencyDistributionResultSnapshot(AbstractRefreshableResult):
    """

    The latency distribution result.

    .. note:: The information is not updated until :meth:`Refresh` is called

    .. note:: See What's new in API v2 for more information.



    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatencyDistributionResultSnapshot, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LatencyDistributionResultSnapshot, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.TimestampGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_TimestampGet(self)


    def TimestampFirstGet(self):
        """

        Gets the timestamp [NS] of the first packet in
        this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.TimestampFirstGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_TimestampFirstGet(self)


    def TimestampLastGet(self):
        """

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the last received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.TimestampLastGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_TimestampLastGet(self)


    def PacketCountGet(self):
        """

        Gets the received packet count.

        Example

        This example gets the received packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.PacketCountGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_PacketCountGet(self)


    def ByteCountGet(self):
        """

        Gets the current received bytes counter.

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.ByteCountGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_ByteCountGet(self)


    def FramesizeMaximumGet(self):
        """

        Gets the largest frame size received in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.FramesizeMaximumGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_FramesizeMaximumGet(self)


    def FramesizeMinimumGet(self):
        """


        Function: FramesizeMinimumGet

        Gets the smallest frame size received in this
        snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 3

        	print(latencyDistributionSnapshot.FramesizeMinimumGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_FramesizeMinimumGet(self)


    def PacketCountValidGet(self):
        """

        Gets the received packet count of valid packets.

        Example

        This example gets the received valid packet counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.PacketCountValidGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_PacketCountValidGet(self)


    def PacketCountInvalidGet(self):
        """

        Gets the received packet count of invalid packets.

        Example

        This example gets the received invalid packet counter

        .. code-block:: python
           :emphasize-lines: 3

        	print(latencyDistributionSnapshot.PacketCountInvalidGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_PacketCountInvalidGet(self)


    def LatencyMinimumGet(self):
        """

        Gets the minimum latency [ns] measured in this snapshot.

        Example

        This example gets the minimum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.LatencyMinimumGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_LatencyMinimumGet(self)


    def LatencyMaximumGet(self):
        """

        Gets the maximum latency [ns] measured in this snapshot.

        Example

        This example gets the maximum latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.LatencyMaximumGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_LatencyMaximumGet(self)


    def LatencyAverageGet(self):
        """

        Gets the average latency [ns] measured in this snapshot.

        Example

        This example gets the average latency measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.LatencyAverageGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_LatencyAverageGet(self)


    def JitterGet(self):
        """

        Gets the jitter [ns] measured in this snapshot.

        Example

        This example gets the jitter measured in this snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.JitterGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_JitterGet(self)


    def RangeMinimumGet(self):
        """

        Returns the inclusive minimum of the range configured.

        :return: The lower bound of the configured range on the
                 :class:`.LatencyDistribution` object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.RangeMinimumGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_RangeMinimumGet(self)


    def RangeMaximumGet(self):
        """

        Returns the exclusive maximum of the range configured.

        :return: The lower bound of the configured range on the
                 :class:`.LatencyDistribution` object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.RangeMaximumGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_RangeMaximumGet(self)


    def BucketWidthGet(self):
        """

        Returns the width in nanoseconds of a bucket.

        Example

        .. code-block:: python
           :emphasize-lines: 3

        	print(latencyDistributionSnapshot.BucketWidthGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_BucketWidthGet(self)


    def BucketCountGet(self):
        """

        Returns the number of buckets in which the range is divided.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(latencyDistributionSnapshot.BucketCountGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_BucketCountGet(self)


    def PacketCountBelowMinimumGet(self):
        """

        Returns the number of packets arrived with a latency below the given range.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.PacketCountBelowMinimumGet())


        """
        return _byteblower.LatencyDistributionResultSnapshot_PacketCountBelowMinimumGet(self)


    def PacketCountAboveMaximumGet(self):
        """

        Returns the number of packets arrived with a latency above the given range.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.PacketCountAboveMaximumGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_PacketCountAboveMaximumGet(self)


    def PacketCountBucketsGet(self):
        """

        Returns the number of packets received per bucket.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.PacketCountBucketsGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_PacketCountBucketsGet(self)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp when the counters of this object where last refreshed.

        ..note:: This is not the same as :meth:`TimestampGet`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyDistributionSnapshot.RefreshTimestampGet())



        """
        return _byteblower.LatencyDistributionResultSnapshot_RefreshTimestampGet(self)

LatencyDistributionResultSnapshot_swigregister = _byteblower.LatencyDistributionResultSnapshot_swigregister
LatencyDistributionResultSnapshot_swigregister(LatencyDistributionResultSnapshot)

class LatencyDistribution(Latency):
    """

    Receive-side packet processor which calculates distribution of latency on the
    incoming frames, matching a filter.

    This latency distribution calculation is always active and starts processing
    frames as soon as it is created. Processing continues until the packet
    processor is destructed.

    The transmit time stamp of a packet is obtained from a time tag in the frame.
    This tag is configured on the FrameTag.Tx, which can be obtained via
    :meth:.Frame.FrameTagTimeGet`.

    ..note:: The initial (empty) filter string accepts all incoming frames.
    See :meth:`FilterSet` for filtering information.

    A latency distribution object can be created via a :class:`.ByteBlowerPort`,
    using :meth:`.ByteBlowerPort.RxLatencyDistributionAdd`

    This packet processor processes frames received on the ByteBlower interface
    where its parent ByteBlowerPort is located.

    Example

    Receive all frames on "trunk-1-45" of some server, matching UDP source or
    destination port 49523.

    .. code-block:: python
       :emphasize-lines: 3

       from byteblowerll.byteblower import ByteBlower
       server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
       # TODO


    """

    __swig_setmethods__ = {}
    for _s in [Latency]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatencyDistribution, name, value)
    __swig_getmethods__ = {}
    for _s in [Latency]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LatencyDistribution, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultGet(self):
        """

        Returns the current result counters.

        :return: :class:`.LatencyDistributionResultSnapshot` result object

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latencyDistributionSnapshot = distributionTrigger.ResultGet()



        """
        return _byteblower.LatencyDistribution_ResultGet(self)


    def ResultHistoryGet(self):
        """

        Returns the current result counters.

        :return: :class:`.LatencyDistributionResultHistory` result object

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latencyDistributionHistory = distributionTrigger.ResultHistoryGet()



        """
        return _byteblower.LatencyDistribution_ResultHistoryGet(self)


    def BucketCountGet(self):
        return _byteblower.LatencyDistribution_BucketCountGet(self)

    def BucketWidthGet(self):
        return _byteblower.LatencyDistribution_BucketWidthGet(self)

    def RangeMinimumGet(self):
        return _byteblower.LatencyDistribution_RangeMinimumGet(self)

    def RangeMaximumGet(self):
        return _byteblower.LatencyDistribution_RangeMaximumGet(self)

    def RangeSet(self, rangeStartNs, rangeEndNs):
        """

        Configures the range for which the Latency Distribution will measure the latency and create a distribution.

        Default value: [0, 1s[

        .. note:: Nanosecond resolution is supported for versions 1.8.24 and beyond
                  (older versions only supported up to microsecond resolution).

        Bug

        An incorrect exception is thrown when an invalid
        range is given.

        :raises: <tcl_error> - 'LAT001': When trying to configure an invalid range.

        Example

        This will set the range from 0 to 5seconds.

        .. code-block:: python
           :emphasize-lines: 1

        	distributionTrigger.RangeSet(0, 100)


        """
        return _byteblower.LatencyDistribution_RangeSet(self, rangeStartNs, rangeEndNs)


    def RangeGet(self):
        """

        Returns the current configured range for the latency distribution.

        Example

        Suppose the range has been configured for [0,750ms[

        .. code-block:: python
           :emphasize-lines: 1

        	print(distributionTrigger.RangeGet())


        """
        return _byteblower.LatencyDistribution_RangeGet(self)


    def ResultClear(self):
        """

        Resets the counter values to zero.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	distributionTrigger.ResultClear()


        """
        return _byteblower.LatencyDistribution_ResultClear(self)


    def FilterSet(self, inFilter):
        """

        Sets a BPF filter on a RX object.

        .. note:: Configuring a new filter string does not reset the counter values
                  which were triggered by a previous filter string.

        :param bpfString: Valid BPF filter string. For creating valid BPF filter
                          strings, please have a look at
                          http://www.tcpdump.org/#documentation
                          for more  information.

        :raises: ByteBlower.Rx.* - When the {server-side} RX object could not be
                 resolved.
        :raises: ByteBlower.Rx.Filter.CompilationFailed - When an invalid BPF filter
                 string is given.
        :raises: ByteBlower.InvalidFilter - When an invalid BPF filter string is given.

        Example
        This will filter only UDP traffic.  Set the filter on packets that match:

        - source and destination IPv4 address

        - UDP traffic with given destination and source UDP port

        - (layer2) frame length (without CRC!)

        .. code-block:: python
           :emphasize-lines: 1

        	bpf_filter = 'ip dst {} and udp port {}'.format(dst_ip, udp_dest)
        	distributionTrigger.FilterSet(bpf_filter)


        """
        return _byteblower.LatencyDistribution_FilterSet(self, inFilter)


    def FilterGet(self):
        """

        Returns the current installed BPF filter string.

        The filter string can be configured using :meth:`FilterSet`

        :return: The current BPF filter string

        Example

        Suppose we configured the trigger with filter string:
        where `ipv4_1` and `ipv4_2` are :class:`IPv4Configuration` objects and
        `frameSize` is the (layer2) size of the frames (without CRC!). The
        BPF filter string would then become for example:

        .. code-block:: python
           :emphasize-lines: 1

        	print(distributionTrigger.FilterGet())


        """
        return _byteblower.LatencyDistribution_FilterGet(self)


    def FrameTagSet(self, fromFrameTagTx):
        """

        Configure the FrameTagRx to match the given FrameTagTx.

        This method takes a FrameTag.Tx and applies its metrics and format
        configuration on this trigger's :class:`.FrameTagRx`.

        .. note:: The transmitted frame tag type (sequence number, time stamp, ...)
                  must match the receiver frame tag type that is used for this trigger.

        The transmitted frame tag (sequence number, timestamp) can be obtained from the
        Frame (:meth:`.Frame.FrameTagSequenceGet`, resp. :meth:`.Frame.FrameTagTimeGet`)

        :param transmittedFrameTag: The :class:`.FrameTagTx` to obtain the metrics and
                                    format configuration from.

        .. versionadded:: 1.8.18

        :raises: ByteBlower.Server.NotSupported - Unsupported Server Capability:
                 'Manage TX/RX Frame Tag placement': When a transmitted frame tag with
                 unsupported metrics and/or format is given.

        :raises: <tcl_error> - 'FrameTag is of incorrect Type':
                 When a transmitted frame tag of invalid type is given (sequence vs.
                 time)

        Example

        This example applies the transmitted time tag configuration on the receiver's
        time tag:

        .. code-block:: python
           :emphasize-lines: 3

        	frameTag = frame.FrameTagTimeGet()
            frameTag.Enable(True)
        	distributionTrigger.FrameTagSet(frameTag)


        """
        return _byteblower.LatencyDistribution_FrameTagSet(self, fromFrameTagTx)

LatencyDistribution_swigregister = _byteblower.LatencyDistribution_swigregister
LatencyDistribution_swigregister(LatencyDistribution)

class LatencyDistributionResultData(AbstractObject):
    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatencyDistributionResultData, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LatencyDistributionResultData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        return _byteblower.LatencyDistributionResultData_TimestampGet(self)

    def TimestampFirstGet(self):
        return _byteblower.LatencyDistributionResultData_TimestampFirstGet(self)

    def TimestampLastGet(self):
        return _byteblower.LatencyDistributionResultData_TimestampLastGet(self)

    def PacketCountGet(self):
        return _byteblower.LatencyDistributionResultData_PacketCountGet(self)

    def ByteCountGet(self):
        return _byteblower.LatencyDistributionResultData_ByteCountGet(self)

    def FramesizeMaximumGet(self):
        return _byteblower.LatencyDistributionResultData_FramesizeMaximumGet(self)

    def FramesizeMinimumGet(self):
        return _byteblower.LatencyDistributionResultData_FramesizeMinimumGet(self)

    def PacketCountValidGet(self):
        return _byteblower.LatencyDistributionResultData_PacketCountValidGet(self)

    def PacketCountInvalidGet(self):
        return _byteblower.LatencyDistributionResultData_PacketCountInvalidGet(self)

    def LatencyMinimumGet(self):
        return _byteblower.LatencyDistributionResultData_LatencyMinimumGet(self)

    def LatencyMaximumGet(self):
        return _byteblower.LatencyDistributionResultData_LatencyMaximumGet(self)

    def LatencyAverageGet(self):
        return _byteblower.LatencyDistributionResultData_LatencyAverageGet(self)

    def JitterGet(self):
        return _byteblower.LatencyDistributionResultData_JitterGet(self)

    def RangeMinimumGet(self):
        return _byteblower.LatencyDistributionResultData_RangeMinimumGet(self)

    def RangeMaximumGet(self):
        return _byteblower.LatencyDistributionResultData_RangeMaximumGet(self)

    def BucketWidthGet(self):
        return _byteblower.LatencyDistributionResultData_BucketWidthGet(self)

    def BucketCountGet(self):
        return _byteblower.LatencyDistributionResultData_BucketCountGet(self)

    def PacketCountBelowMinimumGet(self):
        return _byteblower.LatencyDistributionResultData_PacketCountBelowMinimumGet(self)

    def PacketCountAboveMaximumGet(self):
        return _byteblower.LatencyDistributionResultData_PacketCountAboveMaximumGet(self)

    def PacketCountBucketsGet(self):
        return _byteblower.LatencyDistributionResultData_PacketCountBucketsGet(self)

    def IntervalDurationGet(self):
        return _byteblower.LatencyDistributionResultData_IntervalDurationGet(self)
LatencyDistributionResultData_swigregister = _byteblower.LatencyDistributionResultData_swigregister
LatencyDistributionResultData_swigregister(LatencyDistributionResultData)

class LatencyDistributionResultDataList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatencyDistributionResultDataList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LatencyDistributionResultDataList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.LatencyDistributionResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.LatencyDistributionResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.LatencyDistributionResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.LatencyDistributionResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.LatencyDistributionResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.LatencyDistributionResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.LatencyDistributionResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.LatencyDistributionResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.LatencyDistributionResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.LatencyDistributionResultDataList___setitem__(self, *args)

    def pop(self):
        return _byteblower.LatencyDistributionResultDataList_pop(self)

    def append(self, x):
        return _byteblower.LatencyDistributionResultDataList_append(self, x)

    def empty(self):
        return _byteblower.LatencyDistributionResultDataList_empty(self)

    def size(self):
        return _byteblower.LatencyDistributionResultDataList_size(self)

    def swap(self, v):
        return _byteblower.LatencyDistributionResultDataList_swap(self, v)

    def begin(self):
        return _byteblower.LatencyDistributionResultDataList_begin(self)

    def end(self):
        return _byteblower.LatencyDistributionResultDataList_end(self)

    def rbegin(self):
        return _byteblower.LatencyDistributionResultDataList_rbegin(self)

    def rend(self):
        return _byteblower.LatencyDistributionResultDataList_rend(self)

    def clear(self):
        return _byteblower.LatencyDistributionResultDataList_clear(self)

    def get_allocator(self):
        return _byteblower.LatencyDistributionResultDataList_get_allocator(self)

    def pop_back(self):
        return _byteblower.LatencyDistributionResultDataList_pop_back(self)

    def erase(self, *args):
        return _byteblower.LatencyDistributionResultDataList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_LatencyDistributionResultDataList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.LatencyDistributionResultDataList_push_back(self, x)

    def front(self):
        return _byteblower.LatencyDistributionResultDataList_front(self)

    def back(self):
        return _byteblower.LatencyDistributionResultDataList_back(self)

    def assign(self, n, x):
        return _byteblower.LatencyDistributionResultDataList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.LatencyDistributionResultDataList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.LatencyDistributionResultDataList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.LatencyDistributionResultDataList_reserve(self, n)

    def capacity(self):
        return _byteblower.LatencyDistributionResultDataList_capacity(self)
    __swig_destroy__ = _byteblower.delete_LatencyDistributionResultDataList
    __del__ = lambda self: None
LatencyDistributionResultDataList_swigregister = _byteblower.LatencyDistributionResultDataList_swigregister
LatencyDistributionResultDataList_swigregister(LatencyDistributionResultDataList)

class LatencyDistributionResultHistory(AbstractRefreshableResult):
    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatencyDistributionResultHistory, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LatencyDistributionResultHistory, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        return _byteblower.LatencyDistributionResultHistory_Clear(self)

    def IntervalCompletedGet(self):
        return _byteblower.LatencyDistributionResultHistory_IntervalCompletedGet(self)

    def CumulativeCompletedGet(self):
        return _byteblower.LatencyDistributionResultHistory_CumulativeCompletedGet(self)

    def CumulativeGet(self):
        return _byteblower.LatencyDistributionResultHistory_CumulativeGet(self)

    def CumulativeGetByIndex(self, index):
        return _byteblower.LatencyDistributionResultHistory_CumulativeGetByIndex(self, index)

    def CumulativeLengthGet(self):
        return _byteblower.LatencyDistributionResultHistory_CumulativeLengthGet(self)

    def CumulativeGetByTime(self, timestamp):
        return _byteblower.LatencyDistributionResultHistory_CumulativeGetByTime(self, timestamp)

    def CumulativeLatestGet(self):
        return _byteblower.LatencyDistributionResultHistory_CumulativeLatestGet(self)

    def IntervalGet(self):
        return _byteblower.LatencyDistributionResultHistory_IntervalGet(self)

    def IntervalGetByIndex(self, index):
        return _byteblower.LatencyDistributionResultHistory_IntervalGetByIndex(self, index)

    def IntervalLengthGet(self):
        return _byteblower.LatencyDistributionResultHistory_IntervalLengthGet(self)

    def IntervalGetByTime(self, timestamp):
        return _byteblower.LatencyDistributionResultHistory_IntervalGetByTime(self, timestamp)

    def IntervalLatestGet(self):
        return _byteblower.LatencyDistributionResultHistory_IntervalLatestGet(self)

    def SamplingIntervalDurationGet(self):
        return _byteblower.LatencyDistributionResultHistory_SamplingIntervalDurationGet(self)

    def SamplingIntervalDurationSet(self, inDuration):
        return _byteblower.LatencyDistributionResultHistory_SamplingIntervalDurationSet(self, inDuration)

    def SamplingBufferLengthGet(self):
        return _byteblower.LatencyDistributionResultHistory_SamplingBufferLengthGet(self)

    def SamplingBufferLengthSet(self, inLength):
        return _byteblower.LatencyDistributionResultHistory_SamplingBufferLengthSet(self, inLength)

    def RefreshTimestampGet(self):
        return _byteblower.LatencyDistributionResultHistory_RefreshTimestampGet(self)
LatencyDistributionResultHistory_swigregister = _byteblower.LatencyDistributionResultHistory_swigregister
LatencyDistributionResultHistory_swigregister(LatencyDistributionResultHistory)

class LatencyDistributionMobile(Latency):
    """

    Receive-side packet processor which calculates distribution of latency on the
    incoming frames, matching a filter.

    This latency distribution calculation is always active and starts processing
    frames as soon as it is created. Processing continues until the packet
    processor is destructed.

    The transmit time stamp of a packet is obtained from a time tag in the frame.
    This tag is configured on the FrameTag.Tx, which can be obtained via
    :meth:.Frame.FrameTagTimeGet`.

    ..note:: The initial (empty) filter string accepts all incoming frames.
    See :meth:`FilterSet` for filtering information.

    A latency distribution object can be created via a :class:`.WirelessEndpoint`,
    using :meth:`.WirelessEndpoint.RxLatencyDistributionAdd`

    This packet processor processes frames received on the ByteBlower interface
    where its parent WirelessEndpoint is located.

    Example

    Receive all frames on "trunk-1-45" of some server, matching UDP source or
    destination port 49523.

    .. code-block:: python
       :emphasize-lines: 3

       from byteblowerll.byteblower import ByteBlower
       server = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
       wireless_endpoint = server.DeviceGet('aa-89bb54-c04')
       trigger = wireless_endpoint.RxLatencyDistributionAdd()
       # Do the rest of the test
       # ...
       result = trigger.ResultGet()
       # parse the results
       # ...
       wireless_endpoint.RxLatencyDistributionRemove(trigger)


    """

    __swig_setmethods__ = {}
    for _s in [Latency]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatencyDistributionMobile, name, value)
    __swig_getmethods__ = {}
    for _s in [Latency]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LatencyDistributionMobile, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultGet(self):
        return _byteblower.LatencyDistributionMobile_ResultGet(self)

    def ResultHistoryGet(self):
        return _byteblower.LatencyDistributionMobile_ResultHistoryGet(self)

    def BucketCountGet(self):
        return _byteblower.LatencyDistributionMobile_BucketCountGet(self)

    def BucketWidthGet(self):
        return _byteblower.LatencyDistributionMobile_BucketWidthGet(self)

    def RangeGet(self):
        """

        Returns the current configured range for the latency distribution.

        Example

        Suppose the range has been configured for [0,750ms[

        .. code-block:: python
           :emphasize-lines: 1

        	print(distributionTrigger.RangeGet())


        """
        return _byteblower.LatencyDistributionMobile_RangeGet(self)


    def RangeMinimumGet(self):
        return _byteblower.LatencyDistributionMobile_RangeMinimumGet(self)

    def RangeMaximumGet(self):
        return _byteblower.LatencyDistributionMobile_RangeMaximumGet(self)

    def RangeSet(self, rangeStartNs, rangeEndNs):
        """

        Configures the range for which the Latency Distribution will measure the latency and create a distribution.

        Default value: [0, 1s[

        .. note:: Nanosecond resolution is supported for versions 1.8.24 and beyond
                  (older versions only supported up to microsecond resolution).

        Bug

        An incorrect exception is thrown when an invalid
        range is given.

        :raises: <tcl_error> - 'LAT001': When trying to configure an invalid range.

        Example

        This will set the range from 0 to 5seconds.

        .. code-block:: python
           :emphasize-lines: 1

        	distributionTrigger.RangeSet(0, 100)


        """
        return _byteblower.LatencyDistributionMobile_RangeSet(self, rangeStartNs, rangeEndNs)


    def ResultClear(self):
        """

        Resets the counter values to zero.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	distributionTrigger.ResultClear()


        """
        return _byteblower.LatencyDistributionMobile_ResultClear(self)


    def FilterSet(self, arg2):
        return _byteblower.LatencyDistributionMobile_FilterSet(self, arg2)

    def FilterGet(self):
        """

        Returns the current installed BPF filter string.

        The filter string can be configured using :meth:`FilterSet`

        :return: The current BPF filter string

        Example

        Suppose we configured the trigger with filter string:
        where `ipv4_1` and `ipv4_2` are :class:`IPv4Configuration` objects and
        `frameSize` is the (layer2) size of the frames (without CRC!). The
        BPF filter string would then become for example:

        .. code-block:: python
           :emphasize-lines: 1

        	print(distributionTrigger.FilterGet())


        """
        return _byteblower.LatencyDistributionMobile_FilterGet(self)


    def FilterSourceAddressGet(self):
        """

        Returns the source address field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyMobileTrigger.FilterSourceAddressGet())


        """
        return _byteblower.LatencyDistributionMobile_FilterSourceAddressGet(self)


    def FilterSourceAddressSet(self, inAddress):
        """

        Sets the source address field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latencyMobileTrigger.FilterSourceAddressSet('10.8.1.2')


        """
        return _byteblower.LatencyDistributionMobile_FilterSourceAddressSet(self, inAddress)


    def FilterUdpSourcePortGet(self):
        """

        Returns the source port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyMobileTrigger.FilterUdpSourcePortGet())



        """
        return _byteblower.LatencyDistributionMobile_FilterUdpSourcePortGet(self)


    def FilterUdpSourcePortSet(self, inPort):
        """

        Sets the source port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latencyMobileTrigger.FilterUdpSourcePortSet(4096)


        """
        return _byteblower.LatencyDistributionMobile_FilterUdpSourcePortSet(self, inPort)


    def FilterUdpDestinationPortGet(self):
        """

        Returns the destination port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyMobileTrigger.FilterUdpDestinationPortGet())

        """
        return _byteblower.LatencyDistributionMobile_FilterUdpDestinationPortGet(self)


    def FilterUdpDestinationPortSet(self, inPort):
        """

        Sets the destination port field of the packet filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latencyMobileTrigger.FilterUdpDestinationPortSet(4096)



        """
        return _byteblower.LatencyDistributionMobile_FilterUdpDestinationPortSet(self, inPort)


    def DurationGet(self):
        """

        Returns the duration for which the trigger will be active.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(latencyMobileTrigger.DurationGet())

        """
        return _byteblower.LatencyDistributionMobile_DurationGet(self)


    def DurationSet(self, inDuration):
        """

        Sets the duration for which the trigger will be active.

        Configures how long the trigger will listen for incoming packets.

        Example

        Listen for 10 minutes

        .. code-block:: python
           :emphasize-lines: 1

        	latencyMobileTrigger.DurationSet(10*1000000000)

        """
        return _byteblower.LatencyDistributionMobile_DurationSet(self, inDuration)

LatencyDistributionMobile_swigregister = _byteblower.LatencyDistributionMobile_swigregister
LatencyDistributionMobile_swigregister(LatencyDistributionMobile)

class ServiceInfo(AbstractObject):
    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ServiceInfo, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ServiceInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def TypeGet(self):
        return _byteblower.ServiceInfo_TypeGet(self)

    def SeriesGet(self):
        return _byteblower.ServiceInfo_SeriesGet(self)

    def VersionGet(self):
        return _byteblower.ServiceInfo_VersionGet(self)

    def MachineIDGet(self):
        return _byteblower.ServiceInfo_MachineIDGet(self)

    def ServiceIDGet(self):
        return _byteblower.ServiceInfo_ServiceIDGet(self)
ServiceInfo_swigregister = _byteblower.ServiceInfo_swigregister
ServiceInfo_swigregister(ServiceInfo)

class PacketDump(AbstractObject):
    """

    Utility for dumping ByteBlower network traffic to a pcap file.

    A PacketDump object is created for a ByteBlower interface and can be configured
    with a BPF filter and a maximum snapshot length.

    .. versionAdded: 2.9.0

    Example

    .. code-block:: python

    	packetDump = interface.PacketDumpCreate()
        packetDump.Start('packetDump.pcap')
        while (packetDump.FileSizeGet()) < 1000000000:
            time.sleep(10)
        packetDump.Stop()


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PacketDump, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PacketDump, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ServerGet(self):
        return _byteblower.PacketDump_ServerGet(self)

    def Start(self, filename):
        """

        Start capturing packets.

        :param filename: Location of where the pcap file should be stored.

        .. note:: if the file already existsit will be overwritten.

        .. code-block:: python
           :emphasize-lines: 1

            packetDump.Start('packetDump.pcap')


        """
        return _byteblower.PacketDump_Start(self, filename)


    def Stop(self):
        """

        Stop capturing packets.

        .. code-block:: python
           :emphasize-lines: 1

            packetDump.Stop()


        """
        return _byteblower.PacketDump_Stop(self)


    def FilterGet(self):
        """

        Returns the BPF filter.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(packetDump.FilterGet())


        """
        return _byteblower.PacketDump_FilterGet(self)


    def FilterSet(self, value):
        """

        Configures a BPF filter so that only packets that match the filter will be
        captured.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            packetDump.FilterSet('udp port 4096')


        """
        return _byteblower.PacketDump_FilterSet(self, value)


    def SnapshotLengthGet(self):
        """

        Returns the maximum number of bytes that can be captured for each packet.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(packetDump.SnapshotLengthGet())


        """
        return _byteblower.PacketDump_SnapshotLengthGet(self)


    def SnapshotLengthSet(self, value):
        """

        Configure the maximum number of bytes that can be captured for each packet.

        .. code-block:: python
           :emphasize-lines: 1

            packetDump.SnapshotLengthSet(100000)


        """
        return _byteblower.PacketDump_SnapshotLengthSet(self, value)


    def FileNameGet(self):
        """

        Returns file name of the target pcap file.

        .. code-block:: python
           :emphasize-lines: 1

            print(packetDump.FileNameGet())


        """
        return _byteblower.PacketDump_FileNameGet(self)


    def FileSizeGet(self):
        """

        Returns current size of the target pcap file.


        .. code-block:: python
           :emphasize-lines: 1

            print(packetDump.FileSizeGet())


        """
        return _byteblower.PacketDump_FileSizeGet(self)

PacketDump_swigregister = _byteblower.PacketDump_swigregister
PacketDump_swigregister(PacketDump)

class ByteBlowerPort(AbstractObject):
    """

    Logical representation of a network host docked somewhere in the :term:`NUT`, 
    which can transmit or schedule network traffic, process incoming traffic and 
    run stateful network applications.  

    A ByteBlowerPort is physically connected (or 'attached') to the :term:`NUT` 
    through the physical ByteBlower interface on which it is created. See 
    :meth:`.ByteBlowerServer.PortCreate` for more information.  

    Multiple ports may be created on the same physical interface. From a network 
    view, they are just different (simulated) hosts within a shared (datalink or 
    layer 2) subnet. This means traffic to one port created on an interface is seen
    by all ports on that interface.  

    Most test scenarios start with one or more ByteBlower ports that are configured
    to do the following things:

    * become part of the network (layer2, layer3, perform DHCP, 
      join multicast groups, ...)
    * schedule network traffic streams for transmission (TX objects)
    * configure incoming packet processors (RX objects) that look for matching 
      packets and e.g. count them
    * start network applications such as HTTP servers
    * schedule network application actions (called 'schedulable objects') such an 
      HTTP client application sending out an HTTP request

    When such ports are subsequently activated, the scheduled streams and network 
    actions are performed at the configured time.  

    From that moment, relevant result data may be pulled from those streams (TX 
    statistics), incoming packet processors (RX statistics) and network 
    applications (application and session statistics).  

    Destroying a port will clean up everything that is configured on that port in a
    clean way:

    * streams, incoming packet processors and network applications are teared down,
      their results are gone
    * the port leaves all multicast groups of which it is part (but doesn't wait 
      for confirmation)
    * the port releases its DHCP lease (but doesn't wait for confirmation)


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteBlowerPort, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ByteBlowerPort, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetByteBlowerInterface(self):
        return _byteblower.ByteBlowerPort_GetByteBlowerInterface(self)

    def ServerGet(self):
        return _byteblower.ByteBlowerPort_ServerGet(self)

    def InterfaceNameGet(self):
        """

        Returns physical ByteBlower interface code.  

        Each ByteBlower port is created on a physical ByteBlower interface of a server.
        This interface determines where the port will be 'attached' to the :term:`NUT`.  

        See :meth:`.ByteBlowerServer.PortCreate` for more information and to see how
        an interface name is structured.  

        :return: String code representing the physical interface name (e.g. trunk-1-4 
                 or nontrunk-1).  
        :rtype: str

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(port.InterfaceNameGet())
        	# prints trunk-1-1


        """
        return _byteblower.ByteBlowerPort_InterfaceNameGet(self)


    def InterfaceSpeedGet(self):
        """

        Returns physical ByteBlower interface speed.  

        See :meth:`.ByteBlowerServer.PortCreate` for more information and to see how an
        interface name is structured.  

        :return: The maximum speed in bits per second a ByteBlower Interface can 
                 transmit. This does not take any VLAN overhead into account!  
        :rtype: long

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(port.InterfaceSpeedGet())
        	# prints 1000000000


        """
        return _byteblower.ByteBlowerPort_InterfaceSpeedGet(self)


    def InterfaceSwitchIdGet(self):
        return _byteblower.ByteBlowerPort_InterfaceSwitchIdGet(self)

    def MDLMaximumGet(self):
        """

        Returns the port's highest allowed Maximum Data Length (MDL) value, which is limited by the physical interface.  

        The MDL of a ByteBlower port places a limit on the size of ethernet frames that may be sent on that port. It can be modified by the user through :meth:`MDLSet`. The MDL value (in bytes) covers the whole ethernet packet, but excluding CRC, preamble and interframe gap.  

        The physical ByteBlower interface (e.g. nontrunk-1) on which a port is created places an upper bound on the allowed MDL values. Through this method, this property can be retrieved at runtime.  

        The typical value of the maximum MDL is 9014 on non-trunking interfaces and 9010 on trunking interfaces.  

        .. note:: On trunking interfaces the ByteBlower server adds a temporary VLAN automatically, to select an interface (e.g. trunk-1-10) on the ByteBlower switch. This is hidden from the user. However, it also means that from a user perspective, the maximum MDL value of the same physical interface is 4 bytes less when it's configured as a trunking interface.  

        :return: Physical upper bound for the MDL in bytes.  

        Example


        Typical values for a trunking and a non-trunking
        port.  

        .. code-block:: python
        	:emphasize-lines: 1

            print(port1.MDLMaximumGet())


        """
        return _byteblower.ByteBlowerPort_MDLMaximumGet(self)


    def MDLGet(self):
        """

        Returns the port's current Maximum Data Length (MDL), the maximum ethernet frame size that can be transmitted.  

        The MDL is the maximum size (in bytes) for any ethernet packet leaving the 
        port. It includes the ethernet header, but excludes CRC, preamble and 
        interframe gap. To calculate the maximum size of the layer 2 *payload*, 
        substract the 14 bytes of the ethernet header.   

        This payload may be a layer 3 IP packet, a layer 2.5 VLAN tag followed by such a layer 3 IP packet or anything else.  

        The MDL value defaults to 1514, which corresponds with a layer 2 payload of 1500 bytes.  

        This value is used by the protocol stack. For example, the announced TCP Maximum Segment Size (MSS) is based on this MDL value. This value also limits the number of bytes that can be placed in a Frame when calling :meth:`.Frame.BytesSet`.  

        .. note:: For ports without layer 2.5 configurations, the default MDL of 1514 will also lead to a maximum layer 3 packet size of 1500. This value is often called the Maximum Transmission Unit or MTU of an interface. When a port has a VLAN configuration however, the MTU will only be 1496 by default! Consider increasing the MDL to 1518 in such cases to simulate typical real-world behavior.  

        .. note:: On trunking interfaces the ByteBlower server adds a temporary VLAN automatically, to select an interface (e.g. trunk-1-10) on the ByteBlower switch. This is hidden from the user and has no influence on the MDL value. See ByteBlowerPort::MDLMaximumGet for more information.  

        :return: Current MDL value in bytes.  

        Example

        Typical values for a trunking and non-trunking
        port.  

        .. code-block:: python
        	:emphasize-lines: 1

            print(port1.MDLGet())


        """
        return _byteblower.ByteBlowerPort_MDLGet(self)


    def MDLSet(self, mdl):
        """

        Sets the port's Maximum Data Length (MDL), the maximum ethernet frame size that
        can be transmitted.  

        See :meth:`MDLGet` for more information.  

        :param mdl: New MDL value in bytes. Should be less then the value returned by 
                    :meth:`MDLMaximumGet`.  
        :type mdl: long

        :raises: ByteBlower.Exception.InvalidValue.Integer - When ``mdl`` is no integer.  

        :raises: TBD - When the provided value was larger than the maximum supported MDL. 
                 TODO: Decide on this exception and document (Tim, February 2015)  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	port.MDLSet('1350')
        	print(port.MDLGet())
        	# prints 1350

        """
        return _byteblower.ByteBlowerPort_MDLSet(self, mdl)


    def CapabilityListGet(self):
        """

        Returns a list of Capability objects.  

        .. versionadded:: 2.6.0  

        :return: An object representing a list of known capabilities
        :rtype: :class:`.CapabilityList`

        Example

        .. code-block:: python
           :emphasize-lines: 1
           :caption: This example shows how to query the capabilities on a ByteBlowerPort

           capability_list = port.CapabilityListGet()

           for capability in capability_list:
               print(capability.DescriptionGet())

        """
        return _byteblower.ByteBlowerPort_CapabilityListGet(self)


    def CapabilityGetByName(self, name):
        """

        Returns a Capability object by its name.  

        .. versionadded:: 2.6.0  

        :return: An object representing the requested capability
        :rtype: :class:`.Capability`

        :raises: :exc:`.ConfigError` - UnsupportedConfig error message when the     Capability is not supported  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	capability = port.CapabilityGetByName('IPv4')
        	print(capability.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_CapabilityGetByName(self, name)


    def CapabilityIsSupported(self, name):
        """

        Checks whether a capability is supported.  

        .. versionadded:: 2.6.0  

        :return: True if it is supported, False if not  
        :rtype: bool

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(port.CapabilityIsSupported('IPv4')
           # prints True

        """
        return _byteblower.ByteBlowerPort_CapabilityIsSupported(self, name)


    def Layer2EthIISet(self):
        """

        Sets the layer 2 configuration of this port.  

        .. versionadded: 2.5.0  

        Once the layer 2 configuration is set, it cannot be destroyed or overwritten.  

        :return: :class:`.EthernetConfiguration` object.  

        :raises: :exc:`.ConfigError` - When the layer 2 configuration is already set.  

        Example

        Configure `port`'s network connection as an Ethernet interface and add MAC address.  

        .. code-block:: python
        	:emphasize-lines: 1

        	port.Layer2EthIISet().MacSet('00bb1b000001')


        """
        return _byteblower.ByteBlowerPort_Layer2EthIISet(self)


    def Layer2EthIIGet(self):
        """

        Returns the layer 2 configuration object of this port.  

        .. versionadded:: 2.5.0  

        :return: The ethernet configuration of the ByteBlower port
        :rtype: :class:`.EthernetConfiguration`

        :raises: :exc:`.ConfigError` - When the layer 2 configuration is not yet set.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	eth_conf = port.Layer2EthIIGet()



        """
        return _byteblower.ByteBlowerPort_Layer2EthIIGet(self)


    def Layer25VlanAdd(self):
        """

        Adds a layer 2.5 VLAN to this port.  

        .. versionchanged:: 2.5.0  
           Multiple layer 2.5 configurations can be added. They will be stacked on top 
           each other in the the port's network stack from the bottom up.  

        Once a layer 2.5 configuration is added to a port, it cannot be destroyed or 
        removed.  

        .. versionchanged:: 2.3.0
           Support for stacking multiple VLAN tags. Adding a second VLAN tag on an 
           older server will throw a technical exception.  

        :return: Created VLAN configuration object.  
        :rtype: :class:`VlanTag`

        :raises: :exc:`.ConfigError` - When an underlying layer 2 or layer 2.5
                 configuration is not yet fully configured.  

        Example

        Configure `port`'s network connection as a VLAN-enabled virtual interface.  

        .. code-block:: python
           :emphasize-lines: 1

           vlan_tag = port.Layer25VlanAdd()
           vlan_tag.IDSet(20)


        """
        return _byteblower.ByteBlowerPort_Layer25VlanAdd(self)


    def Layer25VlanGet(self):
        """

        Returns the ordered list of layer 2.5 Vlan objects of this port.  

        .. versionadded:: 2.5.0  
           VLAN  objects can be added by :meth:`Layer25VlanAdd`.

        :return: :class:`.Layer25VlanList`

        Example
        Reading the number of VlanTag` objects of `port`
        Configure `port`'s network connection as a VLAN-enabled virtual interface.  
        .. code-block:: python
        	:emphasize-lines: 1

            vlan_list = port.Layer25VlanGet()


        """
        return _byteblower.ByteBlowerPort_Layer25VlanGet(self)


    def Layer25VlanRemove(self, inVlanTag):
        return _byteblower.ByteBlowerPort_Layer25VlanRemove(self, inVlanTag)

    def Layer25PPPoEAdd(self):
        """

        Adds a layer 2.5 PPPoE Client to this port.  

        .. versionadded:: 2.5.0  

        Once a layer 2.5 configuration is added to a port, it cannot be destroyed or
        removed.  

        :return: an object representing an PPPoE client
        :rtype: :class:`.PPPoEClient`

        :raises: :exc:`.ConfigError` - When an underlying layer 2 or layer 2.5 
                 configuration is not yet fully configured.  

        Example

        Configure `port`'s network connection as a PPPoE-enabled virtual interface.  

        .. code-block:: python
        	:emphasize-lines: 1

        	# set an PPPoE client
        	client = port.Layer25PPPoEAdd()
        	print(client.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_Layer25PPPoEAdd(self)


    def Layer25PPPoEGet(self):
        """

        Returns the ordered list of layer 2.5 PPPoE objects of this port.  

        .. versionadded:: 2.5.0  
           PPPoE objects can be added by :meth:`.ByteBlowerPort.Layer25PPPoEAdd`

        :return: A list with all the PPPoE clients created
        :rtype: :class:`.Layer25PPPoEList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	layer25PPPoEGet = port.Layer25PPPoEGet()


        """
        return _byteblower.ByteBlowerPort_Layer25PPPoEGet(self)


    def Layer25PPPoERemove(self, inPPPoEClient):
        return _byteblower.ByteBlowerPort_Layer25PPPoERemove(self, inPPPoEClient)

    def Layer3IPv4Set(self):
        """

        Sets the layer 3 IPv4 configuration of this port.  

        .. versionadded:: 2.5.0  

        Once a layer 3 configuration is set, it cannot be destroyed or overwritten.  

        Both IPv4 and IPv6 are supported. Dual stack is not available on a single port,
        but can be achieved by creating 2 separate ports with identical layer 2 and 
        (possibly) layer 2.5 configurations.  

        :return: an object representing the IPv4 configuration for the ByteBlower port
        :rtype: :class:`.IPv4Configuration`

        :raises: :exc:`.ConfigError` - When an underlying layer 2 or layer 2.5 
                 configuration is not yet fully configured.  
        :raises: :exc:`.ConfigError` - When the layer 3 configuration is already set.  

        Example

        Configure `port`'s network connection as an IPv4 host.  

        .. code-block:: python
        	:emphasize-lines: 1

        	ipv4_config = port.Layer3IPv4Set()

        """
        return _byteblower.ByteBlowerPort_Layer3IPv4Set(self)


    def Layer3IPv4Get(self):
        """

        Returns the layer 3 IPv4 configuration object of this port.  

        .. versionadded:: 2.5.0  

        :return: A created IPv4 configuration object
        :rtype: :class:`.IPv4Configuration`.  

        :raises: :exc:`.ConfigError` - When the layer 3 configuration is not yet set.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	ipv4_config = port.Layer3IPv4Get()
        	print(ipv4_config.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_Layer3IPv4Get(self)


    def Layer3IPv6Set(self):
        """

        Sets the layer 3 IPv6 configuration of this port.  

        .. versionadded:: 2.5.0  

        Once a layer 3 configuration isM set, it cannot be destroyed or overwritten.  

        Both IPv4 and IPv6 are supported. Dual stack is not available on a single port, but can be achieved by creating 2 separate ports with identical layer 2 and (possibly) layer 2.5
        configurations.  

        :return: :class:`.IPv6Configuration`

        :raises: :exc:`.ConfigError` - When an underlying layer 2 or layer 2.5 configuration is not yet fully configured.  
        :raises: :exc:`.ConfigError` - When the layer 3 configuration is already set.  

        Example

        Configure `port`'s network connection as an IPv6 host.  

        .. code-block:: python	
        	:emphasize-lines: 1

            bbPort1_l3 = port1.Layer3IPv6Set().IpManualAdd('3000:3128::24/64')


        """
        return _byteblower.ByteBlowerPort_Layer3IPv6Set(self)


    def Layer3IPv6Get(self):
        """

        Returns the layer 3 IPv6 configuration object of this port.  

        .. versionadded:: 2.5.0  

        :return: An object with the IPv6 configuration of the ByteBlower Port
        :rtype: :class:`.IPv6Configuration`

        :raises: :exc:`.ConfigError` - When the layer 3 configuration is not yet set.

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	l3_config = port.Layer3IPv6Get()



        """
        return _byteblower.ByteBlowerPort_Layer3IPv6Get(self)


    def ProtocolHttpServerAdd(self):
        """

        Creates a HTTP server application to run on this port.  

        An :class:`.HttpServer` application is a customized HTTP server that is typically used to emulate a TCP connection.  

        It listens for special HTTP requests (sent by :class:`.HttpClient` 
        applications) and responds in the desired way. For example, an HTTP request may
        ask (GET) for a response of a specified size and the HTTP server will emulate 
        sending such a file back.  

        :return: an object representing an HTTP Server object.
        :rtype: :class:`.HttpServer`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	http_server = port.ProtocolHttpServerAdd()


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpServerAdd(self)


    def ProtocolHttpServerGet(self):
        """

        Returns the list of all HTTP server applications created on this port.  

        See :meth:`ProtocolHttpServerAdd` for more information.  

        :return: class:`.HttpServerList`  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(port.ProtocolHttpServerGet())




        """
        return _byteblower.ByteBlowerPort_ProtocolHttpServerGet(self)


    def ProtocolHttpServerRemove(self, arg2):
        return _byteblower.ByteBlowerPort_ProtocolHttpServerRemove(self, arg2)

    def ProtocolHttpClientAdd(self):
        """

        Creates a HTTP client application to run on this port.  

        A ::class:`HttpMultiServer` application can initiate customized HTTP sessions that are typically used to emulate a TCP connection.  

        It allows configuring the special HTTP requests to which a running :class:`.HttpServer` application responds. For example, an HTTP client can ask (GET) for a response of a specified size or time or may send (PUT) a payload of a specified size or time itself.  

        Besides constructing such special HTTP requests, the HTTP client can interact with any normal webserver by configuring its URL.  

        :return: ::class:`HttpMultiServer`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	httpClient = port.ProtocolHttpClientAdd()



        """
        return _byteblower.ByteBlowerPort_ProtocolHttpClientAdd(self)


    def ProtocolHttpClientGet(self):
        """

        Returns the list of all HTTP client applications created on this port.  

        See :meth:`ProtocolHttpClientAdd` for more information.  

        :return: returns a list of created :class:`.HtppClient` objects
        :rtype: :class:`.HttpClientList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	all_clients = port.ProtocolHttpClientGet()
        	print(all_clients.size())


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpClientGet(self)


    def ProtocolHttpClientRemove(self, arg2):
        return _byteblower.ByteBlowerPort_ProtocolHttpClientRemove(self, arg2)

    def ProtocolHttpMultiServerAdd(self):
        """

        Creates a :class:`HttpMultiServer` object on this port.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	# create the HTTP client
        	httpServer = port.ProtocolHttpMultiServerAdd()



        """
        return _byteblower.ByteBlowerPort_ProtocolHttpMultiServerAdd(self)


    def ProtocolHttpMultiServerGet(self):
        """

        Returns the list of :class:`HttpMultiServer` objects on this port.  

        :return: :class:`HttpMultiServerList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(port.ProtocolHttpMultiServerGet())


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpMultiServerGet(self)


    def ProtocolHttpMultiServerRemove(self, arg2):
        return _byteblower.ByteBlowerPort_ProtocolHttpMultiServerRemove(self, arg2)

    def ProtocolHttpMultiClientAdd(self):
        """

        Creates a Layer5.Http.MultiClient object on this port.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	httpClient = port.ProtocolHttpMultiClientAdd()



        """
        return _byteblower.ByteBlowerPort_ProtocolHttpMultiClientAdd(self)


    def ProtocolHttpMultiClientGet(self):
        """

        Returns the list of a :class:`.HttpMultiClient` objects on this port.  

        :return: :class:`.HttpMultiClientList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(port.ProtocolHttpMultiClientGet())


        """
        return _byteblower.ByteBlowerPort_ProtocolHttpMultiClientGet(self)


    def ProtocolHttpMultiClientRemove(self, arg2):
        return _byteblower.ByteBlowerPort_ProtocolHttpMultiClientRemove(self, arg2)

    def TunnelTcpAdd(self):
        """

        Creates a TCP tunnel object.  

        A :class:`.TcpTunnel` can be used to configure TCP port forwarding between the
        user's office network and the lab network.  

        Through the protocol, a client can requesting dynamic changes to the firewall 
        or NAT port forwarding settings of a (PCP-enabled) gateway.  

        :return: The created TcpTunnel object.  This object can be used to configure 
                 the tunnel
        :rtype: :class:`.TcpTunnel`  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	tunnel = port.TunnelTcpAdd()
        	print(tunnel.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_TunnelTcpAdd(self)


    def TunnelTcpGet(self):
        """

        Returns a list of all TCP Tunnel objects created on this port.  

        See :meth:`TunnelTcpAdd` for more information.  

        :return: :class:`.TcpTunnelList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	tunnelTcp = port.TunnelTcpGet()


        """
        return _byteblower.ByteBlowerPort_TunnelTcpGet(self)


    def TunnelTcpRemove(self, arg2):
        return _byteblower.ByteBlowerPort_TunnelTcpRemove(self, arg2)

    def ProtocolTelnetClientAdd(self):
        """

        Creates a Telnet client application to run on this port.  

        .. versionadded:: API 2.2.0  

        A :class:`.TelnetClient` application can contact and interact with an external Telnet server.  

        Apart from simulating such scenarios for its own sake, this application can be used to contact important nodes within the :term:`NUT` (e.g. a router) and retrieve relevant statistics from it.  

        :return: :class:`.TelnetClient`.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	protocolTelnetClient = port.ProtocolTelnetClientAdd()


        """
        return _byteblower.ByteBlowerPort_ProtocolTelnetClientAdd(self)


    def ProtocolTelnetClientGet(self):
        """

        Returns the list of all Telnet client applications created on this port.  

        .. versionadded:: API 2.2.0  

        See :meth:`ProtocolTelnetClientAdd` for more information.  

        :return: :class:`.TelnetClientList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	protocolTelnetClient = port.ProtocolTelnetClientGet()


        """
        return _byteblower.ByteBlowerPort_ProtocolTelnetClientGet(self)


    def ProtocolTelnetClientRemove(self, arg2):
        return _byteblower.ByteBlowerPort_ProtocolTelnetClientRemove(self, arg2)

    def TxStreamAdd(self):
        """

        Creates a transmit stream, which can be configured to blast layer 2 frames traffic from this port in a stateless way.  

        Initially, a stream does not contain any traffic. It must still be configured 
        by adding content (in the form of Frame objects) and timing information 
        (especially the interframe gap).

        A :class:`.Stream` can be compared to the transmitting part of a frame blasting
        flow in the GUI.  

        :return: an object representing a pure frame blasting stream.
        :rtype: :class:`.Stream`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	stream = port.TxStreamAdd()


        """
        return _byteblower.ByteBlowerPort_TxStreamAdd(self)


    def TxStreamRemove(self, inStream):
        return _byteblower.ByteBlowerPort_TxStreamRemove(self, inStream)

    def TxStreamGet(self):
        """

        Returns a list of transmit streams created on this port.  

        :return: A list with all created :class:`.Stream` objects
        :rtype: :class:`.StreamList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	streams = port.TxStreamGet()
        	print(streams.size())
        	# prints 1


        """
        return _byteblower.ByteBlowerPort_TxStreamGet(self)


    def RxTriggerBasicAdd(self):
        """

        Creates a basic receive trigger, whose counters are updated for each received frame (possibly restricted by a filter).  

        .. versionadded:: 2.5.0  

        Like all incoming packet processors (or 'Rx' objects), this object listens to 
        incoming traffic matching a configurable BPF filter and performs some action 
        when it arrives.  

        The receive trigger is activated as soon as it is created, so don't forget to 
        reset its counters after setting the filter and initializing your test.  

        See the class documentation of the returned types for more information.  

        :return: A basic trigger object, which allows to configure the trigger and 
                 getting the results
        :rtype: :class:`TriggerBasic`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	trigger = port.RxTriggerBasciAdd()

        """
        return _byteblower.ByteBlowerPort_RxTriggerBasicAdd(self)


    def RxTriggerBasicGet(self):
        """

        Returns the list of receive triggers created on this port.  

        .. versionadded:: 2.5.0  

        See :meth:`RxTriggerBasicAdd` for more information.  

        :return: an object representing a list of create basic triggers
        :rtype: :class:`.TriggerBasicList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	all_triggers = port.RxTriggerBasicGet()
        	print(all_triggers.size())
        	# prints 1  

        """
        return _byteblower.ByteBlowerPort_RxTriggerBasicGet(self)


    def RxTriggerBasicRemove(self, arg2):
        return _byteblower.ByteBlowerPort_RxTriggerBasicRemove(self, arg2)

    def RxTriggerSizeDistributionAdd(self):
        """

        Creates a size distribution receive trigger, whose counters are updated for each received frame (possibly restricted by a filter).  

        .. versionadded:: 2.5.0  

        Like all incoming packet processors (or 'Rx' objects), this object listens to incoming traffic matching a configurable BPF filter and performs some action when it arrives.  

        The receive trigger is activated as soon as it is created, so don't forget to reset its counters after setting the filter and initializing your test.  

        See the class documentation of the returned types for more information.  

        :return: :class:`.TriggerSizeDistribution`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	trigger = port.RxTriggerSizeDistributionAdd()



        """
        return _byteblower.ByteBlowerPort_RxTriggerSizeDistributionAdd(self)


    def RxTriggerSizeDistributionGet(self):
        """

        Returns the list of receive triggers created on this port.  

        .. versionadded:: 2.5.0  

        See :meth:`RxTriggerSizeDistributionAdd` for more information.  

        :return: A list with all the sizedistribution triggers created
        :rtype: :class:`.TriggerSizeDistributionList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	all_size_dists = port.RxTriggerSizeDistributionGet()
        	print(all_size_dists.size())
        	# prints 1


        """
        return _byteblower.ByteBlowerPort_RxTriggerSizeDistributionGet(self)


    def RxTriggerSizeDistributionRemove(self, arg2):
        return _byteblower.ByteBlowerPort_RxTriggerSizeDistributionRemove(self, arg2)

    def RxLatencyBasicAdd(self):
        """

        Creates a latency calculator, which computes latency measurements based on timestamps in received frames (possibly restricted by a filter).  

        .. versionadded:: 2.5.0  

        Like all incoming packet processors (or 'Rx' objects), this object listens to incoming traffic matching a configurable BPF filter and performs some action when it arrives.  

        Typically, the filter should limit the matching traffic to the Tx.Stream whose transmitted frames actually contain the required timestamps!  

        The latency calculator is activated as soon as it is created, so don't forget to reset its counters after setting the filter and initializing your test.  

        See :class:`.Frame` for information on timestamping.  

        :return: :class:`.LatencyBasic`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	latency = port.RxLatencyBasicAdd()



        """
        return _byteblower.ByteBlowerPort_RxLatencyBasicAdd(self)


    def RxLatencyBasicRemove(self, inLatency):
        return _byteblower.ByteBlowerPort_RxLatencyBasicRemove(self, inLatency)

    def RxLatencyBasicGet(self):
        """

        Returns the list of latency calculators created on this port.  

        .. versionadded:: 2.5.0  

        See :meth:`LatencyBasicAdd` for more information.  

        :return: :class:`.LatencyBasicList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	all_latency = port.RxLatencyBasicGet()
        	print(all_latency.size())
        	# prints 1


        """
        return _byteblower.ByteBlowerPort_RxLatencyBasicGet(self)


    def RxLatencyDistributionAdd(self):
        """

        Creates a latency calculator, which computes latency measurements based on timestamps in received frames (possibly restricted by a filter).  

        .. versionadded:: 2.5.0  

        Like all incoming packet processors (or 'Rx' objects), this object listens to incoming traffic matching a configurable BPF filter and performs some action when it arrives.  

        Typically, the filter should limit the matching traffic to the Tx.Stream whose transmitted frames actually contain the required timestamps!  

        The latency calculator is activated as soon as it is created, so don't forget to reset its counters after setting the filter and initializing your test.  

        See :class:`.Frame` for information on timestamping.  

        :return: :class:`.LatencyDistribution`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

           distribution = port.RxLatencyDistributionAdd()


        """
        return _byteblower.ByteBlowerPort_RxLatencyDistributionAdd(self)


    def RxLatencyDistributionRemove(self, inLatency):
        return _byteblower.ByteBlowerPort_RxLatencyDistributionRemove(self, inLatency)

    def RxLatencyDistributionGet(self):
        """

        Returns the list of latency calculators created on this port.  

        .. versionadded:: 2.5.0  

        See :meth:`.LatencyDistributionAdd` for more information.  

        :return: :class:`.LatencyDistributionList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	all_latency = port.RxLatencyDistributionGet()




        """
        return _byteblower.ByteBlowerPort_RxLatencyDistributionGet(self)


    def RxOutOfSequenceBasicAdd(self):
        """

        Creates an out-of-sequence detector, which counts such cases based on sequence numbers in received frames (possibly restricted by a filter).

        .. versionadded:: 2.5.0  

        Like all incoming packet processors (or 'Rx' objects), this object listens to 
        incoming traffic matching a configurable BPF filter and performs some action 
        when it arrives.  

        Typically, the filter should limit the matching traffic to the :class:`.Stream`
        whose transmitted frames actually contain the required sequence numbers!   

        The out-of-sequence detector is activated as soon as it is created, so don't 
        forget to reset its counters after setting the filter and initializing your 
        test.

        :return: Created out-of-sequence detector object.
        :rtype: :class:`.OutOfSequence`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           out_of_sequence = port.RxOutOfsequenceBasicAdd()
           # lets assume traffic is sent to UDP port 9000
           out_of_sequence.FilterSet('ip && dst port 9000')
           print(out_of_sequence.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_RxOutOfSequenceBasicAdd(self)


    def RxOutOfSequenceBasicRemove(self, inOutOfSequence):
        return _byteblower.ByteBlowerPort_RxOutOfSequenceBasicRemove(self, inOutOfSequence)

    def RxOutOfSequenceBasicGet(self):
        """

        Returns the list of out-of-sequence detectors created on this port.  

        .. versionadded:: 2.5.0  

        See :meth:`OutOfSequenceBasicAdd` for more information.  

        :return: A list of created objects
        :rtype: :class:`.OutOfSequenceList`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           all_oos = port.RxOutOfSequenceBasicGet()
           print(all_oos.size())
           # prints 1


        """
        return _byteblower.ByteBlowerPort_RxOutOfSequenceBasicGet(self)


    def Start(self):
        """

        Starts all transmit streams and schedulable objects configured on this port.  

        See :meth:`.ByteBlower.PortsStart`, which does the same for a set of ports, for
        more information.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	port.Start()



        """
        return _byteblower.ByteBlowerPort_Start(self)


    def Stop(self):
        return _byteblower.ByteBlowerPort_Stop(self)

    def ResultGet(self):
        """

        Returns the result object.  

        :return: A result object which contains the packet count, byte count etc for 
                 this ByteBlower port. 
        :rtype: :class:`.ByteBlowerPortResultSnapshot`


        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	result = port.ResultGet()
        	print(result.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_ResultGet(self)


    def ResultHistoryGet(self):
        """

        Returns the history for the counters for the ByteBlower port.  

        :return: :class:`.ByteBlowerPortResultHistory`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	historyResult = port.ResultHistoryGet()
        	print(historyResult.DescriptionGet())


        """
        return _byteblower.ByteBlowerPort_ResultHistoryGet(self)


    def ResultClear(self):
        """

        Clears the counters for the ByteBlower port and empties the :class:`.ByteBlowerPortResultHistory`.  

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	port.ResultClear()


        """
        return _byteblower.ByteBlowerPort_ResultClear(self)


    def RxCaptureBasicAdd(self):
        """

        Creates a capture tool, which captures the data and metadata of incoming frames (possibly restricted by a filter).  

        .. versionadded:: 2.5.0  

        Like all incoming packet processors (or 'Rx' objects), this object listens to 
        incoming traffic matching a configurable BPF filter and performs some action 
        when it arrives.  

        Typically, the filter should limit the matching packets to the interesting 
        traffic, especially since capturing all incoming bytes at high rates may place
        a heavy load on the server.  

        .. note:: Unlike other Rx objects, the capture tool is not activated as soon as
           it is created.  See the class documentation of the returned types for more 
           information.  

        .. warning:: Using this tool requires a lot of system resources. Try to avoid 
           capturing at high rates or for a long time. Set the capture filter as strict
           as possible to avoid unwanted traffic. When too much incoming traffic must 
           be processed, the ByteBlower server may become unstable.  

        .. note:: It is also possible to log in to the server and capture there. Note
           that when capturing a trunking interface (i.e. connected to a switch) you 
           will see an extra VLAN tag that shows to or from which interface the traffic
           goes. This is currently *only* possible on the 1x00 series, where the
           Linux `tcpdump` tool can sniff the server's (native) data interfaces.  

        .. note:: This functionality is also available with a stand-alone command-line
           tool. It can be found and downloaded on our support portal.  

        The returned capture tool is a basic capture tool stores both the frame data 
        and some metadata.  

        :return: An object representing the servers implementation of the capture
                 functionality
        :rtype: :class:`CaptureRawPacket`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	captureTool = port.RxCaptureBasicAdd()
            captureTool.Start()


        """
        return _byteblower.ByteBlowerPort_RxCaptureBasicAdd(self)


    def RxCaptureBasicRemove(self, inCapture):
        return _byteblower.ByteBlowerPort_RxCaptureBasicRemove(self, inCapture)

    def RxCaptureBasicGet(self):
        """

        Returns the list of capture tools created on this port.  

        .. versionadded::: 2.5.0  

        See :meth:`RxCaptureBasicAdd` for more information.  

        :return: :class:`.CaptureRawPacketList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	tools = port.RxCaptureBasicGet()


        """
        return _byteblower.ByteBlowerPort_RxCaptureBasicGet(self)

ByteBlowerPort_swigregister = _byteblower.ByteBlowerPort_swigregister
ByteBlowerPort_swigregister(ByteBlowerPort)

class ByteBlowerPortResultRxData(AbstractObject):
    """

    ByteBlower port counter result set.

    A ByteBlower port result data snapshot object can be created via a
    :class:`.ByteBlowerPortResultData` or :class:`.ByteBlowerPortResultSnapshot`

    .. note:: See What's new in API v2 for more information.

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.

    .. code-block:: python
       :emphasize-lines: 1

        rx_result=port_result.RxAllGet()


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteBlowerPortResultRxData, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ByteBlowerPortResultRxData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    CounterType_RxBroadcast = _byteblower.ByteBlowerPortResultRxData_CounterType_RxBroadcast
    CounterType_RxUnicast = _byteblower.ByteBlowerPortResultRxData_CounterType_RxUnicast
    CounterType_RxAll = _byteblower.ByteBlowerPortResultRxData_CounterType_RxAll

    def TimestampFirstGet(self):
        """

        Gets the timestamp [NS] of the first packet in this snapshot.

        :raises: CounterUnavailable - When no frames are  received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the first received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.TimestampFirstGet())

        """
        return _byteblower.ByteBlowerPortResultRxData_TimestampFirstGet(self)


    def TimestampLastGet(self):
        """

        Gets the current timestamp [NS] of the last packet in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the timestamp [NS] of the last received packet in this
        snapshot

        .. code-block:: python
           :emphasize-lines: 1

        	print(rx_result.TimestampLastGet())

        """
        return _byteblower.ByteBlowerPortResultRxData_TimestampLastGet(self)


    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.TimestampGet()) 

        """
        return _byteblower.ByteBlowerPortResultRxData_TimestampGet(self)


    def PacketCountGet(self):
        """

        Gets the received packet count.

        Example

        This example gets the received packet counter

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.PacketCountGet())

        """
        return _byteblower.ByteBlowerPortResultRxData_PacketCountGet(self)


    def ByteCountGet(self):
        """

        Gets the current received bytes counter.

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.ByteCountGet())

        """
        return _byteblower.ByteBlowerPortResultRxData_ByteCountGet(self)


    def ByteCountWithCRCGet(self):
        """

        Gets the current received bytes counter with the CRC.

        Example

        This example gets the received bytes counter

        .. code-block:: python
           :emphasize-lines: 1

        	print(rx_result.ByteCountWithCRCGet())

        """
        return _byteblower.ByteBlowerPortResultRxData_ByteCountWithCRCGet(self)


    def FramesizeMinimumGet(self):
        """

        Gets the smallest frame size received in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                 unavailable

        Example

        This example gets the smallest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.FramesizeMinimumGet())

        """
        return _byteblower.ByteBlowerPortResultRxData_FramesizeMinimumGet(self)


    def FramesizeMaximumGet(self):
        """

        Gets the largest frame size received in this snapshot.

        :raises: CounterUnavailable - When no frames are received, this counter is
                                      unavailable

        Example

        This example gets the largest frame size received in this snapshot.

        .. code-block:: python
           :emphasize-lines: 1

           print(rx_result.FramesizeMaximumGet())

        """
        return _byteblower.ByteBlowerPortResultRxData_FramesizeMaximumGet(self)


    def IntervalDurationGet(self):
        return _byteblower.ByteBlowerPortResultRxData_IntervalDurationGet(self)
ByteBlowerPortResultRxData_swigregister = _byteblower.ByteBlowerPortResultRxData_swigregister
ByteBlowerPortResultRxData_swigregister(ByteBlowerPortResultRxData)


def ConvertCounterType(inType):
    return _byteblower.ConvertCounterType(inType)
ConvertCounterType = _byteblower.ConvertCounterType
class ByteBlowerPortResultData(AbstractObject):
    """

    ByteBlower port counter result set.

    The result set contains three different counters:

    - a Unicast counter, which counts all received unicast Ethernet frames.
    - a Broadcast counter, which counts all received broadcast Ethernet frames.
    - an All counter, which counts all received Ethernet frames.

    .. note:: The 'all' counter can be seen as the combination of the unicast and
              the broadcast counter.

    .. note:: See What's new in API v2 for more information.

    A ByteBlower port result data snapshot object can be created via a
    :class:`.ByteBlowerPortResultData` or ByteBlowerPort.ResultSnapshot

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.

    .. code-block:: python
       :emphasize-lines: 2

    	result = port.ResultHistoryGet()
        resultData = result.CumulativeLatestGet()


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteBlowerPortResultData, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ByteBlowerPortResultData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def RxUnicastGet(self):
        """

        Gets the received unicast counters for the port.

        This will return a :class:`.ByteBlowerPortResultRxData` object which contain all
        unicast counters from a port. This will only contain the broadcast unicast
        received on the port.

        :return: :class:`.ByteBlowerPortResultRxData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.RxUnicastGet().DescriptionGet())


        """
        return _byteblower.ByteBlowerPortResultData_RxUnicastGet(self)


    def RxBroadcastGet(self):
        """

        Gets the received broadcast counters for the port.

        This will return a :class:`.ByteBlowerPortResultRxData` object which contain
        all counters from a port. This will only contain the broadcast packets
        received on the port.

        :return: :class:`.ByteBlowerPortResultRxData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultData.RxBroadcastGet().DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultData_RxBroadcastGet(self)


    def RxAllGet(self):
        """

        Gets the received counters for the port.

        This will return a :class:`.ByteBlowerPortResultRxData` object which contain
        all counters from a port

        :return: :class:`.ByteBlowerPortResultRxData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(resultData.RxAllGet().DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultData_RxAllGet(self)


    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.TimestampGet())


        """
        return _byteblower.ByteBlowerPortResultData_TimestampGet(self)


    def IntervalDurationGet(self):
        """

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

            print(resultData.IntervalDurationGet())


        """
        return _byteblower.ByteBlowerPortResultData_IntervalDurationGet(self)

ByteBlowerPortResultData_swigregister = _byteblower.ByteBlowerPortResultData_swigregister
ByteBlowerPortResultData_swigregister(ByteBlowerPortResultData)

class ByteBlowerPortResultSnapshot(AbstractRefreshableResult):
    """

    ByteBlower port counter result set.

    The result set contains three different counters:

    - a Unicast counter, which counts all received unicast Ethernet frames.
    - a Broadcast counter, which counts all received broadcast Ethernet frames.
    - an All counter, which counts all received Ethernet frames.

    .. note:: The "all" counter can be seen as the combination of the unicast
              and the broadcast counter.

    .. note:: See What's new in API v2 for more information.

    A ByteBlower port result data snapshot object can be created via a
    :class:`.ByteBlowerPortResultData` or :class:`.ByteBlowerPortResultSnapshot`

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.

    .. code-block:: python
       :emphasize-lines: 1

       port_result = port.ResultGet()

    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteBlowerPortResultSnapshot, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ByteBlowerPortResultSnapshot, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        return _byteblower.ByteBlowerPortResultSnapshot_Clear(self)

    def RxUnicastGet(self):
        """

        Gets the received unicast counters for the port. This will return a
        :class:`.ByteBlowerPortResultRxData` object which contain all unicast counters
        from a port. This will only contain the broadcast unicast received on the port.

        :return: :class:`.ByteBlowerPortResultRxData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(port_result.RxUnicastGet.DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultSnapshot_RxUnicastGet(self)


    def RxBroadcastGet(self):
        """

        Gets the received broadcast counters for the port. This will return a
        :class:`.ByteBlowerPortResultRxData` object which contain all counters from a
        port. This will only contain the broadcast packets received on the port.

        :return: :class:`.ByteBlowerPortResultRxData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(port_result.RxBroadcastGet.DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultSnapshot_RxBroadcastGet(self)


    def RxAllGet(self):
        """

        Gets the received counters for the port. This will return a
        :class:`.ByteBlowerPortResultRxData` object which contain all counters from a
        port.

        :return: :class:`.ByteBlowerPortResultRxData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(port_result.RxAllGet.DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultSnapshot_RxAllGet(self)


    def TimestampGet(self):
        """

        Gets the snapshot timestamp [NS].

        Example

        This example gets the snapshot timestamp [NS].

        .. code-block:: python
           :emphasize-lines: 1

            print(port_result.TimestampGet())

        """
        return _byteblower.ByteBlowerPortResultSnapshot_TimestampGet(self)


    def IntervalDurationGet(self):
        """

        Gets the *configured* duration of this results snapshot [NS].

        .. versionadded:: 2.3.0

        Example

        This example gets interval duration of this result snapshot [NS]

        .. code-block:: python
           :emphasize-lines: 1

        	print(port_result.IntervalDurationGet())

        """
        return _byteblower.ByteBlowerPortResultSnapshot_IntervalDurationGet(self)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp on the server when the current snapshot is requested.

        When the snapshot is part of a history, the refresh timestamp will be the same
        as refresh timestamp of the History object.

        ..note:: This is not the same as :meth:`TimestampGet`

        :return: Timestamp on the server when the current snapshot is requested in
                 nanoseconds since epoch

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(port_result.RefreshTimestampGet())

        """
        return _byteblower.ByteBlowerPortResultSnapshot_RefreshTimestampGet(self)


    def RefreshImpl(self):
        return _byteblower.ByteBlowerPortResultSnapshot_RefreshImpl(self)
ByteBlowerPortResultSnapshot_swigregister = _byteblower.ByteBlowerPortResultSnapshot_swigregister
ByteBlowerPortResultSnapshot_swigregister(ByteBlowerPortResultSnapshot)

class ByteBlowerPortResultDataList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteBlowerPortResultDataList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ByteBlowerPortResultDataList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ByteBlowerPortResultDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ByteBlowerPortResultDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ByteBlowerPortResultDataList___bool__(self)

    def __len__(self):
        return _byteblower.ByteBlowerPortResultDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ByteBlowerPortResultDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ByteBlowerPortResultDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ByteBlowerPortResultDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ByteBlowerPortResultDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ByteBlowerPortResultDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ByteBlowerPortResultDataList___setitem__(self, *args)

    def pop(self):
        return _byteblower.ByteBlowerPortResultDataList_pop(self)

    def append(self, x):
        return _byteblower.ByteBlowerPortResultDataList_append(self, x)

    def empty(self):
        return _byteblower.ByteBlowerPortResultDataList_empty(self)

    def size(self):
        return _byteblower.ByteBlowerPortResultDataList_size(self)

    def swap(self, v):
        return _byteblower.ByteBlowerPortResultDataList_swap(self, v)

    def begin(self):
        return _byteblower.ByteBlowerPortResultDataList_begin(self)

    def end(self):
        return _byteblower.ByteBlowerPortResultDataList_end(self)

    def rbegin(self):
        return _byteblower.ByteBlowerPortResultDataList_rbegin(self)

    def rend(self):
        return _byteblower.ByteBlowerPortResultDataList_rend(self)

    def clear(self):
        return _byteblower.ByteBlowerPortResultDataList_clear(self)

    def get_allocator(self):
        return _byteblower.ByteBlowerPortResultDataList_get_allocator(self)

    def pop_back(self):
        return _byteblower.ByteBlowerPortResultDataList_pop_back(self)

    def erase(self, *args):
        return _byteblower.ByteBlowerPortResultDataList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_ByteBlowerPortResultDataList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.ByteBlowerPortResultDataList_push_back(self, x)

    def front(self):
        return _byteblower.ByteBlowerPortResultDataList_front(self)

    def back(self):
        return _byteblower.ByteBlowerPortResultDataList_back(self)

    def assign(self, n, x):
        return _byteblower.ByteBlowerPortResultDataList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.ByteBlowerPortResultDataList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.ByteBlowerPortResultDataList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.ByteBlowerPortResultDataList_reserve(self, n)

    def capacity(self):
        return _byteblower.ByteBlowerPortResultDataList_capacity(self)
    __swig_destroy__ = _byteblower.delete_ByteBlowerPortResultDataList
    __del__ = lambda self: None
ByteBlowerPortResultDataList_swigregister = _byteblower.ByteBlowerPortResultDataList_swigregister
ByteBlowerPortResultDataList_swigregister(ByteBlowerPortResultDataList)

class ByteBlowerPortResultHistory(AbstractRefreshableResult):
    """

    Port counter result history.

    The port counter history is - as always - available in two flavors: the
    cumulative and the interval results

    .. note:: The information is not updated until :meth:`Refresh` is called

    .. note:: See History result for more information.

    A result history object can be created via a ByteBlowerPort, using
    :meth:`.ByteBlowerPort.ResultHistoryGet`

    Example

    Receive all frames on "trunk-1-2" of some server, matching UDP source or
    destination port 67.

    .. code-block:: python
       :emphasize-lines: 3

       port_resultHistory = port.ResultHistoryGet()


    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteBlowerPortResultHistory, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ByteBlowerPortResultHistory, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        """

        Removes the locally stored history snapshots.

        This can be used to save memory in long tests where the results are requested
        at regular intervals.

        .. warning:: Any interval or cumulative result object returned from this
                     history object before calling :meth:`Clear` will be destroyed and
                     thus become unusable.

        """
        return _byteblower.ByteBlowerPortResultHistory_Clear(self)


    def SamplingIntervalDurationGet(self):
        """

        Duration of one sampling interval in nanoseconds.

        :return:  Duration in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.SamplingIntervalDurationGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_SamplingIntervalDurationGet(self)


    def SamplingIntervalDurationSet(self, inDuration):
        """

        Sets the duration of one sampling interval.

        .. warning:: This affects all users on the same ByteBlower interface.

        .. warning:: The previously collected history will be invalidated.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port1_resultHistory.SamplingIntervalDurationGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_SamplingIntervalDurationSet(self, inDuration)


    def SamplingBufferLengthGet(self):
        """

        Number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method gets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        :return: The length of the sample buffer

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.SamplingBufferLengthGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_SamplingBufferLengthGet(self)


    def SamplingBufferLengthSet(self, inCount):
        """

        Sets the number of samples to keep in the buffer.

        The ByteBlower server has a buffer to keep some samples before they are
        transferred to the client. This method sets the maximum number of samples the
        server can hold. The last sample will always be the running sample. When a
        sample is closed, the oldest sample in the buffer will be removed.

        .. versionadded:: 2.3.0

        Example

        .. code-block:: python
           :emphasize-lines: 1

           port_resultHistory.SamplingBufferLengthSet(10)


        """
        return _byteblower.ByteBlowerPortResultHistory_SamplingBufferLengthSet(self, inCount)


    def CumulativeGet(self):
        """

        Returns a list of available cumulative counters.

        :return: :class:`.ByteBlowerPortResultDataList` containing the Interval
                 counters

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

            for results in port_resultHistory.CumulativeGet():
                print(results.DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_CumulativeGet(self)


    def IntervalGet(self):
        """

        Returns a list of available interval counters.

        :return: :class:`ByteBlowerPortResultDataList` containing the Interval counters

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

            for i in resultHistory.IntervalGet():
                print(i.DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_IntervalGet(self)


    def CumulativeGetByIndex(self, index):
        """

        Returns a single item of the cumulative list.

        :return: :class:`.ByteBlowerPortResultData` cumulative counter object at the
                 specified index

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

            print(resultHistory.CumulativeGetByIndex(0).DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_CumulativeGetByIndex(self, index)


    def IntervalGetByIndex(self, index):
        """

        Returns a single item of the interval list.

        :return: :class:`.ByteBlowerPortResultData` interval counter object at the
                 specified index

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.IntervalGetByIndex(0).DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_IntervalGetByIndex(self, index)


    def CumulativeGetByTime(self, timestamp):
        """

        Returns a single item of the cumulative list using a timestamp nanoseconds.

        .. versionadded:: 2.2

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.CumulativeGetByTime(timestamp).DescriptionGet())


        """
        return _byteblower.ByteBlowerPortResultHistory_CumulativeGetByTime(self, timestamp)


    def IntervalGetByTime(self, timestamp):
        """

        Returns a single item of the interval list using a timestamp in nanoseconds.

        .. versionadded:: 2.2

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           interval = port_resultHistory.IntervalGetByTime(timestamp)

        """
        return _byteblower.ByteBlowerPortResultHistory_IntervalGetByTime(self, timestamp)


    def CumulativeLatestGet(self):
        """

        Returns latest closed item of the cumulative list.

        :return: The latests closed :class:`.ByteBlowerPortResultData` cumulative
                  counter object.

        .. versionadded:: 2.2

        Example

        This example gets the available cumulative counters

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.CumulativeLatestGet.DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_CumulativeLatestGet(self)


    def IntervalLatestGet(self):
        """

        Returns the latest closed item of the interval list.

        :return: The latests closed :class:`.ByteBlowerPortResultData` interval counter
                 object.

        .. versionadded:: 2.2

        Example

        This example gets the available interval counters

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.IntervalLatestGet.DescriptionGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_IntervalLatestGet(self)


    def CumulativeLengthGet(self):
        """

        Returns the size of the cumulative list.

        :return:  The length of the cumulative list

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.CumulativeLengthGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_CumulativeLengthGet(self)


    def IntervalLengthGet(self):
        """

        Returns the size of the interval list.

        :return:  The length of the interval list

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.IntervalLengthGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_IntervalLengthGet(self)


    def RefreshTimestampGet(self):
        """

        Returns the timestamp on the server when the current history is requested.

        :return: Timestamp on the server when the current history is requested in
                 nanoseconds since epoch

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(port_resultHistory.RefreshTimestampGet())

        """
        return _byteblower.ByteBlowerPortResultHistory_RefreshTimestampGet(self)

ByteBlowerPortResultHistory_swigregister = _byteblower.ByteBlowerPortResultHistory_swigregister
ByteBlowerPortResultHistory_swigregister(ByteBlowerPortResultHistory)

class ByteBlowerServer(AbstractObject):
    """

    Representation of a client connection to a shared,  physical ByteBlower server, 
    which can send and receive network traffic through its interfaces.  

    Using this class, ByteBlower ports (logical network hosts) can be docked to a 
    :term:`NUT` at a specific place.  

    Furthermore, information about a shared ByteBlower Server, such as the 
    available interfaces and the current connections can be retrieved.  

    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteBlowerServer, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ByteBlowerServer, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PhysicalInterfacesGet(self):
        return _byteblower.ByteBlowerServer_PhysicalInterfacesGet(self)

    def PhysicalInterfacesGetByType(self, inPhysicalInterfaceType):
        return _byteblower.ByteBlowerServer_PhysicalInterfacesGetByType(self, inPhysicalInterfaceType)

    def InterfaceGetByName(self, name):
        return _byteblower.ByteBlowerServer_InterfaceGetByName(self, name)

    def InterfaceNamesGet(self):
        """

        Shows the available physical ByteBlower interfaces on the ByteBlower server.  

        The available interfaces on a server depend on the static server configuration. 
        Only the presence of USB interfaces can change dynamically (using ::Update).  

        ByteBlower interfaces are represented by a string code formatted as follows:

        * Trunking interfaces, which are interfaces located on a ByteBlower switch, 
          have a format ``trunk-X-Y``, where ``X`` is the server interface on which the
          switch is connected and ``Y`` is the interface number on the switch itself.
        * Non-trunking interface, which are located directly on the server (without 
          switch), have a format ``nontrunk-X``, where ``X`` is the (server) interface.  

        This format is used as keys in the key-value pair list returned by :meth:`UsersGet`.
        It is also the format that should be passed to :meth:`PortCreate` method as 
        argument.

        :return: A list of all available physical interfaces on this server.  

        Example

        Assume `server` has a single 48-port trunking interface and a single 
        non-trunking interface.

        .. code-block:: python
           :emphasize-lines: 1

           server.InterfaceNamesGet()
           # Returns ['trunk-1-1', 'trunk-1-2', 'trunk-1-3', ... , 'trunk-1-48', 'nontrunk-1']

        """
        return _byteblower.ByteBlowerServer_InterfaceNamesGet(self)


    def PacketDumpCreate(self, *args):
        """

        Creates a PacketDump object on the specified ByteBlower interface.  

        .. versionadded:: 2.9.0

        The PacketDump API allows to capture all incoming and outgoing network traffic 
        on a ByteBlower interface.  

        :param interface: Interface name of the ByteBlower interface

        :return: :class:`.PacketDump`

        :raises: ByteBlower.Exception.API.UnknownByteBlowerInterface - When the 
                 specified interface name does not exist on the connected server.  

        Example

        Create a PacketDump object on trunk-1-1  

        .. code-block:: python
           :emphasize-lines: 1

        	dump = server.PacketDumpCreate('trunk-1-1')



        Creates a PacketDump object on the specified ByteBlower interface.  

        .. versionadded:: 2.9.0

        The PacketDump API allows to capture all incoming and outgoing network traffic 
        on a ByteBlower interface.  

        :param interface: Interface name of the ByteBlower interface

        :return: :class:`.PacketDump`

        :raises: ByteBlower.Exception.API.UnknownByteBlowerInterface - When the 
                 specified interface name does not exist on the connected server.  

        Example

        Create a PacketDump object on trunk-1-1  

        .. code-block:: python
           :emphasize-lines: 1

        	dump = server.PacketDumpCreate('trunk-1-1')


        """
        return _byteblower.ByteBlowerServer_PacketDumpCreate(self, *args)


    def PacketDumpDestroy(self, packet_dump):
        return _byteblower.ByteBlowerServer_PacketDumpDestroy(self, packet_dump)

    def PortCreate(self, *args):
        """

        Creates a new ByteBlower port on the specified ByteBlower interface.  

        By specifying a physical ByteBlower interface, we can 'attach' a ByteBlower 
        port (which represents a network host) to the :term:`NUT`
        somewhere. This depends of the physical set-up.  

        Available ByteBlower interfaces depend on the server type and configuration. 
        Available interfaces on the connected server can be shown using 
        :meth:`InterfacesGet`.

        ByteBlower interfaces are represented by a string code formatted as follows:

        * Trunking interfaces, which are interfaces located on a ByteBlower switch, 
          have a format ``trunk-X-Y``, where ``X`` is the server interface on which the
          switch is connected and ``Y`` is the interface number on the switch itself.
        * Non-trunking interface, which are located directly on the server (without 
          switch), have a format ``nontrunk-X``, where ``X`` is the (server) interface.  

        :param interface: String code for the ByteBlower interface on which to create the port.  

        :return: :class:`.ByteBlowerPort`  

        :raises: ByteBlower.Exception.API.UnknownByteBlowerInterface - 
                 When the specified interface name does not exist on the connected server.  

        Example

        Create a simulated host and attach it to the :term:`NUT`. More  specifically,
        locate it within the ethernet subnet connected to the first  interface of the
        first ByteBlower switch.  

        .. code-block:: python
           :emphasize-lines: 1

           port = server.PortCreate('trunk-1-1')



        Creates a new ByteBlower port on the specified ByteBlower interface.  

        By specifying a physical ByteBlower interface, we can 'attach' a ByteBlower 
        port (which represents a network host) to the :term:`NUT`
        somewhere. This depends of the physical set-up.  

        Available ByteBlower interfaces depend on the server type and configuration. 
        Available interfaces on the connected server can be shown using 
        :meth:`InterfacesGet`.

        ByteBlower interfaces are represented by a string code formatted as follows:

        * Trunking interfaces, which are interfaces located on a ByteBlower switch, 
          have a format ``trunk-X-Y``, where ``X`` is the server interface on which the
          switch is connected and ``Y`` is the interface number on the switch itself.
        * Non-trunking interface, which are located directly on the server (without 
          switch), have a format ``nontrunk-X``, where ``X`` is the (server) interface.  

        :param interface: String code for the ByteBlower interface on which to create the port.  

        :return: :class:`.ByteBlowerPort`  

        :raises: ByteBlower.Exception.API.UnknownByteBlowerInterface - 
                 When the specified interface name does not exist on the connected server.  

        Example

        Create a simulated host and attach it to the :term:`NUT`. More  specifically,
        locate it within the ethernet subnet connected to the first  interface of the
        first ByteBlower switch.  

        .. code-block:: python
           :emphasize-lines: 1

           port = server.PortCreate('trunk-1-1')



        Creates a new ByteBlower port on the specified ByteBlower interface.  

        By specifying a physical ByteBlower interface, we can 'attach' a ByteBlower 
        port (which represents a network host) to the :term:`NUT`
        somewhere. This depends of the physical set-up.  

        Available ByteBlower interfaces depend on the server type and configuration. 
        Available interfaces on the connected server can be shown using 
        :meth:`InterfacesGet`.

        ByteBlower interfaces are represented by a string code formatted as follows:

        * Trunking interfaces, which are interfaces located on a ByteBlower switch, 
          have a format ``trunk-X-Y``, where ``X`` is the server interface on which the
          switch is connected and ``Y`` is the interface number on the switch itself.
        * Non-trunking interface, which are located directly on the server (without 
          switch), have a format ``nontrunk-X``, where ``X`` is the (server) interface.  

        :param interface: String code for the ByteBlower interface on which to create the port.  

        :return: :class:`.ByteBlowerPort`  

        :raises: ByteBlower.Exception.API.UnknownByteBlowerInterface - 
                 When the specified interface name does not exist on the connected server.  

        Example

        Create a simulated host and attach it to the :term:`NUT`. More  specifically,
        locate it within the ethernet subnet connected to the first  interface of the
        first ByteBlower switch.  

        .. code-block:: python
           :emphasize-lines: 1

           port = server.PortCreate('trunk-1-1')


        """
        return _byteblower.ByteBlowerServer_PortCreate(self, *args)


    def PortDestroy(self, inPort):
        return _byteblower.ByteBlowerServer_PortDestroy(self, inPort)

    def PortGet(self):
        """

        Returns a list of all ByteBlower ports created through this server connection.  

        Only ports created through the connection represented by this object are 
        returned, not those created by other client instances (either GUI or API) or 
        those created by other server connections within this API instance! See 
        :meth:`UsersGet` to see the interfaces on which other users have created ports.

        :return:  :class:`.ByteBlowerPortList`

        .. code-block:: python
           :emphasize-lines: 1

           port = server.PortGet()

        """
        return _byteblower.ByteBlowerServer_PortGet(self)


    def UsersGet(self):
        """

        Shows which physical interfaces of the (shared) physical ByteBlower server are currently used by which clients.  

        This method gives an overview of how a ByteBlower server is currently used. 
        It displays which client connections (whether from GUI scenario runs or API
        sessions) have created ByteBlowerPort objects on which of the server's physical
        ByteBlower interfaces.  

        Such a client connection to a server is represented by this very 
        ByteBlowerServer type! As soon as some client instance (e.g. a TCL shell, 
        python interpreter or a GUI) on some client computer creates such server 
        object, a  connection is established to that shared server.  

        Multiple client instances can be active on the same host. For example, a single
        host may be running a GUI scenario, two python scripts and an interactive Tcl 
        session at the same time.
        Similarly, a single client instance may have multiple parallel connections to 
        the same server, by calling :meth:`.ByteBlower.ServerAdd` multiple times for 
        the same server URL or IP.

        The server's physical interfaces are statically configured on the server 
        machine and can be retrieved using :meth:`InterfacesGet`. They are shared 
        among all connected clients.

        Client connections are identified by the client's hostname. This means that all
        server connections from all client instances on a single host will all be
        different 'users', but will have the same string representation. If they use 
        the same interfaces, that hostname will simply appear multiple times.  

        As soon as a specific ByteBlowerServer (representing a client connection) 
        creates a first ByteBlowerPort on some interface, it is 'using' that interface.
        The interface is no longer used when all all ports created by that server on 
        it are destroyed. Ports can be destroyed in the following ways:

        * Explicitly, by calling ``PortRemove`` on the ByteBlowerServer
        * By destroying the ByteBlowerServer for that port. This is also what happens 
          when a GUI finishes or cancels a scenario.
        * By destroying that client instances root ByteBlower object. This is also what
          happens when a client process (GUI or API) is killed.

        :return:  A list of name value pairs, one for each physical ByteBlower 
                  interface with one or more ports configured on it. The name is the 
                  string representation of the interface, the value is a list of the 
                  server connections (represented by their client's hostname) which 
                  have created ports on that interface.  

        Example

        Assume three client instances are currently connected to this server. The first
        runs on John's PC, the second runs on Jane's PC and the last one is a second 
        client instance connecting John's PC. Note the non-trunking interface is used 
        by multiple client instances!  

        .. code-block:: python
           :emphasize-lines: 1

           userList = server.UsersGet()

        """
        return _byteblower.ByteBlowerServer_UsersGet(self)


    def Update(self):
        """

        Updates dynamic interfaces (e.g. USB) on the connected server.  

        .. deprecated:: 2.0
           Since 2.0 are USB interfaces not supported anymore

        This methods looks for attached USB interfaces and updates its available 
        interfaces. If USB interfaces are attached, they will be returned by
        :meth:`InterfacesGet` after this running this method.  

        Bug
        Since USB interfaces are not yet supported, this method currently has no use. 
        Method is not yet implemented and will throw a :exc:`.TechnicalError`


        """
        return _byteblower.ByteBlowerServer_Update(self)


    def TimestampGet(self):
        """

        Returns the current timestamp on the server.  

        .. versionadded:: 2.3.0

        Retrieves the current timestamp of the server in nanoseconds. This can be used
        to calculate the offset between two servers to compare results.  

        :return: Timestamp in nanoseconds

        Example

        Assume the client is connected (through this object) to a server:  

        .. code-block:: python
           :emphasize-lines: 1

           server.TimestampGet()
           # :return: 1432805398000000000 


        """
        return _byteblower.ByteBlowerServer_TimestampGet(self)


    def PortsStart(self, inPorts):
        return _byteblower.ByteBlowerServer_PortsStart(self, inPorts)

    def PortsStop(self, inPorts):
        return _byteblower.ByteBlowerServer_PortsStop(self, inPorts)

    def PortsStartAll(self):
        return _byteblower.ByteBlowerServer_PortsStartAll(self)

    def PortsStopAll(self):
        return _byteblower.ByteBlowerServer_PortsStopAll(self)

    def ServiceInfoGet(self):
        """

        Returns the service information of the ByteBlower server daemon.  

        .. versionadded:: 2.6.0  

        .. code-block:: python
           :emphasize-lines: 1

           server.ServiceInfoGet()


        """
        return _byteblower.ByteBlowerServer_ServiceInfoGet(self)


    def ResultsRefreshAll(self):
        return _byteblower.ByteBlowerServer_ResultsRefreshAll(self)
ByteBlowerServer_swigregister = _byteblower.ByteBlowerServer_swigregister
ByteBlowerServer_swigregister(ByteBlowerServer)

class ByteBlowerServerServiceInfo(ServiceInfo):
    """

    This class contains information on the ByteBlower System.

    With this object you can get information concerning the Type / version / IP or hostname etc... information.

    Example

    .. code-block:: python
       :emphasize-lines: 3

       from byteblowerll.byteblower import ByteBlower
       server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
       service_info = server.ServiceInfoGet()

    .. versionadded:: 2.6.0


    """

    __swig_setmethods__ = {}
    for _s in [ServiceInfo]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteBlowerServerServiceInfo, name, value)
    __swig_getmethods__ = {}
    for _s in [ServiceInfo]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ByteBlowerServerServiceInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def LicenseGet(self):
        """

        Returns the License information for this ByteBlower server.

        .. versionadded:: 2.6.0
        .. deprecated:: 2.10

        Each physical ByteBlower server (represented by this type of object) has a
        specific ByteBlower License.

        :return: :class:`ByteBlowerLicense`


        """
        return _byteblower.ByteBlowerServerServiceInfo_LicenseGet(self)


    def ManagementIPAddressGet(self):
        """

        Returns all management IP addresses of the connected ByteBlower server.

        .. versionadded:: 2.6.0

        :return: List of management IP addresses

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(service_info.ManagementIPAddressGet())

        """
        return _byteblower.ByteBlowerServerServiceInfo_ManagementIPAddressGet(self)


    def ConnectionHostGet(self):
        """

        Returns the host (either registered name or IP address) used to connect to the
        ByteBlower server.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(service_info.ConnectionHostGet())
           # prints 'bytblower-1.lab.byteblower.com'

        """
        return _byteblower.ByteBlowerServerServiceInfo_ConnectionHostGet(self)


    def ConnectionIPAddressGet(self):
        """

        Returns the IP address used to connect to the ByteBlower server.

        Example

        .. code-block:: python
           :emphasize-lines: 5

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           server.PortCreate('trunk-1-1')
           service_info = server.ServiceInfoGet()
           print(service_info.ConnectionIPAddressGet())
           # prints ip address

        """
        return _byteblower.ByteBlowerServerServiceInfo_ConnectionIPAddressGet(self)


    def ConnectionPortNumberGet(self):
        """

        Returns the TCP port number of the connected ByteBlower server.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(service_info.ConnectionPortNumberGet())


        """
        return _byteblower.ByteBlowerServerServiceInfo_ConnectionPortNumberGet(self)

ByteBlowerServerServiceInfo_swigregister = _byteblower.ByteBlowerServerServiceInfo_swigregister
ByteBlowerServerServiceInfo_swigregister(ByteBlowerServerServiceInfo)

class ByteBlowerLicense(AbstractObject):
    """

    This class represents the license information of your connected server.

    The license is defined by the security key hardware on your ByteBlower server.

    .. versionadded:: 2.6.0
    .. deprecated:: 2.10.0

    Example

    .. code-block:: python
       :emphasize-lines: 2

    	license = serverServiceInfo.LicenseGet()
        print(license.TimeAllowedGet())



    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteBlowerLicense, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ByteBlowerLicense, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def VersionGet(self):
        """

        Gets the version of the license.

        :return: the version of the license
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(license.VersionGet())

        """
        return _byteblower.ByteBlowerLicense_VersionGet(self)


    def SerialGet(self):
        """

        Retrieves the serial number.

        This serial number is the serial number of the hardware containing the license.
        This is handy info when contacting the ByteBlower support department.

        :return: the serial number of the hardware containing the license
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(license.SerialGet())

        """
        return _byteblower.ByteBlowerLicense_SerialGet(self)


    def NumberOfNonTrunksGet(self):
        """

        The maximum number of non-trunking interfaces allowed by the license

        :return: number of nontrunks
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(license.NumberOfNonTrunksGet())

        """
        return _byteblower.ByteBlowerLicense_NumberOfNonTrunksGet(self)


    def NumberOfTrunksGet(self):
        """

        The maximum number of trunking interfaces allowed by the license

        :return: number of trunking interfaces
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(license.NumberOfTrunksGet())

        """
        return _byteblower.ByteBlowerLicense_NumberOfTrunksGet(self)


    def NumberOfTrunkPortsGet(self, index):
        """

        The maximum number of ByteBlower Interfaces that can reside at the given trunk
        interface.

        :param index: Index of the trunk interface to obtain the value for.
        :type index: int

        :return: Allowed number of ByteBlower Interfaces on the physical interface
        :rtype int:

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(license.NumberOfTrunkPortsGet())

        """
        return _byteblower.ByteBlowerLicense_NumberOfTrunkPortsGet(self, index)


    def TimeConsumedGet(self):
        """

        The number of minutes the ByteBlower server has run on the license.

        This value has only a meaning when the license is a temporary (demo) license.

        :return: Number of minutes the ByteBlower server has used of the maximum allowed
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(license.TimeConsumedGet())


        """
        return _byteblower.ByteBlowerLicense_TimeConsumedGet(self)


    def TimeAllowedGet(self):
        """

        The number of minutes the ByteBlower server can run on the license.

        If the value is set to 4294967295, the license is permanent and the number
        should be treated as infinity.

        :return: Number of minutes the ByteBlower server can run.
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(license.TimeAllowedGet())



        """
        return _byteblower.ByteBlowerLicense_TimeAllowedGet(self)

ByteBlowerLicense_swigregister = _byteblower.ByteBlowerLicense_swigregister
ByteBlowerLicense_swigregister(ByteBlowerLicense)

class GroupSchedulableObject(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GroupSchedulableObject, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GroupSchedulableObject, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_GroupSchedulableObject
    __del__ = lambda self: None

    def SetScheduleGroup(self, group):
        return _byteblower.GroupSchedulableObject_SetScheduleGroup(self, group)

    def UnsetScheduleGroup(self):
        return _byteblower.GroupSchedulableObject_UnsetScheduleGroup(self)
GroupSchedulableObject_swigregister = _byteblower.GroupSchedulableObject_swigregister
GroupSchedulableObject_swigregister(GroupSchedulableObject)

class AbstractObjectList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AbstractObjectList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AbstractObjectList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.AbstractObjectList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.AbstractObjectList___nonzero__(self)

    def __bool__(self):
        return _byteblower.AbstractObjectList___bool__(self)

    def __len__(self):
        return _byteblower.AbstractObjectList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.AbstractObjectList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.AbstractObjectList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.AbstractObjectList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.AbstractObjectList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.AbstractObjectList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.AbstractObjectList___setitem__(self, *args)

    def pop(self):
        return _byteblower.AbstractObjectList_pop(self)

    def append(self, x):
        return _byteblower.AbstractObjectList_append(self, x)

    def empty(self):
        return _byteblower.AbstractObjectList_empty(self)

    def size(self):
        return _byteblower.AbstractObjectList_size(self)

    def swap(self, v):
        return _byteblower.AbstractObjectList_swap(self, v)

    def begin(self):
        return _byteblower.AbstractObjectList_begin(self)

    def end(self):
        return _byteblower.AbstractObjectList_end(self)

    def rbegin(self):
        return _byteblower.AbstractObjectList_rbegin(self)

    def rend(self):
        return _byteblower.AbstractObjectList_rend(self)

    def clear(self):
        return _byteblower.AbstractObjectList_clear(self)

    def get_allocator(self):
        return _byteblower.AbstractObjectList_get_allocator(self)

    def pop_back(self):
        return _byteblower.AbstractObjectList_pop_back(self)

    def erase(self, *args):
        return _byteblower.AbstractObjectList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_AbstractObjectList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.AbstractObjectList_push_back(self, x)

    def front(self):
        return _byteblower.AbstractObjectList_front(self)

    def back(self):
        return _byteblower.AbstractObjectList_back(self)

    def assign(self, n, x):
        return _byteblower.AbstractObjectList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.AbstractObjectList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.AbstractObjectList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.AbstractObjectList_reserve(self, n)

    def capacity(self):
        return _byteblower.AbstractObjectList_capacity(self)
    __swig_destroy__ = _byteblower.delete_AbstractObjectList
    __del__ = lambda self: None
AbstractObjectList_swigregister = _byteblower.AbstractObjectList_swigregister
AbstractObjectList_swigregister(AbstractObjectList)

ScheduleGroupStatus_Configuration = _byteblower.ScheduleGroupStatus_Configuration
ScheduleGroupStatus_Prepared = _byteblower.ScheduleGroupStatus_Prepared
ScheduleGroupStatus_Started = _byteblower.ScheduleGroupStatus_Started
ScheduleGroupStatus_Stopped = _byteblower.ScheduleGroupStatus_Stopped
ScheduleGroupStatus_Error = _byteblower.ScheduleGroupStatus_Error
class ScheduleGroup(AbstractObject):
    """

    A collection of schedulable objects that can be started.

    Example

    remove all members from the group

    .. code-block:: python

        scheduleGroup = bbInstance.ScheduleGroupCreate()
        scheduleGroup.MembersAdd(httpClient)


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScheduleGroup, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ScheduleGroup, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def MembersGet(self):
        """

        Returns a list of ToopOIDs of the members of this group.

        :return: List of schedulable objects in order of addition. Possible empty.
                 Their individual object types depend on the types used in :meth:`MembersAdd`:

        HTTPClient
            Layer5.Http.Client

        ICMPEchoSession
            Layer3.ICMPEchoSession

        ICMPv6EchoSession
            Layer3.ICMPv6EchoSession

        Igmp Join
            Layer4.Igmp.Schedule.Join

        Igmp Leave
            Layer4.Igmp.Schedule.Leave

        Igmp IpMulticastListen
            Layer4.Igmp.Schedule.IpMulticastListen

        Mld StartListening
            Layer4.Mld.Schedule.StartListening

        Mld StopListening
            Layer4.Mld.Schedule.StopListening

        Mld Ipv6MulticastListen
            Layer4.Mld.Schedule.Ipv6MulticastListen

        TxStream
             Tx.Stream

        Example

        return the ObjectID of the members

        .. code-block:: python
           :emphasize-lines: 1

           print(scheduleGroup.MembersGet()[0].DescriptionGet())


        """
        return _byteblower.ScheduleGroup_MembersGet(self)


    def MembersLengthGet(self):
        """

        This method returns the number of members in the scheduleGroup.

        :return:  Size of memberlist

        Example

        add a HTTPClient to the group

        .. code-block:: python
           :emphasize-lines: 3

           print(scheduleGroup.MembersLengthGet())


        """
        return _byteblower.ScheduleGroup_MembersLengthGet(self)


    def MembersAdd(self, *args):
        """

        This method will add a Schedulable object to the ScheduleGroup.

        :param schedulableObject: A ScheduleObject or Stream which will be added to the
                                  ScheduleGroup.

        Example

        add a HTTPClient to the group

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersAdd(igmp)


        Example

        add multiple schedulable objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO



        This method will add a Schedulable object to the ScheduleGroup.

        :param schedulableObject: A ScheduleObject or Stream which will be added to the
                                  ScheduleGroup.

        Example

        add a HTTPClient to the group

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersAdd(igmp)


        Example

        add multiple schedulable objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO



        This method will add a Schedulable object to the ScheduleGroup.

        :param schedulableObject: A ScheduleObject or Stream which will be added to the
                                  ScheduleGroup.

        Example

        add a HTTPClient to the group

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersAdd(igmp)


        Example

        add multiple schedulable objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.ScheduleGroup_MembersAdd(self, *args)


    def MembersRemove(self, *args):
        """

        This method will remove s SchedulableObject from the group.

        :param object: The object which will be removed from this group.

        Example

        remove a igmp from the scheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersRemove(igmp)

        Example

        remove multiple objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO



        This method will remove s SchedulableObject from the group.

        :param object: The object which will be removed from this group.

        Example

        remove a igmp from the scheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersRemove(igmp)

        Example

        remove multiple objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO



        This method will remove s SchedulableObject from the group.

        :param object: The object which will be removed from this group.

        Example

        remove a igmp from the scheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersRemove(igmp)

        Example

        remove multiple objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO



        This method will remove s SchedulableObject from the group.

        :param object: The object which will be removed from this group.

        Example

        remove a igmp from the scheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersRemove(igmp)

        Example

        remove multiple objects at once

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
           # TODO


        """
        return _byteblower.ScheduleGroup_MembersRemove(self, *args)


    def MembersClear(self):
        """

        This method will remove all members from the schedulegroup.

        Example

        remove all members from the group

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.MembersClear()



        """
        return _byteblower.ScheduleGroup_MembersClear(self)


    def Prepare(self):
        """

        This method will prepare all the schedules, but NOT start them.

        :raises: If - one of the Schedules fail to prepare, the others are canceled and
                 an exception is thrown. This exception will contain onformation about
                 the object which caused it.

        Example

        Preparing the scheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

        	scheduleGroup.Prepare()


        """
        return _byteblower.ScheduleGroup_Prepare(self)


    def Start(self):
        """

        This method will start the schedules. The Schedules must be in the prepared
        state.

        :raises: ByteBlower.Exception.ScheduleNotPrepared - The schedulegroup must be
                 prepared before it can be started.

        Example

        Start the ScheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

        	scheduleGroup.Start()



        """
        return _byteblower.ScheduleGroup_Start(self)


    def Stop(self):
        """

        This method will stop the schedules.

        :raises: ByteBlower.Exception.ScheduleNotRunning - You can only stop a schedule
                 that is running.

        Example

        Stop the scheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

           scheduleGroup.stop()



        """
        return _byteblower.ScheduleGroup_Stop(self)


    def StatusGet(self):
        """

        Returns the status of the ScheduleGroup.

        :return: The status

        Valid status values are

        - configure
        - prepared
        - started
        - stopped
        - error

        Example

        Start the scheduleGroup

        .. code-block:: python
           :emphasize-lines: 1

           print(scheduleGroup.StatusGet())



        """
        return _byteblower.ScheduleGroup_StatusGet(self)

ScheduleGroup_swigregister = _byteblower.ScheduleGroup_swigregister
ScheduleGroup_swigregister(ScheduleGroup)


def ConvertScheduleGroupStatusToString(inStatus):
    return _byteblower.ConvertScheduleGroupStatusToString(inStatus)
ConvertScheduleGroupStatusToString = _byteblower.ConvertScheduleGroupStatusToString
class ScheduleGroupList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScheduleGroupList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ScheduleGroupList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ScheduleGroupList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ScheduleGroupList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ScheduleGroupList___bool__(self)

    def __len__(self):
        return _byteblower.ScheduleGroupList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ScheduleGroupList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ScheduleGroupList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ScheduleGroupList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ScheduleGroupList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ScheduleGroupList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ScheduleGroupList___setitem__(self, *args)

    def pop(self):
        return _byteblower.ScheduleGroupList_pop(self)

    def append(self, x):
        return _byteblower.ScheduleGroupList_append(self, x)

    def empty(self):
        return _byteblower.ScheduleGroupList_empty(self)

    def size(self):
        return _byteblower.ScheduleGroupList_size(self)

    def swap(self, v):
        return _byteblower.ScheduleGroupList_swap(self, v)

    def begin(self):
        return _byteblower.ScheduleGroupList_begin(self)

    def end(self):
        return _byteblower.ScheduleGroupList_end(self)

    def rbegin(self):
        return _byteblower.ScheduleGroupList_rbegin(self)

    def rend(self):
        return _byteblower.ScheduleGroupList_rend(self)

    def clear(self):
        return _byteblower.ScheduleGroupList_clear(self)

    def get_allocator(self):
        return _byteblower.ScheduleGroupList_get_allocator(self)

    def pop_back(self):
        return _byteblower.ScheduleGroupList_pop_back(self)

    def erase(self, *args):
        return _byteblower.ScheduleGroupList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_ScheduleGroupList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.ScheduleGroupList_push_back(self, x)

    def front(self):
        return _byteblower.ScheduleGroupList_front(self)

    def back(self):
        return _byteblower.ScheduleGroupList_back(self)

    def assign(self, n, x):
        return _byteblower.ScheduleGroupList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.ScheduleGroupList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.ScheduleGroupList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.ScheduleGroupList_reserve(self, n)

    def capacity(self):
        return _byteblower.ScheduleGroupList_capacity(self)
    __swig_destroy__ = _byteblower.delete_ScheduleGroupList
    __del__ = lambda self: None
ScheduleGroupList_swigregister = _byteblower.ScheduleGroupList_swigregister
ScheduleGroupList_swigregister(ScheduleGroupList)

class MeetingPoint(AbstractObject):
    """

    A MeetingPoint is a server that controls a set of wireless devices.

    .. versionadded 2.6.0

    Wireless Endpoints can connect to a Meeting Point by using the
    ByteBlower Wireless Endpoints App.

    Example

    .. code-block:: python
       :caption: Typical usage flow

       instance = ByteBlower.InstanceGet()

       meetingpoint = instance.MeetingPointAdd('byteblower-1.lab.byteblower.com')

       device = meetingpoint.DeviceGet('1234-1345-123')

       stream = device.TxStreamAdd()
       # ...

       device.Lock(True)
       device.Prepare()
       # ...


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MeetingPoint, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MeetingPoint, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def DeviceListLengthGet(self):
        """

        Returns the number of devices that are connected to the Meeting Point.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           meetingPoint.DeviceListLengthGet()



        """
        return _byteblower.MeetingPoint_DeviceListLengthGet(self)


    def DeviceGet(self, mobileDeviceId):
        """

        Returns the device that matches the given device identifier.

        :return: A :class:`.WirelessEndpoint` object

        Example

        .. code-block:: python
           :emphasize-lines: 1

           wirelessEndpoint = meetingPoint.DeviceGet('1189-456dad-45654')


        """
        return _byteblower.MeetingPoint_DeviceGet(self, mobileDeviceId)


    def DeviceListGet(self):
        """

        Returns the list of devices that are connected to the Meeting Point.

        :return: A list with all known WirelessEndpoints
        :rtype: :class:`.WirelessEndpointList`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           device_list = meetingpoint.DeviceListGet()

        """
        return _byteblower.MeetingPoint_DeviceListGet(self)


    def DeviceDestroy(self, device):
        return _byteblower.MeetingPoint_DeviceDestroy(self, device)

    def DeviceIdentifiersGet(self):
        """

        Returns the list of device identifiers of the devices connected to the Meeting Point.

        :return: A list of device identifiers
        :rtype: :class:`StringList`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           device_list = meetingpoint.DeviceIdentifiersGet()


        """
        return _byteblower.MeetingPoint_DeviceIdentifiersGet(self)


    def TimestampGet(self):
        """

        Returns the current timestamp on the server.

        .. versionadded:: 2.3.0

        Retrieves the current timestamp of the server in nanoseconds. This can be used
        to calculate the offset between two servers to compare results.

        :return: Timestamp in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 3,4
           :caption: Get the current time from a MeetingPoint

           print(server.TimestampGet())
           # Returns 1432805398000000000


        """
        return _byteblower.MeetingPoint_TimestampGet(self)


    def ServiceInfoGet(self):
        """

        Returns the service information of the MeetingPoint daemon.

        .. versionadded:: 2.6.0

        :return: An object representing the service information
        :rtype: :class:`.MeetingPointServiceInfo`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           meetingPoint.ServiceInfoGet()

        """
        return _byteblower.MeetingPoint_ServiceInfoGet(self)


    def UsersGet(self):
        """

        Shows which Wireless Endpoints of the (shared) MeetingPoint are currently used by which clients.

        This method gives an overview of how a MeetingPoint is currently used. It
        displays which client connections (whether from GUI scenario runs or API
        sessions) have created :class:`WirelessEndpoint` objects.

        Such a client connection to a meetingpoint is represented by this very
        :class:`MeetingPoint` type! As soon as some client instance (e.g. a Tcl shell
        or a GUI) on some client computer creates such meetingpoint object, a
        connection is established to that shared server.

        Multiple client instances can be active on the same host. For example, a single
        host may be running a GUI scenario, two Tcl scripts and an interactive Tcl
        session at the same time.  Similarly, a single client instance may have
        multiple parallel connections to the same server, by calling
        :meth:`ByteBlower.MeetingPointAdd` multiple times for the same server URL or IP.

        The server's physical interfaces are statically configured on the server
        machine and can be retrieved using :meth:`InterfacesGet`. They are shared among
        all connected clients.

        Client connections are identified by the client's hostname. This means that all
        server connections from all client instances on a single host will all be
        different 'users', but will have the same string representation. If they use
        the same interfaces, that hostname will simply appear multiple times.

        As soon as a specific MeetingPoint (representing a client connection) creates a
        first WirelessEndpoint, it is 'using' that WirelessEndpoint. The
        MeetingPoint is no longer used when all wireless endpoints created by that
        server on it are destroyed. Ports can be destroyed in the following ways:

        * Explicitly, by calling :meth:`.MeetingPoint.WirelessEndpointRemove`.
        * By destroying the :class:`.MeetingPoint` for that port. This is also what
          happens when a GUI finishes or cancels a scenario.
        * By destroying that client instances root :class:`.ByteBlower` object. This is
          also what happens when a client process (GUI or API) is killed.

        :return: A :class:`.UserMobileList` with an item for each user

        Example

        Assume three client instances are currently connected to this server. The first
        runs on John's PC, the second runs on Jane's PC and the last one is a second
        client instance connecting John's PC. Note the non-trunking interface is used
        by multiple client instances!

        .. code-block:: python
           :emphasize-lines: 1

        	users = meetingpoint.UsersGet()


        """
        return _byteblower.MeetingPoint_UsersGet(self)


    def ResultsRefreshAll(self):
        return _byteblower.MeetingPoint_ResultsRefreshAll(self)

    def DevicesStart(self, inDevices):
        """

        Starts all the given Wireless Endpoints.

        :param endpoints: a list on which to start the traffic, triggers and HTTPClients
        :type endpoints: :class:`.WirelessEndpointList`

        :return: Timestamp when the devices will start in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	meetingPoint.DevicesStart()



        """
        return _byteblower.MeetingPoint_DevicesStart(self, inDevices)


    def DevicesPrepare(self, inDevices):
        """

        Prepare all the given Wireless Endpoints.

        :param endpoints: A :class:`.WirelessEndpointList` object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	meetingPoint.DevicesPrepare()


        """
        return _byteblower.MeetingPoint_DevicesPrepare(self, inDevices)


    def DevicesPrepareAsync(self, inDevices):
        """

        Prepares all the given Wireless Endpoints.

        After the meeting point is informed about the wish to prepare the endpoints the
        API directly returns. Call :meth:`DevicesPrepare` to wait until all devices are
        prepared.

        :param endpoints: A list of wireless endpoints to prepare.
        :type endpoints: :class:`.WirelessEndpointList`

        Example

        .. code-block:: python
           :emphasize-lines: 5-7,9
           :caption: Prepare a set of wireless endpoints at once.

           meetingpoint = byteblower_instance.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           device_1 = meetingpoint.DeviceGet('123-123-1')
           device_2 = meetingpoint.DeviceGet('123-123-2')

           device_list = WirelessEndpointList()
           device_list.push_back(device_1)
           device_list.push_back(device_2)

           meetingpoint.DevicesPrepareAsync(device_list)

        """
        return _byteblower.MeetingPoint_DevicesPrepareAsync(self, inDevices)


    def DevicesStartAll(self):
        """

        Starts all the known Wireless Endpoints.

        :return: Timestamp in nanoseconds

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	meetingPoint.DevicesStartAll()


        """
        return _byteblower.MeetingPoint_DevicesStartAll(self)

MeetingPoint_swigregister = _byteblower.MeetingPoint_swigregister
MeetingPoint_swigregister(MeetingPoint)

class MeetingPointServiceInfo(ServiceInfo):
    """



    This class contains information on the MeetingPoint System.

    With this object you can get information concerning the Type / version / IP or hostname etc... information.

    .. code-block:: python
       :emphasize-lines: 3

       from byteblowerll.byteblower import ByteBlower
       meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
       service_info = meetingpoint.ServiceInfoGet()

    .. versionadded:: 2.6.0


    """

    __swig_setmethods__ = {}
    for _s in [ServiceInfo]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MeetingPointServiceInfo, name, value)
    __swig_getmethods__ = {}
    for _s in [ServiceInfo]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MeetingPointServiceInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def LicenseGet(self):
        """

        Returns a license object for the MeetingPoint.

        .. deprecated:: 2.10

        Each physical ByteBlower Meetingpoint (represented by this type of object) has a specific ByteBlower License.

        :return: :class:`.MeetingPointLicense`

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           print(meetingpointService.LicenseGet())



        """
        return _byteblower.MeetingPointServiceInfo_LicenseGet(self)


    def ManagementIPAddressGet(self):
        """

        Returns all management IP addresses of the meeting point.

        :return:  List of management IP addresses

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           print(meetingpointService.ManagementIPAddressGet()[0])



        """
        return _byteblower.MeetingPointServiceInfo_ManagementIPAddressGet(self)


    def ConnectionHostGet(self):
        """

        Returns the host (either registered name or IP address)used to connect to the MeetingPoint.

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           print(service_info.ConnectionHostGet())




        """
        return _byteblower.MeetingPointServiceInfo_ConnectionHostGet(self)


    def ConnectionIPAddressGet(self):
        """

        Returns the IP address used to connect to the meeting point.

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           print(meetingpointService.ConnectionIPAddressGet())


        """
        return _byteblower.MeetingPointServiceInfo_ConnectionIPAddressGet(self)


    def ConnectionPortNumberGet(self):
        """

        Returns the TCP port number of the Meeting Point service daemon.

        Example

        .. code-block:: python
           :emphasize-lines: 4

           from byteblowerll.byteblower import ByteBlower
           meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           service_info = meetingpoint.ServiceInfoGet()
           print(meetingpointService.ConnectionPortNumberGet())



        """
        return _byteblower.MeetingPointServiceInfo_ConnectionPortNumberGet(self)

MeetingPointServiceInfo_swigregister = _byteblower.MeetingPointServiceInfo_swigregister
MeetingPointServiceInfo_swigregister(MeetingPointServiceInfo)

class MeetingPointLicense(AbstractObject):
    """

    This class represents the license information of your connected Meeting Point.

    The license is defined by the security key hardware on your Meeting Point.

    .. versionadded:: 2.6.0

    .. deprecated::  2.10.0


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, MeetingPointLicense, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, MeetingPointLicense, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def VersionGet(self):
        """

        :return:  the version of the license

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(meetingpointLicense.VersionGet())



        """
        return _byteblower.MeetingPointLicense_VersionGet(self)


    def SerialGet(self):
        """

        Retrieves the serial number. This serial number is the serial number of the
        hardware containing the license. This is handy info when contacting the
        ByteBlower support department.

        :return:  the serial number of the hardware containing the license

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(meetingpointLicense.SerialGet())



        """
        return _byteblower.MeetingPointLicense_SerialGet(self)


    def NumberOfWirelessEndpointsGet(self):
        """

        The maximum number of Wireless Endpoints that can be locked simultaneously

        :return: number of Wireless Endpoints

        .. code-block:: python
           :emphasize-lines: 1

           	print(meetingpointLicense.NumberOfWirelessEndpointsGet())



        """
        return _byteblower.MeetingPointLicense_NumberOfWirelessEndpointsGet(self)


    def TimeConsumedGet(self):
        """

        The number of minutes the Meeting Point has run on the license. This value has
        only a meaning when the license is a temporary (demo) license.

        :return: Number of minutes the Meeting Point has used of the maximum allowed

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(meetingpointLicense.TimeConsumedGet())



        """
        return _byteblower.MeetingPointLicense_TimeConsumedGet(self)


    def TimeAllowedGet(self):
        """

        The number of minutes the Meeting Point can run on the license. If the value is
        set to 4294967295, the license is permanent and the number should be treated as
        infinity.

        :return:  Number of minutes the Meeting Point can run.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(meetingpointLicense.TimeAllowedGet())



        """
        return _byteblower.MeetingPointLicense_TimeAllowedGet(self)

MeetingPointLicense_swigregister = _byteblower.MeetingPointLicense_swigregister
MeetingPointLicense_swigregister(MeetingPointLicense)

LogLevel_Debug = _byteblower.LogLevel_Debug
LogLevel_Info = _byteblower.LogLevel_Info
LogLevel_Warning = _byteblower.LogLevel_Warning
LogLevel_Error = _byteblower.LogLevel_Error
LogLevel_Critical = _byteblower.LogLevel_Critical
DeviceStatus_Unavailable = _byteblower.DeviceStatus_Unavailable
DeviceStatus_Available = _byteblower.DeviceStatus_Available
DeviceStatus_Reserved = _byteblower.DeviceStatus_Reserved
DeviceStatus_Starting = _byteblower.DeviceStatus_Starting
DeviceStatus_Running = _byteblower.DeviceStatus_Running

def ConvertLogLevelFromString(inLevel):
    return _byteblower.ConvertLogLevelFromString(inLevel)
ConvertLogLevelFromString = _byteblower.ConvertLogLevelFromString

def ConvertToString(inLevel):
    return _byteblower.ConvertToString(inLevel)
ConvertToString = _byteblower.ConvertToString
class WirelessEndpoint(AbstractObject):
    """

    A WirelessEndpoint is a handle to a wireless device-under-test.

    .. versionadded:: 2.6.0

    Example

    This example shows how to obtain a WirelessEndpoint object from a
    :class:`MeetingPoint` and configure a simple trigger.

    .. code-block:: python
       :caption: Typical flow to create a trigger on a wireless endpoint

       from byteblowerll.byteblower import ByteBlower
       meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
       device = meetingpoint.DeviceGet('00ff11-234-234')
       trigger = device.RxTriggerBasicAdd()


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, WirelessEndpoint, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, WirelessEndpoint, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def MeetingPointGet(self):
        """

        Returns the meetingpoint of this wireless endpoint.

        :return: A: class:`.MeetingPoint` object
        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(wirelessEndpoint.MeetingPointGet().DescriptionGet())


        """
        return _byteblower.WirelessEndpoint_MeetingPointGet(self)


    def AppVersionGet(self):
        """

        Returns the App version.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(wirelessEndpoint.AppVersionGet())


        """
        return _byteblower.WirelessEndpoint_AppVersionGet(self)


    def DeviceIdentifierGet(self):
        """

        Returns device identifier.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(wirelessEndpoint.DeviceIdentifierGet())


        """
        return _byteblower.WirelessEndpoint_DeviceIdentifierGet(self)


    def CapabilityListGet(self):
        """

        Returns a list of Capability objects.

        .. versionadded:: 2.6.0

        :return: A :class:`.CapabilityList` object

        Example

        .. code-block:: python
           :emphasize-lines: 1

            capabilityList = wirelessEndpoint.CapabilityListGet()


        """
        return _byteblower.WirelessEndpoint_CapabilityListGet(self)


    def CapabilityGetByName(self, name):
        """

        Returns a Capability object by its name.

        .. versionadded:: 2.6.0

        ::return: A :class:`.Capability`

        :raises: :exc:`.ConfigError` - UnsupportedConfig error message when the Capability is not supported

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(wirelessEndpoint.CapabilityGetByName('Tcp.Restart').DescriptionGet())


        """
        return _byteblower.WirelessEndpoint_CapabilityGetByName(self, name)


    def CapabilityIsSupported(self, name):
        """

        Checks whether a capability is supported.

        .. versionadded:: 2.6.0

        :return: bool - True if it is supported, False if not

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(wirelessEndpoint.CapabilityIsSupported('Tcp.Restart'))

        """
        return _byteblower.WirelessEndpoint_CapabilityIsSupported(self, name)


    def DeviceInfoGet(self):
        """

        Returns an object with the Wireless Endpoint DeviceInfo.

        .. versionadded:: 2.6.0

        :return: <WirelessEndpoint.DeviceInfo object>

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(wirelessEndpoint.DeviceInfoGet().DescriptionGet())


        """
        return _byteblower.WirelessEndpoint_DeviceInfoGet(self)


    def HeartbeatCountGet(self):
        """

        Returns the number of heartbeats performed by the device.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(wirelessEndpoint.HeartbeatCountGet())


        """
        return _byteblower.WirelessEndpoint_HeartbeatCountGet(self)


    def HeartbeatIntervalGet(self):
        """

        Returns the heartbeat interval.

        Default value is 1 second

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(self.wireless_endpoint.HeartbeatIntervalGet())


        """
        return _byteblower.WirelessEndpoint_HeartbeatIntervalGet(self)


    def HeartbeatIntervalSet(self, arg2):
        """

        Sets the heartbeat interval.

        .. note:: When setting the Heartbeat Interval to a value lower than supported by the WirelessEndpoint device, will set the interval to the lowest supported value.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           self.wireless_endpoint.HeartbeatIntervalSet(50000000000)


        """
        return _byteblower.WirelessEndpoint_HeartbeatIntervalSet(self, arg2)


    def HeartbeatMaxFailcountGet(self):
        """

        Returns the maximum number of heartbeats that may fail before the Wireless Endpoint considers the communication broken.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(self.wireless_endpoint.HeartbeatMaxFailcountGet())


        """
        return _byteblower.WirelessEndpoint_HeartbeatMaxFailcountGet(self)


    def HeartbeatMaxFailcountSet(self, arg2):
        """

        Sets the maximum number of heartbeats that may fail before the Wireless Endpoint considers the communication broken.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	wirelessEndpoint.HeartbeatMaxFailcountSet(3)


        """
        return _byteblower.WirelessEndpoint_HeartbeatMaxFailcountSet(self, arg2)


    def HeartbeatTimestampLastGet(self):
        """

        Returns the timestamp of the last received heartbeat.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(self.wireless_endpoint.HeartbeatTimestampLastGet())


        """
        return _byteblower.WirelessEndpoint_HeartbeatTimestampLastGet(self)


    def Lock(self, arg2):
        """

        Locks or unlocks the device for exclusive access.

        :param lock: bool - True to lock, False to unlock

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	self.wireless_endpoint.Lock(True)


        """
        return _byteblower.WirelessEndpoint_Lock(self, arg2)


    def LockGet(self):
        """

        Indicates whether or not the device is locked.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(wirelessEndpoint.LockGet())


        """
        return _byteblower.WirelessEndpoint_LockGet(self)


    def LockOwnerGet(self):
        """

        Returns the name of the current lock owner.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(self.wireless_endpoint.LockOwnerGet())


        """
        return _byteblower.WirelessEndpoint_LockOwnerGet(self)


    def LockIsOwner(self):
        """

        Indicates whether or not we are the current owner of the lock.

        :return: bool - True when we have the lock.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(self.wireless_endpoint.LockIsOwner())


        """
        return _byteblower.WirelessEndpoint_LockIsOwner(self)


    def LockTry(self, lock, expected):
        """

        Tries to lock the Wireless Endpoint.

        :param lock: bool, whether to lock the device or not
        :param expected_state: bool The state the device currently is

        :return: bool: True if the operation succeeded, False if the operation failed

        Example

        .. code-block:: python
           :emphasize-lines: 1

           self.wireless_endpoint.LockTry(False, True)


        """
        return _byteblower.WirelessEndpoint_LockTry(self, lock, expected)


    def LogGet(self):
        """

        Returns a string containing the device log messages.

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(wirelessEndpoint.LogGet())


        """
        return _byteblower.WirelessEndpoint_LogGet(self)


    def LogClear(self):
        """

        Clears the log messages on the device.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           wirelessEndpoint.LogGet()


        """
        return _byteblower.WirelessEndpoint_LogClear(self)


    def LogLevelGet(self):
        """

        Gets the log level on the Wireless Endpoint.

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           # ...
           # :return: TODO


        """
        return _byteblower.WirelessEndpoint_LogLevelGet(self)


    def LogLevelSet(self, l):
        """

        Sets the log level on the Wireless Endpoint.

        Accepted log levels are DEBUG, INFO, WARNING, ERROR, CRITICAL

        Example

        .. code-block:: python
           :emphasize-lines: 3

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           # ...
           # :return: TODO


        """
        return _byteblower.WirelessEndpoint_LogLevelSet(self, l)


    def ProtocolHttpClientAdd(self):
        """

        Adds a httpClient to this mobile device.

        :return: a :class:`.HttpClientMobile` object

        Example

        .. code-block:: python
           :emphasize-lines: 1

           http_client = wirelessEndpoint.ProtocolHttpClientAdd()


        """
        return _byteblower.WirelessEndpoint_ProtocolHttpClientAdd(self)


    def ProtocolHttpClientGet(self):
        """

        Returns the list of HTTP clients created on this mobile device.

        :return: A list of configured HTTP clients on the device.
        :rtype: :class:`.HttpClientMobileList`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           for http_client in device.ProtocolHttpClientGet():
               print(http_client.DescriptionGet())


        """
        return _byteblower.WirelessEndpoint_ProtocolHttpClientGet(self)


    def ProtocolHttpClientRemove(self, arg2):
        return _byteblower.WirelessEndpoint_ProtocolHttpClientRemove(self, arg2)

    def RxTriggerBasicAdd(self):
        """

        Adding a RxTrigger to this mobile device.

        :return: :class:`.TriggerBasicMobile`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	trigger = self.wireless_endpoint.RxTriggerBasicAdd()


        """
        return _byteblower.WirelessEndpoint_RxTriggerBasicAdd(self)


    def RxTriggerBasicGet(self):
        """

        Returns the list of receive triggers created on this mobile device.

        :return: :class:`.RxTriggerBasicMobileList`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(wirelessEndpoint.RxTriggerBasicGet()[0])


        """
        return _byteblower.WirelessEndpoint_RxTriggerBasicGet(self)


    def RxTriggerBasicRemove(self, arg2):
        return _byteblower.WirelessEndpoint_RxTriggerBasicRemove(self, arg2)

    def RxLatencyBasicAdd(self):
        """

        Adding a RxLatency to this mobile device.

        :return: Rx.Latency.Basic.Mobile

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	latencyTrigger = wirelessEndpoint.RxLatencyBasicAdd()


        """
        return _byteblower.WirelessEndpoint_RxLatencyBasicAdd(self)


    def RxLatencyBasicGet(self):
        """

        Returns the list of latency triggers created on this mobile device.

        :return: A :class:`.LatencyBasicMobileList` object

        Example

        .. code-block:: python
           :emphasize-lines: 1

            for rxLatency in wirelessEndpoint.RxLatencyBasicGet():
        		print(rxLatency.DescriptionGet())


        """
        return _byteblower.WirelessEndpoint_RxLatencyBasicGet(self)


    def RxLatencyBasicRemove(self, arg2):
        return _byteblower.WirelessEndpoint_RxLatencyBasicRemove(self, arg2)

    def RxLatencyDistributionAdd(self):
        """

        Creates a latency calculator, which computes latency measurements based on timestamps in received frames (possibly restricted by a filter).  

        .. versionadded:: 2.12.16  

        Like all incoming packet processors (or 'Rx' objects), this object listens to incoming traffic matching a configurable BPF filter and performs some action when it arrives.  

        Typically, the filter should limit the matching traffic to the Tx.Stream whose transmitted frames actually contain the required timestamps!  

        The latency calculator is activated as soon as it is created, so don't forget to reset its counters after setting the filter and initializing your test.  

        See :class:`.FrameMobile` for information on timestamping.  

        :return: :class:`.LatencyDistributionMobile`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

           distribution = port.RxLatencyDistributionAdd()


        """
        return _byteblower.WirelessEndpoint_RxLatencyDistributionAdd(self)


    def RxLatencyDistributionGet(self):
        """

        Returns the list of latency calculators created on this port.  

        .. versionadded:: 2.12.16  

        See :meth:`.RxLatencyDistributionAdd` for more information.  

        :return: :class:`.LatencyDistributionMobileList`

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	all_latency = port.RxLatencyDistributionGet()




        """
        return _byteblower.WirelessEndpoint_RxLatencyDistributionGet(self)


    def RxLatencyDistributionRemove(self, arg2):
        return _byteblower.WirelessEndpoint_RxLatencyDistributionRemove(self, arg2)

    def TxStreamAdd(self):
        """

        Adding a :class:`StreamMobile` to this mobile device.

        :return: a :class:`.StreamMobile` object.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	stream = wirelessEndpoint.TxStreamAdd()


        """
        return _byteblower.WirelessEndpoint_TxStreamAdd(self)


    def TxStreamGet(self):
        """

        Returns the list of streams created on this mobile device.

        :return: A list of streams configured on the mobile device.
        :rtype: :class:`.StreamMobileList`

        Example

        .. code-block:: python
           :emphasize-lines: 1

           for stream in device.TxStreamGet():
               print(stream.DescriptionGet())


        """
        return _byteblower.WirelessEndpoint_TxStreamGet(self)


    def TxStreamRemove(self, arg2):
        return _byteblower.WirelessEndpoint_TxStreamRemove(self, arg2)

    def Prepare(self):
        """

        Prepare the device


        Example

        .. code-block:: python
           :emphasize-lines: 1

        	wirelessEndpoint.Prepare()


        """
        return _byteblower.WirelessEndpoint_Prepare(self)


    def PrepareAsync(self):
        """

        PrepareAsync.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           self.wireless_endpoint.PrepareAsync()


        """
        return _byteblower.WirelessEndpoint_PrepareAsync(self)


    def Start(self):
        """

        Start.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	wirelessEndpoint.Start()


        """
        return _byteblower.WirelessEndpoint_Start(self)


    def StartAsync(self):
        """

        Start without waiting for confirmation.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	wirelessEndpoint.StartAsync()


        """
        return _byteblower.WirelessEndpoint_StartAsync(self)


    def Stop(self):
        """

        Signal the Wireless Endpoint to stop the scenario.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	wirelessEndpoint.Stop()


        """
        return _byteblower.WirelessEndpoint_Stop(self)


    def StopAsync(self):
        """

        Signal the Wireless Endpoint to stop the scenario, but do not wait for confirmation.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	wirelessEndpoint.StopAsync()


        """
        return _byteblower.WirelessEndpoint_StopAsync(self)


    def ResultGet(self):
        """

        Request the results.

        Requests the result and waits for the reply. If a previous call to Request.Async was made then this call does not trigger a new request and instead waits for the async result.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(wirelessEndpoint.ResultGet())


        """
        return _byteblower.WirelessEndpoint_ResultGet(self)


    def ResultAsyncGet(self):
        """

        Request the results without waiting for the reply.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           from byteblowerll.byteblower import ByteBlower
           server = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
           # ...
           # :return: TODO


        """
        return _byteblower.WirelessEndpoint_ResultAsyncGet(self)


    def ResultClear(self):
        """

        Clear the result list on the device.

        TODO: does this affect the result snapshots too?

        Example

        .. code-block:: python
           :emphasize-lines: 1

           device.ResultClear()

        """
        return _byteblower.WirelessEndpoint_ResultClear(self)


    def StatusGet(self):
        """

        Returns the device status.

        :return: :class:`.DeviceStatus`

        Example

        .. code-block:: python
           :emphasize-lines: 1

            print(wirelessEndpoint.StatusGet())


        """
        return _byteblower.WirelessEndpoint_StatusGet(self)


    def ScenarioDurationGet(self):
        return _byteblower.WirelessEndpoint_ScenarioDurationGet(self)

    def ScenarioDurationSet(self, arg2):
        return _byteblower.WirelessEndpoint_ScenarioDurationSet(self, arg2)

    def ScenarioHeartbeatIntervalGet(self):
        """

        Returns the heartbeat interval used while running a scenario.

        Default value is 10 seconds.  Setting it to a large value means disabled.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           print(self.wireless_endpoint.ScenarioHeartbeatIntervalGet())


        """
        return _byteblower.WirelessEndpoint_ScenarioHeartbeatIntervalGet(self)


    def ScenarioHeartbeatIntervalSet(self, arg2):
        """

        Sets the heartbeat interval to be used when a scenario is running.

        The allowed value range is 0 (disabled, default) and maximum 86400000000000 (1 day).

        When a value is below the minimum value supported by a specific Endpoint device, the supported value is taken.
        When a value is above the upper threshold of 1 day, 1 day will be used.

        .. note:: A value of max int64 (9223372036854775807) will disable heartbeating during scenarios.  From 2.22.0 on, this value will be a normal valid value.

        Example

        .. code-block:: python
           :emphasize-lines: 1

           self.wireless_endpoint.ScenarioHeartbeatIntervalSet(50000000000)


        """
        return _byteblower.WirelessEndpoint_ScenarioHeartbeatIntervalSet(self, arg2)

WirelessEndpoint_swigregister = _byteblower.WirelessEndpoint_swigregister
WirelessEndpoint_swigregister(WirelessEndpoint)

class MeetingPointList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MeetingPointList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MeetingPointList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.MeetingPointList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.MeetingPointList___nonzero__(self)

    def __bool__(self):
        return _byteblower.MeetingPointList___bool__(self)

    def __len__(self):
        return _byteblower.MeetingPointList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.MeetingPointList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.MeetingPointList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.MeetingPointList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.MeetingPointList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.MeetingPointList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.MeetingPointList___setitem__(self, *args)

    def pop(self):
        return _byteblower.MeetingPointList_pop(self)

    def append(self, x):
        return _byteblower.MeetingPointList_append(self, x)

    def empty(self):
        return _byteblower.MeetingPointList_empty(self)

    def size(self):
        return _byteblower.MeetingPointList_size(self)

    def swap(self, v):
        return _byteblower.MeetingPointList_swap(self, v)

    def begin(self):
        return _byteblower.MeetingPointList_begin(self)

    def end(self):
        return _byteblower.MeetingPointList_end(self)

    def rbegin(self):
        return _byteblower.MeetingPointList_rbegin(self)

    def rend(self):
        return _byteblower.MeetingPointList_rend(self)

    def clear(self):
        return _byteblower.MeetingPointList_clear(self)

    def get_allocator(self):
        return _byteblower.MeetingPointList_get_allocator(self)

    def pop_back(self):
        return _byteblower.MeetingPointList_pop_back(self)

    def erase(self, *args):
        return _byteblower.MeetingPointList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_MeetingPointList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.MeetingPointList_push_back(self, x)

    def front(self):
        return _byteblower.MeetingPointList_front(self)

    def back(self):
        return _byteblower.MeetingPointList_back(self)

    def assign(self, n, x):
        return _byteblower.MeetingPointList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.MeetingPointList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.MeetingPointList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.MeetingPointList_reserve(self, n)

    def capacity(self):
        return _byteblower.MeetingPointList_capacity(self)
    __swig_destroy__ = _byteblower.delete_MeetingPointList
    __del__ = lambda self: None
MeetingPointList_swigregister = _byteblower.MeetingPointList_swigregister
MeetingPointList_swigregister(MeetingPointList)

class WirelessEndpointList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, WirelessEndpointList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, WirelessEndpointList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.WirelessEndpointList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.WirelessEndpointList___nonzero__(self)

    def __bool__(self):
        return _byteblower.WirelessEndpointList___bool__(self)

    def __len__(self):
        return _byteblower.WirelessEndpointList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.WirelessEndpointList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.WirelessEndpointList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.WirelessEndpointList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.WirelessEndpointList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.WirelessEndpointList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.WirelessEndpointList___setitem__(self, *args)

    def pop(self):
        return _byteblower.WirelessEndpointList_pop(self)

    def append(self, x):
        return _byteblower.WirelessEndpointList_append(self, x)

    def empty(self):
        return _byteblower.WirelessEndpointList_empty(self)

    def size(self):
        return _byteblower.WirelessEndpointList_size(self)

    def swap(self, v):
        return _byteblower.WirelessEndpointList_swap(self, v)

    def begin(self):
        return _byteblower.WirelessEndpointList_begin(self)

    def end(self):
        return _byteblower.WirelessEndpointList_end(self)

    def rbegin(self):
        return _byteblower.WirelessEndpointList_rbegin(self)

    def rend(self):
        return _byteblower.WirelessEndpointList_rend(self)

    def clear(self):
        return _byteblower.WirelessEndpointList_clear(self)

    def get_allocator(self):
        return _byteblower.WirelessEndpointList_get_allocator(self)

    def pop_back(self):
        return _byteblower.WirelessEndpointList_pop_back(self)

    def erase(self, *args):
        return _byteblower.WirelessEndpointList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_WirelessEndpointList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.WirelessEndpointList_push_back(self, x)

    def front(self):
        return _byteblower.WirelessEndpointList_front(self)

    def back(self):
        return _byteblower.WirelessEndpointList_back(self)

    def assign(self, n, x):
        return _byteblower.WirelessEndpointList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.WirelessEndpointList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.WirelessEndpointList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.WirelessEndpointList_reserve(self, n)

    def capacity(self):
        return _byteblower.WirelessEndpointList_capacity(self)
    __swig_destroy__ = _byteblower.delete_WirelessEndpointList
    __del__ = lambda self: None
WirelessEndpointList_swigregister = _byteblower.WirelessEndpointList_swigregister
WirelessEndpointList_swigregister(WirelessEndpointList)

class CapabilityValue(AbstractObject):
    """

    The Capability Value class.

    A capability ( Capability ) can have a different type of value (INTEGER,
    BOOLEAN, STRING). Using :meth:`TypeGet` you can discover the value-type and
    then use the corresponding getter to get the real value


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, CapabilityValue, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, CapabilityValue, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    Type_BOOLEAN = _byteblower.CapabilityValue_Type_BOOLEAN
    Type_INTEGER = _byteblower.CapabilityValue_Type_INTEGER
    Type_STRING = _byteblower.CapabilityValue_Type_STRING

    def StringGet(self):
        """

        Returns the value as a string.

        :return: The capability value as a string
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 7

            capabilityType = capabilityValue.TypeGet()
            if capabilityType==0:
                print(capabilityValue.BooleanGet())
            elif capabilityType==1:
                print(capabilityValue.IntegerGet())
            else:
                print(capabilityValue.StringGet())


        """
        return _byteblower.CapabilityValue_StringGet(self)


    def IntegerGet(self):
        """

        Returns the value as an integer.

        :return: The value of the capability as an integer
        :rtype: long

        Example

        .. code-block:: python
           :emphasize-lines: 5

            capabilityType = capabilityValue.TypeGet()
            if capabilityType==0:
                print(capabilityValue.BooleanGet())
            elif capabilityType==1:
                print(capabilityValue.IntegerGet())
            else:
                print(capabilityValue.StringGet())

        """
        return _byteblower.CapabilityValue_IntegerGet(self)


    def BooleanGet(self):
        """

        Returns the value as a boolean.

        :return: The value of the capability as a boolean (if possible)
        :rtype: bool

        Example

        .. code-block:: python
           :emphasize-lines: 3

            capabilityType = capabilityValue.TypeGet()
            if capabilityType==0:
                print(capabilityValue.BooleanGet())
            elif capabilityType==1:
                print(capabilityValue.IntegerGet())
            else:
                print(capabilityValue.StringGet())

        """
        return _byteblower.CapabilityValue_BooleanGet(self)


    def TypeGet(self):
        """

        Returns the type of value.

        :return: The type of the value
        :rtype: TODO

        Example

        .. code-block:: python
           :emphasize-lines: 1

            capabilityType = capabilityValue.TypeGet()
            if capabilityType==0:
                print(capabilityValue.BooleanGet())
            elif capabilityType==1:
                print(capabilityValue.IntegerGet())
            else:
                print(capabilityValue.StringGet())

        """
        return _byteblower.CapabilityValue_TypeGet(self)

CapabilityValue_swigregister = _byteblower.CapabilityValue_swigregister
CapabilityValue_swigregister(CapabilityValue)


def __lshift__(stream, type):
    return _byteblower.__lshift__(stream, type)
__lshift__ = _byteblower.__lshift__
class Capability(AbstractObject):
    """

    Represents a capability, A feature it supports or not.

    Using this class, you can check if e.g. a WirelessEndpoint supports latency
    measurements or not

    Available Capabilities:
    - TODO
    - TODO

    Example

    .. code-block:: python
       :emphasize-lines: 3

    	from byteblowerll.byteblower import ByteBlower
    	server = ByteBlower.ServerAdd('byteblower-1.lab.byteblower.com')
    	port = server.PortCreate('trunk-1-1')
    	capability_list = port.CapabilityListGet()
    	capability = capability_list[0]
    	# print version
    	print(capability.VersionAddedGet())

    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Capability, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Capability, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _byteblower.delete_Capability
    __del__ = lambda self: None

    def NameGet(self):
        """

        Returns a human-readable name of the capability.

        :return: The human readable name of the capability.
        :rtype str:

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(capability.NameGet())

        """
        return _byteblower.Capability_NameGet(self)


    def CapabilityDescriptionGet(self):
        """

        Returns a human-readable description of the capability.

        :return: A human readable description
        :rtype: str

        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	print(capability.CapabilityDescriptionGet())

        """
        return _byteblower.Capability_CapabilityDescriptionGet(self)


    def VersionAddedGet(self):
        """

        Returns the ByteBlower Server/ByteBlower MeetingPoint version since when this
        capability is added.

        :return: The server/meetingpoint version the capability was added
        :rtype: string

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(capability.VersionAddedGet())

        """
        return _byteblower.Capability_VersionAddedGet(self)


    def ValueGet(self):
        """

        Returns a CapabilityValue object.

        :return: the value of the capability
        :rtype: :class:`.CapabilityValue`


        Example

        .. code-block:: python
        	:emphasize-lines: 1

        	capabilityValue = capability.ValueGet()

        """
        return _byteblower.Capability_ValueGet(self)

Capability_swigregister = _byteblower.Capability_swigregister
Capability_swigregister(Capability)

DeviceOsType_Android = _byteblower.DeviceOsType_Android
DeviceOsType_iOS = _byteblower.DeviceOsType_iOS
DeviceOsType_OSx = _byteblower.DeviceOsType_OSx
DeviceOsType_Linux = _byteblower.DeviceOsType_Linux
DeviceOsType_Windows = _byteblower.DeviceOsType_Windows
DeviceOsType_Unknown = _byteblower.DeviceOsType_Unknown
class DeviceInfo(AbstractObject):
    """

    Device information of the wireless endpoint.

    Contains all usefull device information of a wireless endpoint like OS,
    Network, Battery etc...

    .. versionadded:: 2.6.0

    Example

    .. code-block:: python
       :emphasize-lines: 4

       from byteblowerll.byteblower import ByteBlower
       meetingPoint = bb.MeetingPointAdd('byteblower-tutorial-1300.lab.byteblower.excentis.com')
       weDevice = meetingPoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
       deviceInfo = weDevice.DeviceInfoGet()
       print(deviceInfo.BatteryLevelGet())

    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DeviceInfo, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DeviceInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def BatteryLevelGet(self):
        """

        Returns the device's battery level.

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = weDevice.DeviceInfoGet()
           print(deviceInfo.BatteryLevelGet())

        """
        return _byteblower.DeviceInfo_BatteryLevelGet(self)


    def GivenNameGet(self):
        """

        Returns the user-provided device name.

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = weDevice.DeviceInfoGet()
           print(deviceInfo.GivenNameGet())

        """
        return _byteblower.DeviceInfo_GivenNameGet(self)


    def TypeGet(self):
        """

        Returns the type of device. I.e "iPad Air", "iPhone 6S", "Nexus 5x",
        etc...

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = weDevice.DeviceInfoGet()
           print(deviceInfo.TypeGet())

        """
        return _byteblower.DeviceInfo_TypeGet(self)


    def OsTypeGet(self):
        """

        Returns the OS type.

        :return: :class:`.DeviceOsType`

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = weDevice.DeviceInfoGet()
           print(deviceInfo.OsTypeGet())

        """
        return _byteblower.DeviceInfo_OsTypeGet(self)


    def NetworkInfoGet(self):
        """

        Return the networkInfoObject containing all the network information of the Wireless Endpoint.

        :return: :class:`.NetworkInfo`

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = weDevice.DeviceInfoGet()
           networkInfo = weDevice.NetworkInfoGet()

        """
        return _byteblower.DeviceInfo_NetworkInfoGet(self)


    def NetworkInfoMonitorAdd(self):
        """

        Creates a NetworkInfo monitor to be used during a scenario

        A NetworkInfo monitor collects information about the network interfaces using
        the typical history objects

        :return: The newly created NetworkInfoMonitor
        :rtype: :class:`.NetworkInfoMonitor`

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = weDevice.DeviceInfoGet()
           monitor = weDevice.NetworkInfoMonitorAdd()

        """
        return _byteblower.DeviceInfo_NetworkInfoMonitorAdd(self)


    def NetworkInfoMonitorGet(self):
        """

        Get the created NetworkInfo monitors

        A NetworkInfo monitor collects information about the network interfaces using
        the typical history objects

        :return: A list of NetworkInfoMonitors
        :rtype: :class:`.NetworkInfoMonitorList`

        Example

        .. code-block:: python
           :emphasize-lines: 3

           deviceInfo = weDevice.DeviceInfoGet()
           monitor = weDevice.NetworkInfoMonitorAdd()
           monitors = weDevice.NetworkInfoMonitorGet()

        """
        return _byteblower.DeviceInfo_NetworkInfoMonitorGet(self)


    def NetworkInfoMonitorRemove(self, arg2):
        """

        Removes the specified NetworkInfoMonitor

        A NetworkInfo monitor collects information about the network interfaces using
        the typical history objects

        :param monitor: The monitor to be removed
        :type monitor: :class:`.NetworkInfoMonitor`

        Example

        .. code-block:: python
           :emphasize-lines: 3

           deviceInfo = weDevice.DeviceInfoGet()
           monitor = weDevice.NetworkInfoMonitorAdd()
           weDevice.NetworkInfoMonitorRemove(monitor)

        """
        return _byteblower.DeviceInfo_NetworkInfoMonitorRemove(self, arg2)


    def OsVersionGet(self):
        """

        Returns the OS version.

        Example

        .. code-block:: python
           :emphasize-lines: 2

           deviceInfo = weDevice.DeviceInfoGet()
           print(deviceInfo.OsVersionGet())

        """
        return _byteblower.DeviceInfo_OsVersionGet(self)

DeviceInfo_swigregister = _byteblower.DeviceInfo_swigregister
DeviceInfo_swigregister(DeviceInfo)

class NetworkInfo(AbstractObject):
    """

    Network information of the wireless endpoint.

    Contains all usefull network information of a wireless endpoint

    .. versionadded:: 2.6.0

    Example

    .. code-block:: python
       :emphasize-lines: 5

       from byteblowerll.byteblower import ByteBlower
       meetingpoint = ByteBlower.MeetingPointAdd('byteblower-1.lab.byteblower.com')
       wirelessendpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
       deviceInfo = wirelessendpoint.DeviceInfoGet()
       networkInfo = deviceInfo.NetworkInfoGet()

    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NetworkInfo, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NetworkInfo, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def InterfaceGet(self):
        """

        Returns a list of NetworkInterfaces 

        This list contains all the NetworkInterfaces detected on the device.
        Be aware that their are more networkinterfaces than you would expect.

        :return: :class:`.NetworkInterfaceList`

        Example

        .. code-block:: python
           :emphasize-lines: 4

           wirelessendpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
           deviceInfo = wirelessendpoint.DeviceInfoGet()
           networkInfo = deviceInfo.NetworkInfoGet()
           print(networkInfo.InterfaceGet()[0].NameGet())


        """
        return _byteblower.NetworkInfo_InterfaceGet(self)


    def IPv4Get(self):
        """

        Returns a list of IPv4 addresses.

        This is a convenient method that will return the list of IPv4 addresses of the
        first interface. If you want the IP of a specific interface use the
        :meth:`InterfaceGet` method to retrieve them.

        Example

        .. code-block:: python
           :emphasize-lines: 4

           wirelessendpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
           deviceInfo = wirelessendpoint.DeviceInfoGet()
           networkInfo = deviceInfo.NetworkInfoGet()
           print(networkInfo.IPv4Get()[0])



        """
        return _byteblower.NetworkInfo_IPv4Get(self)


    def IPv6GlobalGet(self):
        """

        Returns a list of IPv6 global addresses.

        Example

        .. code-block:: python
           :emphasize-lines: 4

           wirelessendpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
           deviceInfo = wirelessendpoint.DeviceInfoGet()
           networkInfo = deviceInfo.NetworkInfoGet()
           print(networkInfo.IPv6GlobalGet()[0])


        """
        return _byteblower.NetworkInfo_IPv6GlobalGet(self)


    def IPv6LinkLocalGet(self):
        """

        Returns a list of IPv6 linklocal addresses.

        This is a convenient method to get a list of the IPv6 linkLocal addresses.
        If your WE has 2 active interfaces, only the first will be returned. You
        can use :meth:`InterfaceGet` to retrieve the interfaces

        Example

        .. code-block:: python
           :emphasize-lines: 4

           wirelessendpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
           deviceInfo = wirelessendpoint.DeviceInfoGet()
           networkInfo = deviceInfo.NetworkInfoGet()
           print(networkInfo.IPv6LinkLocalGet()[0])



        """
        return _byteblower.NetworkInfo_IPv6LinkLocalGet(self)


    def SSIDGet(self):
        """

        Returns the SSID

        This is the first SSID discoverd by the wireless endpoint. If your device has
        more than 1 connected wireless interface. One of these will be shown here

        If you want to see the others, please use :meth:`InterfaceGet`

        Example

        .. code-block:: python
           :emphasize-lines: 4

           wirelessendpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
           deviceInfo = wirelessendpoint.DeviceInfoGet()
           networkInfo = deviceInfo.NetworkInfoGet()
           print(networkInfo.SSIDGet())



        """
        return _byteblower.NetworkInfo_SSIDGet(self)


    def BSSIDGet(self):
        """

        Returns the BSSID

        This is the first BSSID discoverd by the wireless endpoint. If your device has
        more than 1 connected wireless interface. One of these will be shown here

        If you want to see the others, please use :meth:`InterfaceGet`

        Example

        .. code-block:: python
           :emphasize-lines: 4

           wirelessendpoint = meetingpoint.DeviceGet('5D96F1C6-AAF3-43E3-9816-5DFAC1D2E812')
           deviceInfo = wirelessendpoint.DeviceInfoGet()
           networkInfo = deviceInfo.NetworkInfoGet()
           print(networkInfo.BSSIDGet())



        """
        return _byteblower.NetworkInfo_BSSIDGet(self)

NetworkInfo_swigregister = _byteblower.NetworkInfo_swigregister
NetworkInfo_swigregister(NetworkInfo)

class NetworkInfoMonitorResultData(AbstractObject):
    """

    Result snapshot for the network information.

    .. versionadded:: 2.11.0

    Example

    .. code-block:: python


    	deviceInfo = self.wireless_endpoint.DeviceInfoGet()
    	monitor = deviceInfo.NetworkInfoMonitorAdd()
    	history = monitor.ResultHistoryGet()
    	for item in history.IntervalGet():
    	    print(item.DescriptionGet())


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NetworkInfoMonitorResultData, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NetworkInfoMonitorResultData, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TimestampGet(self):
        """

        Time in nanoseconds when the data was retrieved


        :return: Timestamp
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

                print(interval.TimestampGet())


        """
        return _byteblower.NetworkInfoMonitorResultData_TimestampGet(self)


    def InterfaceGet(self):
        """

        Returns a list of network interfaces available on the device


        :return: List of network interfaces
        :rtype: :class:`.NetworkInterfaceList`

        Example

        .. code-block:: python
           :emphasize-lines: 1,3

                interfaces = interval.InterfacesGet()
                for interface in interfaces:
                    print(interface.DescriptionGet()


        """
        return _byteblower.NetworkInfoMonitorResultData_InterfaceGet(self)


    def IntervalDurationGet(self):
        """

        Duration in nanoseconds of the interval


        :return: Duration in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

                print(interval.IntervalDurationGet())


        """
        return _byteblower.NetworkInfoMonitorResultData_IntervalDurationGet(self)

NetworkInfoMonitorResultData_swigregister = _byteblower.NetworkInfoMonitorResultData_swigregister
NetworkInfoMonitorResultData_swigregister(NetworkInfoMonitorResultData)

class NetworkInfoMonitorResultList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NetworkInfoMonitorResultList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NetworkInfoMonitorResultList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.NetworkInfoMonitorResultList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.NetworkInfoMonitorResultList___nonzero__(self)

    def __bool__(self):
        return _byteblower.NetworkInfoMonitorResultList___bool__(self)

    def __len__(self):
        return _byteblower.NetworkInfoMonitorResultList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.NetworkInfoMonitorResultList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.NetworkInfoMonitorResultList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.NetworkInfoMonitorResultList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.NetworkInfoMonitorResultList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.NetworkInfoMonitorResultList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.NetworkInfoMonitorResultList___setitem__(self, *args)

    def pop(self):
        return _byteblower.NetworkInfoMonitorResultList_pop(self)

    def append(self, x):
        return _byteblower.NetworkInfoMonitorResultList_append(self, x)

    def empty(self):
        return _byteblower.NetworkInfoMonitorResultList_empty(self)

    def size(self):
        return _byteblower.NetworkInfoMonitorResultList_size(self)

    def swap(self, v):
        return _byteblower.NetworkInfoMonitorResultList_swap(self, v)

    def begin(self):
        return _byteblower.NetworkInfoMonitorResultList_begin(self)

    def end(self):
        return _byteblower.NetworkInfoMonitorResultList_end(self)

    def rbegin(self):
        return _byteblower.NetworkInfoMonitorResultList_rbegin(self)

    def rend(self):
        return _byteblower.NetworkInfoMonitorResultList_rend(self)

    def clear(self):
        return _byteblower.NetworkInfoMonitorResultList_clear(self)

    def get_allocator(self):
        return _byteblower.NetworkInfoMonitorResultList_get_allocator(self)

    def pop_back(self):
        return _byteblower.NetworkInfoMonitorResultList_pop_back(self)

    def erase(self, *args):
        return _byteblower.NetworkInfoMonitorResultList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_NetworkInfoMonitorResultList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.NetworkInfoMonitorResultList_push_back(self, x)

    def front(self):
        return _byteblower.NetworkInfoMonitorResultList_front(self)

    def back(self):
        return _byteblower.NetworkInfoMonitorResultList_back(self)

    def assign(self, n, x):
        return _byteblower.NetworkInfoMonitorResultList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.NetworkInfoMonitorResultList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.NetworkInfoMonitorResultList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.NetworkInfoMonitorResultList_reserve(self, n)

    def capacity(self):
        return _byteblower.NetworkInfoMonitorResultList_capacity(self)
    __swig_destroy__ = _byteblower.delete_NetworkInfoMonitorResultList
    __del__ = lambda self: None
NetworkInfoMonitorResultList_swigregister = _byteblower.NetworkInfoMonitorResultList_swigregister
NetworkInfoMonitorResultList_swigregister(NetworkInfoMonitorResultList)

class NetworkInfoMonitorResultHistory(AbstractRefreshableResult):
    """

    History for the network info monitor representing the results over time

    .. versionadded:: 2.11.0

    Example

    .. code-block:: python


    	deviceInfo = self.wireless_endpoint.DeviceInfoGet()
    	networkInfo = deviceInfo.NetworkInfoMonitorAdd()
    	history = networkInfo.ResultHistoryGet()
    	print(history.DescriptionGet())


    """

    __swig_setmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NetworkInfoMonitorResultHistory, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractRefreshableResult]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NetworkInfoMonitorResultHistory, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Clear(self):
        """

        Clears all results of the monitor


        Example

        .. code-block:: python
           :emphasize-lines: 1

        	history.Clear()


        """
        return _byteblower.NetworkInfoMonitorResultHistory_Clear(self)


    def SamplingIntervalDurationGet(self):
        """

        Returns the duration of one result interval

        :return: The duration in nanoseconds
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(history.SamplingIntervalDurationGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_SamplingIntervalDurationGet(self)


    def SamplingIntervalDurationSet(self, inDuration):
        """

        Sets the duration of one result interval

        :param duration: The duration in nanoseconds (default: 1 second)
        :type duration: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	history.SamplingIntervalDurationSet(2000000000)


        """
        return _byteblower.NetworkInfoMonitorResultHistory_SamplingIntervalDurationSet(self, inDuration)


    def IntervalGet(self):
        """

        Returns the collected intervals

        :return: A list of the collected intervals
        :rtype: :class:`NetworkInfoMonitorResultList`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	history.Refresh()
        	for interval in history.IntervalGet():
        	    print(interval.DescriptionGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_IntervalGet(self)


    def IntervalGetByIndex(self, index):
        """

        Return an interval as specified by the index in the list

        :param index: number of the index in the list
        :type index: int

        :raises: :exc:`.ConfigError` - When the index is out of range

        :return: The specified interval snapshot
        :rtype: :class:`NetworkInfoMonitorResultData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	history.Refresh()
        	interval = history.IntervalGetByIndex(1):
                print(interval.DescriptionGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_IntervalGetByIndex(self, index)


    def IntervalGetByTime(self, timestamp):
        """

        Return an interval as specified by the timestamp it was created

        :param timestamp: A timestamp in nanoseconds rounded to the second
        :type index: int

        :raises: :exc:`.ConfigError` - When the timestamp is out of range

        :return: The specified interval snapshot
        :rtype: :class:`NetworkInfoMonitorResultData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	history.Refresh()
        	interval = history.IntervalGetByTime(1568194819000000000):
                print(interval.DescriptionGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_IntervalGetByTime(self, timestamp)


    def IntervalLatestGet(self):
        """

        Return the last interval snapshot created

        :return: The specified interval snapshot
        :rtype: :class:`NetworkInfoMonitorResultData`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	history.Refresh()
        	interval = history.IntervalLatestGet():
                print(interval.DescriptionGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_IntervalLatestGet(self)


    def IntervalLengthGet(self):
        """

        Returns the number of collected interval snapshots


        :return: number of interval snapshots
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	history.Refresh()
                print(history.IntervalLengthGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_IntervalLengthGet(self)


    def RefreshTimestampGet(self):
        """

        Time in nanoseconds when the data was last retrieved


        :return: Timestamp
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	history.Refresh()
                print(history.RefreshTimestampGet())


        """
        return _byteblower.NetworkInfoMonitorResultHistory_RefreshTimestampGet(self)

NetworkInfoMonitorResultHistory_swigregister = _byteblower.NetworkInfoMonitorResultHistory_swigregister
NetworkInfoMonitorResultHistory_swigregister(NetworkInfoMonitorResultHistory)

class NetworkInfoMonitor(AbstractObject):
    """

    Monitor to collect the NetworkInfo over time

    .. versionadded:: 2.11.0

    Example

    .. code-block:: python


    	deviceInfo = self.wireless_endpoint.DeviceInfoGet()
    	networkInfo = deviceInfo.NetworkInfoMonitorAdd()


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NetworkInfoMonitor, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NetworkInfoMonitor, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def ResultHistoryGet(self):
        """

        Returns the result history of the network monitor

        :return: The history object for the network monitor
        :rtype: :class:`.NetworkInfoMonitorResultHistory`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(monitor.ResultHistoryGet().DescriptionGet())


        """
        return _byteblower.NetworkInfoMonitor_ResultHistoryGet(self)

NetworkInfoMonitor_swigregister = _byteblower.NetworkInfoMonitor_swigregister
NetworkInfoMonitor_swigregister(NetworkInfoMonitor)

NetworkInterfaceType_Unknown = _byteblower.NetworkInterfaceType_Unknown
NetworkInterfaceType_Loopback = _byteblower.NetworkInterfaceType_Loopback
NetworkInterfaceType_Ethernet = _byteblower.NetworkInterfaceType_Ethernet
NetworkInterfaceType_WiFi = _byteblower.NetworkInterfaceType_WiFi

def NetworkInterfaceTypeToString(t):
    return _byteblower.NetworkInterfaceTypeToString(t)
NetworkInterfaceTypeToString = _byteblower.NetworkInterfaceTypeToString
class NetworkInterface(AbstractObject):
    """

    NetworkInterface information of the wireless endpoint.

    Represents a network interface of a wireless endpoint.

    .. versionadded:: 2.6.0

    Example

    .. code-block:: python


    	deviceInfo = self.wireless_endpoint.DeviceInfoGet()
    	etworkInfo = deviceInfo.NetworkInfoGet()
    	networkInterface = networkInfo.InterfaceGet()[0]


    """

    __swig_setmethods__ = {}
    for _s in [AbstractObject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NetworkInterface, name, value)
    __swig_getmethods__ = {}
    for _s in [AbstractObject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NetworkInterface, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def TypeGet(self):
        """

        Returns the type of a network interface.

        This can be used to distinguish e.g. WiFi interfaces from others

        :return: The type of the network interface
        :rtype: :class:`.NetworkInterfaceType`

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.TypeGet() == NetworkInterfaceType.WiFi)

        """
        return _byteblower.NetworkInterface_TypeGet(self)


    def NameGet(self):
        """


        Returns the name of the interface.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.NameGet())



        """
        return _byteblower.NetworkInterface_NameGet(self)


    def DisplayNameGet(self):
        """

        Returns the display name of the interface.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.DisplayNameGet())



        """
        return _byteblower.NetworkInterface_DisplayNameGet(self)


    def MacGet(self):
        """

        Returns the mac-address of the interface.

        On some platforms (e.g. iOS) this isn't allowed so a fake address will be
        returned.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.MacGet())



        """
        return _byteblower.NetworkInterface_MacGet(self)


    def IPv4Get(self):
        """

        Returns a list of IPv4 addresses of this interface.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.IPv4Get())



        """
        return _byteblower.NetworkInterface_IPv4Get(self)


    def IPv6GlobalGet(self):
        """

        Returns a list of the Global IPv6 addresses of this interface.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.IPv6GlobalGet())



        """
        return _byteblower.NetworkInterface_IPv6GlobalGet(self)


    def IPv6LinkLocalGet(self):
        """

        Returns a list of the LinkLocal addresses of this interface.

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.IPv6LinkLocalGet())



        """
        return _byteblower.NetworkInterface_IPv6LinkLocalGet(self)


    def WiFiSsidGet(self):
        """

        Returns the SSID of the current WiFi connection

        When the interface is not a WiFi interface or when the interface is not 
        connected to a wireless network, the method will return an empty string

        :return: The SSID of the network interface
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.WiFiSsidGet())
        	# Prints e.g. MyFavoriteNetwork

        """
        return _byteblower.NetworkInterface_WiFiSsidGet(self)


    def WiFiBssidGet(self):
        """

        Returns the BSSID of the current WiFi connection

        When the interface is not a WiFi interface or when the interface is not 
        connected to a wireless network, the method will return an empty string

        :return: The BSSID of the network interface in colon-delimited format
        :rtype: str

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.WiFiBssidGet())
        	# prints e.g. 00:bb:1b:00:12:22

        """
        return _byteblower.NetworkInterface_WiFiBssidGet(self)


    def WiFiRssiGet(self):
        """

        Returns the RSSI of the current WiFi connection

        When the interface is not a WiFi interface or when the interface is not 
        connected to a wireless network, the method will return -127

        :return: The RSSI of the network interface in dBm
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.WiFiRssiGet())
        	# prints e.g. -67

        """
        return _byteblower.NetworkInterface_WiFiRssiGet(self)


    def WiFiTxRateGet(self):
        """

        Returns the announced maximum transmit speed of the current WiFi connection

        When the interface is not a WiFi interface or when the interface is not 
        connected to a wireless network, the method will return -1

        :return: The maximum transmit speed of the network interface in bits/s
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.WiFiTxRateGet())
        	# prints e.g. 54000000

        """
        return _byteblower.NetworkInterface_WiFiTxRateGet(self)


    def WiFiRxRateGet(self):
        """

        Returns the announced maximum receive speed of the current WiFi connection

        When the interface is not a WiFi interface or when the interface is not 
        connected to a wireless network, the method will return -1

        :return: The maximum receive speed of the network interface in bits/s
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.WiFiRxRateGet())
        	# prints e.g. 54000000

        """
        return _byteblower.NetworkInterface_WiFiRxRateGet(self)


    def WiFiChannelGet(self):
        """

        Returns the channel of the current WiFi connection

        When the interface is not a WiFi interface or when the interface is not 
        connected to a wireless network, the method will return -1

        :return: The channel of the network interface
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.WiFiChannelGet())
        	# prints e.g. 9

        """
        return _byteblower.NetworkInterface_WiFiChannelGet(self)


    def SpeedGet(self):
        """

        Returns the announced maximum speed of the interface

        When the interface is down or does not have a link speed, this method will 
        return -1.

        If the interface is a WiFi interface with an active connection, the transmit
        speed as given by WiFiTxRateGet() will be returned.

        :return: The link speed of the network interface in bits/s
        :rtype: int

        Example

        .. code-block:: python
           :emphasize-lines: 1

        	print(networkInterface.SpeedGet())
        	# prints e.g. 1000000000

        """
        return _byteblower.NetworkInterface_SpeedGet(self)

NetworkInterface_swigregister = _byteblower.NetworkInterface_swigregister
NetworkInterface_swigregister(NetworkInterface)

class NetworkInterfaceList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, NetworkInterfaceList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, NetworkInterfaceList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.NetworkInterfaceList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.NetworkInterfaceList___nonzero__(self)

    def __bool__(self):
        return _byteblower.NetworkInterfaceList___bool__(self)

    def __len__(self):
        return _byteblower.NetworkInterfaceList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.NetworkInterfaceList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.NetworkInterfaceList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.NetworkInterfaceList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.NetworkInterfaceList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.NetworkInterfaceList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.NetworkInterfaceList___setitem__(self, *args)

    def pop(self):
        return _byteblower.NetworkInterfaceList_pop(self)

    def append(self, x):
        return _byteblower.NetworkInterfaceList_append(self, x)

    def empty(self):
        return _byteblower.NetworkInterfaceList_empty(self)

    def size(self):
        return _byteblower.NetworkInterfaceList_size(self)

    def swap(self, v):
        return _byteblower.NetworkInterfaceList_swap(self, v)

    def begin(self):
        return _byteblower.NetworkInterfaceList_begin(self)

    def end(self):
        return _byteblower.NetworkInterfaceList_end(self)

    def rbegin(self):
        return _byteblower.NetworkInterfaceList_rbegin(self)

    def rend(self):
        return _byteblower.NetworkInterfaceList_rend(self)

    def clear(self):
        return _byteblower.NetworkInterfaceList_clear(self)

    def get_allocator(self):
        return _byteblower.NetworkInterfaceList_get_allocator(self)

    def pop_back(self):
        return _byteblower.NetworkInterfaceList_pop_back(self)

    def erase(self, *args):
        return _byteblower.NetworkInterfaceList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_NetworkInterfaceList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.NetworkInterfaceList_push_back(self, x)

    def front(self):
        return _byteblower.NetworkInterfaceList_front(self)

    def back(self):
        return _byteblower.NetworkInterfaceList_back(self)

    def assign(self, n, x):
        return _byteblower.NetworkInterfaceList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.NetworkInterfaceList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.NetworkInterfaceList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.NetworkInterfaceList_reserve(self, n)

    def capacity(self):
        return _byteblower.NetworkInterfaceList_capacity(self)
    __swig_destroy__ = _byteblower.delete_NetworkInterfaceList
    __del__ = lambda self: None
NetworkInterfaceList_swigregister = _byteblower.NetworkInterfaceList_swigregister
NetworkInterfaceList_swigregister(NetworkInterfaceList)

class Stats(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Stats, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Stats, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.Stats_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.Stats___nonzero__(self)

    def __bool__(self):
        return _byteblower.Stats___bool__(self)

    def __len__(self):
        return _byteblower.Stats___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _byteblower.Stats___getitem__(self, key)

    def __delitem__(self, key):
        return _byteblower.Stats___delitem__(self, key)

    def has_key(self, key):
        return _byteblower.Stats_has_key(self, key)

    def keys(self):
        return _byteblower.Stats_keys(self)

    def values(self):
        return _byteblower.Stats_values(self)

    def items(self):
        return _byteblower.Stats_items(self)

    def __contains__(self, key):
        return _byteblower.Stats___contains__(self, key)

    def key_iterator(self):
        return _byteblower.Stats_key_iterator(self)

    def value_iterator(self):
        return _byteblower.Stats_value_iterator(self)

    def __setitem__(self, *args):
        return _byteblower.Stats___setitem__(self, *args)

    def asdict(self):
        return _byteblower.Stats_asdict(self)

    def __init__(self, *args):
        this = _byteblower.new_Stats(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self):
        return _byteblower.Stats_empty(self)

    def size(self):
        return _byteblower.Stats_size(self)

    def swap(self, v):
        return _byteblower.Stats_swap(self, v)

    def begin(self):
        return _byteblower.Stats_begin(self)

    def end(self):
        return _byteblower.Stats_end(self)

    def rbegin(self):
        return _byteblower.Stats_rbegin(self)

    def rend(self):
        return _byteblower.Stats_rend(self)

    def clear(self):
        return _byteblower.Stats_clear(self)

    def get_allocator(self):
        return _byteblower.Stats_get_allocator(self)

    def count(self, x):
        return _byteblower.Stats_count(self, x)

    def erase(self, *args):
        return _byteblower.Stats_erase(self, *args)

    def find(self, x):
        return _byteblower.Stats_find(self, x)

    def lower_bound(self, x):
        return _byteblower.Stats_lower_bound(self, x)

    def upper_bound(self, x):
        return _byteblower.Stats_upper_bound(self, x)
    __swig_destroy__ = _byteblower.delete_Stats
    __del__ = lambda self: None
Stats_swigregister = _byteblower.Stats_swigregister
Stats_swigregister(Stats)

class StatsList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StatsList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StatsList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.StatsList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.StatsList___nonzero__(self)

    def __bool__(self):
        return _byteblower.StatsList___bool__(self)

    def __len__(self):
        return _byteblower.StatsList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.StatsList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.StatsList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.StatsList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.StatsList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.StatsList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.StatsList___setitem__(self, *args)

    def pop(self):
        return _byteblower.StatsList_pop(self)

    def append(self, x):
        return _byteblower.StatsList_append(self, x)

    def empty(self):
        return _byteblower.StatsList_empty(self)

    def size(self):
        return _byteblower.StatsList_size(self)

    def swap(self, v):
        return _byteblower.StatsList_swap(self, v)

    def begin(self):
        return _byteblower.StatsList_begin(self)

    def end(self):
        return _byteblower.StatsList_end(self)

    def rbegin(self):
        return _byteblower.StatsList_rbegin(self)

    def rend(self):
        return _byteblower.StatsList_rend(self)

    def clear(self):
        return _byteblower.StatsList_clear(self)

    def get_allocator(self):
        return _byteblower.StatsList_get_allocator(self)

    def pop_back(self):
        return _byteblower.StatsList_pop_back(self)

    def erase(self, *args):
        return _byteblower.StatsList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_StatsList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.StatsList_push_back(self, x)

    def front(self):
        return _byteblower.StatsList_front(self)

    def back(self):
        return _byteblower.StatsList_back(self)

    def assign(self, n, x):
        return _byteblower.StatsList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.StatsList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.StatsList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.StatsList_reserve(self, n)

    def capacity(self):
        return _byteblower.StatsList_capacity(self)
    __swig_destroy__ = _byteblower.delete_StatsList
    __del__ = lambda self: None
StatsList_swigregister = _byteblower.StatsList_swigregister
StatsList_swigregister(StatsList)

class StatsByTime(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StatsByTime, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StatsByTime, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.StatsByTime_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.StatsByTime___nonzero__(self)

    def __bool__(self):
        return _byteblower.StatsByTime___bool__(self)

    def __len__(self):
        return _byteblower.StatsByTime___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _byteblower.StatsByTime___getitem__(self, key)

    def __delitem__(self, key):
        return _byteblower.StatsByTime___delitem__(self, key)

    def has_key(self, key):
        return _byteblower.StatsByTime_has_key(self, key)

    def keys(self):
        return _byteblower.StatsByTime_keys(self)

    def values(self):
        return _byteblower.StatsByTime_values(self)

    def items(self):
        return _byteblower.StatsByTime_items(self)

    def __contains__(self, key):
        return _byteblower.StatsByTime___contains__(self, key)

    def key_iterator(self):
        return _byteblower.StatsByTime_key_iterator(self)

    def value_iterator(self):
        return _byteblower.StatsByTime_value_iterator(self)

    def __setitem__(self, *args):
        return _byteblower.StatsByTime___setitem__(self, *args)

    def asdict(self):
        return _byteblower.StatsByTime_asdict(self)

    def __init__(self, *args):
        this = _byteblower.new_StatsByTime(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self):
        return _byteblower.StatsByTime_empty(self)

    def size(self):
        return _byteblower.StatsByTime_size(self)

    def swap(self, v):
        return _byteblower.StatsByTime_swap(self, v)

    def begin(self):
        return _byteblower.StatsByTime_begin(self)

    def end(self):
        return _byteblower.StatsByTime_end(self)

    def rbegin(self):
        return _byteblower.StatsByTime_rbegin(self)

    def rend(self):
        return _byteblower.StatsByTime_rend(self)

    def clear(self):
        return _byteblower.StatsByTime_clear(self)

    def get_allocator(self):
        return _byteblower.StatsByTime_get_allocator(self)

    def count(self, x):
        return _byteblower.StatsByTime_count(self, x)

    def erase(self, *args):
        return _byteblower.StatsByTime_erase(self, *args)

    def find(self, x):
        return _byteblower.StatsByTime_find(self, x)

    def lower_bound(self, x):
        return _byteblower.StatsByTime_lower_bound(self, x)

    def upper_bound(self, x):
        return _byteblower.StatsByTime_upper_bound(self, x)
    __swig_destroy__ = _byteblower.delete_StatsByTime
    __del__ = lambda self: None
StatsByTime_swigregister = _byteblower.StatsByTime_swigregister
StatsByTime_swigregister(StatsByTime)

class Int64StringMap(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Int64StringMap, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Int64StringMap, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.Int64StringMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.Int64StringMap___nonzero__(self)

    def __bool__(self):
        return _byteblower.Int64StringMap___bool__(self)

    def __len__(self):
        return _byteblower.Int64StringMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _byteblower.Int64StringMap___getitem__(self, key)

    def __delitem__(self, key):
        return _byteblower.Int64StringMap___delitem__(self, key)

    def has_key(self, key):
        return _byteblower.Int64StringMap_has_key(self, key)

    def keys(self):
        return _byteblower.Int64StringMap_keys(self)

    def values(self):
        return _byteblower.Int64StringMap_values(self)

    def items(self):
        return _byteblower.Int64StringMap_items(self)

    def __contains__(self, key):
        return _byteblower.Int64StringMap___contains__(self, key)

    def key_iterator(self):
        return _byteblower.Int64StringMap_key_iterator(self)

    def value_iterator(self):
        return _byteblower.Int64StringMap_value_iterator(self)

    def __setitem__(self, *args):
        return _byteblower.Int64StringMap___setitem__(self, *args)

    def asdict(self):
        return _byteblower.Int64StringMap_asdict(self)

    def __init__(self, *args):
        this = _byteblower.new_Int64StringMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self):
        return _byteblower.Int64StringMap_empty(self)

    def size(self):
        return _byteblower.Int64StringMap_size(self)

    def swap(self, v):
        return _byteblower.Int64StringMap_swap(self, v)

    def begin(self):
        return _byteblower.Int64StringMap_begin(self)

    def end(self):
        return _byteblower.Int64StringMap_end(self)

    def rbegin(self):
        return _byteblower.Int64StringMap_rbegin(self)

    def rend(self):
        return _byteblower.Int64StringMap_rend(self)

    def clear(self):
        return _byteblower.Int64StringMap_clear(self)

    def get_allocator(self):
        return _byteblower.Int64StringMap_get_allocator(self)

    def count(self, x):
        return _byteblower.Int64StringMap_count(self, x)

    def erase(self, *args):
        return _byteblower.Int64StringMap_erase(self, *args)

    def find(self, x):
        return _byteblower.Int64StringMap_find(self, x)

    def lower_bound(self, x):
        return _byteblower.Int64StringMap_lower_bound(self, x)

    def upper_bound(self, x):
        return _byteblower.Int64StringMap_upper_bound(self, x)
    __swig_destroy__ = _byteblower.delete_Int64StringMap
    __del__ = lambda self: None
Int64StringMap_swigregister = _byteblower.Int64StringMap_swigregister
Int64StringMap_swigregister(Int64StringMap)

class Buffer(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Buffer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Buffer, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.Buffer_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.Buffer___nonzero__(self)

    def __bool__(self):
        return _byteblower.Buffer___bool__(self)

    def __len__(self):
        return _byteblower.Buffer___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.Buffer___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.Buffer___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.Buffer___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.Buffer___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.Buffer___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.Buffer___setitem__(self, *args)

    def pop(self):
        return _byteblower.Buffer_pop(self)

    def append(self, x):
        return _byteblower.Buffer_append(self, x)

    def empty(self):
        return _byteblower.Buffer_empty(self)

    def size(self):
        return _byteblower.Buffer_size(self)

    def swap(self, v):
        return _byteblower.Buffer_swap(self, v)

    def begin(self):
        return _byteblower.Buffer_begin(self)

    def end(self):
        return _byteblower.Buffer_end(self)

    def rbegin(self):
        return _byteblower.Buffer_rbegin(self)

    def rend(self):
        return _byteblower.Buffer_rend(self)

    def clear(self):
        return _byteblower.Buffer_clear(self)

    def get_allocator(self):
        return _byteblower.Buffer_get_allocator(self)

    def pop_back(self):
        return _byteblower.Buffer_pop_back(self)

    def erase(self, *args):
        return _byteblower.Buffer_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_Buffer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.Buffer_push_back(self, x)

    def front(self):
        return _byteblower.Buffer_front(self)

    def back(self):
        return _byteblower.Buffer_back(self)

    def assign(self, n, x):
        return _byteblower.Buffer_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.Buffer_resize(self, *args)

    def insert(self, *args):
        return _byteblower.Buffer_insert(self, *args)

    def reserve(self, n):
        return _byteblower.Buffer_reserve(self, n)

    def capacity(self):
        return _byteblower.Buffer_capacity(self)
    __swig_destroy__ = _byteblower.delete_Buffer
    __del__ = lambda self: None
Buffer_swigregister = _byteblower.Buffer_swigregister
Buffer_swigregister(Buffer)

class BufferList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BufferList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BufferList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.BufferList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.BufferList___nonzero__(self)

    def __bool__(self):
        return _byteblower.BufferList___bool__(self)

    def __len__(self):
        return _byteblower.BufferList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.BufferList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.BufferList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.BufferList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.BufferList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.BufferList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.BufferList___setitem__(self, *args)

    def pop(self):
        return _byteblower.BufferList_pop(self)

    def append(self, x):
        return _byteblower.BufferList_append(self, x)

    def empty(self):
        return _byteblower.BufferList_empty(self)

    def size(self):
        return _byteblower.BufferList_size(self)

    def swap(self, v):
        return _byteblower.BufferList_swap(self, v)

    def begin(self):
        return _byteblower.BufferList_begin(self)

    def end(self):
        return _byteblower.BufferList_end(self)

    def rbegin(self):
        return _byteblower.BufferList_rbegin(self)

    def rend(self):
        return _byteblower.BufferList_rend(self)

    def clear(self):
        return _byteblower.BufferList_clear(self)

    def get_allocator(self):
        return _byteblower.BufferList_get_allocator(self)

    def pop_back(self):
        return _byteblower.BufferList_pop_back(self)

    def erase(self, *args):
        return _byteblower.BufferList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_BufferList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.BufferList_push_back(self, x)

    def front(self):
        return _byteblower.BufferList_front(self)

    def back(self):
        return _byteblower.BufferList_back(self)

    def assign(self, n, x):
        return _byteblower.BufferList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.BufferList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.BufferList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.BufferList_reserve(self, n)

    def capacity(self):
        return _byteblower.BufferList_capacity(self)
    __swig_destroy__ = _byteblower.delete_BufferList
    __del__ = lambda self: None
BufferList_swigregister = _byteblower.BufferList_swigregister
BufferList_swigregister(BufferList)

class Int64List(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Int64List, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Int64List, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.Int64List_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.Int64List___nonzero__(self)

    def __bool__(self):
        return _byteblower.Int64List___bool__(self)

    def __len__(self):
        return _byteblower.Int64List___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.Int64List___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.Int64List___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.Int64List___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.Int64List___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.Int64List___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.Int64List___setitem__(self, *args)

    def pop(self):
        return _byteblower.Int64List_pop(self)

    def append(self, x):
        return _byteblower.Int64List_append(self, x)

    def empty(self):
        return _byteblower.Int64List_empty(self)

    def size(self):
        return _byteblower.Int64List_size(self)

    def swap(self, v):
        return _byteblower.Int64List_swap(self, v)

    def begin(self):
        return _byteblower.Int64List_begin(self)

    def end(self):
        return _byteblower.Int64List_end(self)

    def rbegin(self):
        return _byteblower.Int64List_rbegin(self)

    def rend(self):
        return _byteblower.Int64List_rend(self)

    def clear(self):
        return _byteblower.Int64List_clear(self)

    def get_allocator(self):
        return _byteblower.Int64List_get_allocator(self)

    def pop_back(self):
        return _byteblower.Int64List_pop_back(self)

    def erase(self, *args):
        return _byteblower.Int64List_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_Int64List(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.Int64List_push_back(self, x)

    def front(self):
        return _byteblower.Int64List_front(self)

    def back(self):
        return _byteblower.Int64List_back(self)

    def assign(self, n, x):
        return _byteblower.Int64List_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.Int64List_resize(self, *args)

    def insert(self, *args):
        return _byteblower.Int64List_insert(self, *args)

    def reserve(self, n):
        return _byteblower.Int64List_reserve(self, n)

    def capacity(self):
        return _byteblower.Int64List_capacity(self)
    __swig_destroy__ = _byteblower.delete_Int64List
    __del__ = lambda self: None
Int64List_swigregister = _byteblower.Int64List_swigregister
Int64List_swigregister(Int64List)

class IntegerList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IntegerList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IntegerList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.IntegerList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.IntegerList___nonzero__(self)

    def __bool__(self):
        return _byteblower.IntegerList___bool__(self)

    def __len__(self):
        return _byteblower.IntegerList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.IntegerList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.IntegerList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.IntegerList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.IntegerList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.IntegerList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.IntegerList___setitem__(self, *args)

    def pop(self):
        return _byteblower.IntegerList_pop(self)

    def append(self, x):
        return _byteblower.IntegerList_append(self, x)

    def empty(self):
        return _byteblower.IntegerList_empty(self)

    def size(self):
        return _byteblower.IntegerList_size(self)

    def swap(self, v):
        return _byteblower.IntegerList_swap(self, v)

    def begin(self):
        return _byteblower.IntegerList_begin(self)

    def end(self):
        return _byteblower.IntegerList_end(self)

    def rbegin(self):
        return _byteblower.IntegerList_rbegin(self)

    def rend(self):
        return _byteblower.IntegerList_rend(self)

    def clear(self):
        return _byteblower.IntegerList_clear(self)

    def get_allocator(self):
        return _byteblower.IntegerList_get_allocator(self)

    def pop_back(self):
        return _byteblower.IntegerList_pop_back(self)

    def erase(self, *args):
        return _byteblower.IntegerList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_IntegerList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.IntegerList_push_back(self, x)

    def front(self):
        return _byteblower.IntegerList_front(self)

    def back(self):
        return _byteblower.IntegerList_back(self)

    def assign(self, n, x):
        return _byteblower.IntegerList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.IntegerList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.IntegerList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.IntegerList_reserve(self, n)

    def capacity(self):
        return _byteblower.IntegerList_capacity(self)
    __swig_destroy__ = _byteblower.delete_IntegerList
    __del__ = lambda self: None
IntegerList_swigregister = _byteblower.IntegerList_swigregister
IntegerList_swigregister(IntegerList)

class UnsignedIntegerList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UnsignedIntegerList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UnsignedIntegerList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.UnsignedIntegerList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.UnsignedIntegerList___nonzero__(self)

    def __bool__(self):
        return _byteblower.UnsignedIntegerList___bool__(self)

    def __len__(self):
        return _byteblower.UnsignedIntegerList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.UnsignedIntegerList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.UnsignedIntegerList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.UnsignedIntegerList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.UnsignedIntegerList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.UnsignedIntegerList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.UnsignedIntegerList___setitem__(self, *args)

    def pop(self):
        return _byteblower.UnsignedIntegerList_pop(self)

    def append(self, x):
        return _byteblower.UnsignedIntegerList_append(self, x)

    def empty(self):
        return _byteblower.UnsignedIntegerList_empty(self)

    def size(self):
        return _byteblower.UnsignedIntegerList_size(self)

    def swap(self, v):
        return _byteblower.UnsignedIntegerList_swap(self, v)

    def begin(self):
        return _byteblower.UnsignedIntegerList_begin(self)

    def end(self):
        return _byteblower.UnsignedIntegerList_end(self)

    def rbegin(self):
        return _byteblower.UnsignedIntegerList_rbegin(self)

    def rend(self):
        return _byteblower.UnsignedIntegerList_rend(self)

    def clear(self):
        return _byteblower.UnsignedIntegerList_clear(self)

    def get_allocator(self):
        return _byteblower.UnsignedIntegerList_get_allocator(self)

    def pop_back(self):
        return _byteblower.UnsignedIntegerList_pop_back(self)

    def erase(self, *args):
        return _byteblower.UnsignedIntegerList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_UnsignedIntegerList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.UnsignedIntegerList_push_back(self, x)

    def front(self):
        return _byteblower.UnsignedIntegerList_front(self)

    def back(self):
        return _byteblower.UnsignedIntegerList_back(self)

    def assign(self, n, x):
        return _byteblower.UnsignedIntegerList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.UnsignedIntegerList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.UnsignedIntegerList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.UnsignedIntegerList_reserve(self, n)

    def capacity(self):
        return _byteblower.UnsignedIntegerList_capacity(self)
    __swig_destroy__ = _byteblower.delete_UnsignedIntegerList
    __del__ = lambda self: None
UnsignedIntegerList_swigregister = _byteblower.UnsignedIntegerList_swigregister
UnsignedIntegerList_swigregister(UnsignedIntegerList)

class StringList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.StringList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.StringList___nonzero__(self)

    def __bool__(self):
        return _byteblower.StringList___bool__(self)

    def __len__(self):
        return _byteblower.StringList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.StringList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.StringList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.StringList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.StringList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.StringList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.StringList___setitem__(self, *args)

    def pop(self):
        return _byteblower.StringList_pop(self)

    def append(self, x):
        return _byteblower.StringList_append(self, x)

    def empty(self):
        return _byteblower.StringList_empty(self)

    def size(self):
        return _byteblower.StringList_size(self)

    def swap(self, v):
        return _byteblower.StringList_swap(self, v)

    def begin(self):
        return _byteblower.StringList_begin(self)

    def end(self):
        return _byteblower.StringList_end(self)

    def rbegin(self):
        return _byteblower.StringList_rbegin(self)

    def rend(self):
        return _byteblower.StringList_rend(self)

    def clear(self):
        return _byteblower.StringList_clear(self)

    def get_allocator(self):
        return _byteblower.StringList_get_allocator(self)

    def pop_back(self):
        return _byteblower.StringList_pop_back(self)

    def erase(self, *args):
        return _byteblower.StringList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_StringList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.StringList_push_back(self, x)

    def front(self):
        return _byteblower.StringList_front(self)

    def back(self):
        return _byteblower.StringList_back(self)

    def assign(self, n, x):
        return _byteblower.StringList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.StringList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.StringList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.StringList_reserve(self, n)

    def capacity(self):
        return _byteblower.StringList_capacity(self)
    __swig_destroy__ = _byteblower.delete_StringList
    __del__ = lambda self: None
StringList_swigregister = _byteblower.StringList_swigregister
StringList_swigregister(StringList)

class Int64Pair(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Int64Pair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Int64Pair, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _byteblower.new_Int64Pair(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["first"] = _byteblower.Int64Pair_first_set
    __swig_getmethods__["first"] = _byteblower.Int64Pair_first_get
    if _newclass:
        first = _swig_property(_byteblower.Int64Pair_first_get, _byteblower.Int64Pair_first_set)
    __swig_setmethods__["second"] = _byteblower.Int64Pair_second_set
    __swig_getmethods__["second"] = _byteblower.Int64Pair_second_get
    if _newclass:
        second = _swig_property(_byteblower.Int64Pair_second_get, _byteblower.Int64Pair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _byteblower.delete_Int64Pair
    __del__ = lambda self: None
Int64Pair_swigregister = _byteblower.Int64Pair_swigregister
Int64Pair_swigregister(Int64Pair)

class AbstractRefreshableResultList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, AbstractRefreshableResultList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, AbstractRefreshableResultList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.AbstractRefreshableResultList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.AbstractRefreshableResultList___nonzero__(self)

    def __bool__(self):
        return _byteblower.AbstractRefreshableResultList___bool__(self)

    def __len__(self):
        return _byteblower.AbstractRefreshableResultList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.AbstractRefreshableResultList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.AbstractRefreshableResultList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.AbstractRefreshableResultList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.AbstractRefreshableResultList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.AbstractRefreshableResultList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.AbstractRefreshableResultList___setitem__(self, *args)

    def pop(self):
        return _byteblower.AbstractRefreshableResultList_pop(self)

    def append(self, x):
        return _byteblower.AbstractRefreshableResultList_append(self, x)

    def empty(self):
        return _byteblower.AbstractRefreshableResultList_empty(self)

    def size(self):
        return _byteblower.AbstractRefreshableResultList_size(self)

    def swap(self, v):
        return _byteblower.AbstractRefreshableResultList_swap(self, v)

    def begin(self):
        return _byteblower.AbstractRefreshableResultList_begin(self)

    def end(self):
        return _byteblower.AbstractRefreshableResultList_end(self)

    def rbegin(self):
        return _byteblower.AbstractRefreshableResultList_rbegin(self)

    def rend(self):
        return _byteblower.AbstractRefreshableResultList_rend(self)

    def clear(self):
        return _byteblower.AbstractRefreshableResultList_clear(self)

    def get_allocator(self):
        return _byteblower.AbstractRefreshableResultList_get_allocator(self)

    def pop_back(self):
        return _byteblower.AbstractRefreshableResultList_pop_back(self)

    def erase(self, *args):
        return _byteblower.AbstractRefreshableResultList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_AbstractRefreshableResultList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.AbstractRefreshableResultList_push_back(self, x)

    def front(self):
        return _byteblower.AbstractRefreshableResultList_front(self)

    def back(self):
        return _byteblower.AbstractRefreshableResultList_back(self)

    def assign(self, n, x):
        return _byteblower.AbstractRefreshableResultList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.AbstractRefreshableResultList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.AbstractRefreshableResultList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.AbstractRefreshableResultList_reserve(self, n)

    def capacity(self):
        return _byteblower.AbstractRefreshableResultList_capacity(self)
    __swig_destroy__ = _byteblower.delete_AbstractRefreshableResultList
    __del__ = lambda self: None
AbstractRefreshableResultList_swigregister = _byteblower.AbstractRefreshableResultList_swigregister
AbstractRefreshableResultList_swigregister(AbstractRefreshableResultList)

class UserList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UserList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UserList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.UserList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.UserList___nonzero__(self)

    def __bool__(self):
        return _byteblower.UserList___bool__(self)

    def __len__(self):
        return _byteblower.UserList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.UserList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.UserList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.UserList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.UserList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.UserList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.UserList___setitem__(self, *args)

    def pop(self):
        return _byteblower.UserList_pop(self)

    def append(self, x):
        return _byteblower.UserList_append(self, x)

    def empty(self):
        return _byteblower.UserList_empty(self)

    def size(self):
        return _byteblower.UserList_size(self)

    def swap(self, v):
        return _byteblower.UserList_swap(self, v)

    def begin(self):
        return _byteblower.UserList_begin(self)

    def end(self):
        return _byteblower.UserList_end(self)

    def rbegin(self):
        return _byteblower.UserList_rbegin(self)

    def rend(self):
        return _byteblower.UserList_rend(self)

    def clear(self):
        return _byteblower.UserList_clear(self)

    def get_allocator(self):
        return _byteblower.UserList_get_allocator(self)

    def pop_back(self):
        return _byteblower.UserList_pop_back(self)

    def erase(self, *args):
        return _byteblower.UserList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_UserList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.UserList_push_back(self, x)

    def front(self):
        return _byteblower.UserList_front(self)

    def back(self):
        return _byteblower.UserList_back(self)

    def assign(self, n, x):
        return _byteblower.UserList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.UserList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.UserList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.UserList_reserve(self, n)

    def capacity(self):
        return _byteblower.UserList_capacity(self)
    __swig_destroy__ = _byteblower.delete_UserList
    __del__ = lambda self: None
UserList_swigregister = _byteblower.UserList_swigregister
UserList_swigregister(UserList)

class UserMobileList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UserMobileList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UserMobileList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.UserMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.UserMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.UserMobileList___bool__(self)

    def __len__(self):
        return _byteblower.UserMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.UserMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.UserMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.UserMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.UserMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.UserMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.UserMobileList___setitem__(self, *args)

    def pop(self):
        return _byteblower.UserMobileList_pop(self)

    def append(self, x):
        return _byteblower.UserMobileList_append(self, x)

    def empty(self):
        return _byteblower.UserMobileList_empty(self)

    def size(self):
        return _byteblower.UserMobileList_size(self)

    def swap(self, v):
        return _byteblower.UserMobileList_swap(self, v)

    def begin(self):
        return _byteblower.UserMobileList_begin(self)

    def end(self):
        return _byteblower.UserMobileList_end(self)

    def rbegin(self):
        return _byteblower.UserMobileList_rbegin(self)

    def rend(self):
        return _byteblower.UserMobileList_rend(self)

    def clear(self):
        return _byteblower.UserMobileList_clear(self)

    def get_allocator(self):
        return _byteblower.UserMobileList_get_allocator(self)

    def pop_back(self):
        return _byteblower.UserMobileList_pop_back(self)

    def erase(self, *args):
        return _byteblower.UserMobileList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_UserMobileList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.UserMobileList_push_back(self, x)

    def front(self):
        return _byteblower.UserMobileList_front(self)

    def back(self):
        return _byteblower.UserMobileList_back(self)

    def assign(self, n, x):
        return _byteblower.UserMobileList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.UserMobileList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.UserMobileList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.UserMobileList_reserve(self, n)

    def capacity(self):
        return _byteblower.UserMobileList_capacity(self)
    __swig_destroy__ = _byteblower.delete_UserMobileList
    __del__ = lambda self: None
UserMobileList_swigregister = _byteblower.UserMobileList_swigregister
UserMobileList_swigregister(UserMobileList)

class ByteBlowerServerList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteBlowerServerList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ByteBlowerServerList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ByteBlowerServerList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ByteBlowerServerList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ByteBlowerServerList___bool__(self)

    def __len__(self):
        return _byteblower.ByteBlowerServerList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ByteBlowerServerList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ByteBlowerServerList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ByteBlowerServerList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ByteBlowerServerList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ByteBlowerServerList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ByteBlowerServerList___setitem__(self, *args)

    def pop(self):
        return _byteblower.ByteBlowerServerList_pop(self)

    def append(self, x):
        return _byteblower.ByteBlowerServerList_append(self, x)

    def empty(self):
        return _byteblower.ByteBlowerServerList_empty(self)

    def size(self):
        return _byteblower.ByteBlowerServerList_size(self)

    def swap(self, v):
        return _byteblower.ByteBlowerServerList_swap(self, v)

    def begin(self):
        return _byteblower.ByteBlowerServerList_begin(self)

    def end(self):
        return _byteblower.ByteBlowerServerList_end(self)

    def rbegin(self):
        return _byteblower.ByteBlowerServerList_rbegin(self)

    def rend(self):
        return _byteblower.ByteBlowerServerList_rend(self)

    def clear(self):
        return _byteblower.ByteBlowerServerList_clear(self)

    def get_allocator(self):
        return _byteblower.ByteBlowerServerList_get_allocator(self)

    def pop_back(self):
        return _byteblower.ByteBlowerServerList_pop_back(self)

    def erase(self, *args):
        return _byteblower.ByteBlowerServerList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_ByteBlowerServerList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.ByteBlowerServerList_push_back(self, x)

    def front(self):
        return _byteblower.ByteBlowerServerList_front(self)

    def back(self):
        return _byteblower.ByteBlowerServerList_back(self)

    def assign(self, n, x):
        return _byteblower.ByteBlowerServerList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.ByteBlowerServerList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.ByteBlowerServerList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.ByteBlowerServerList_reserve(self, n)

    def capacity(self):
        return _byteblower.ByteBlowerServerList_capacity(self)
    __swig_destroy__ = _byteblower.delete_ByteBlowerServerList
    __del__ = lambda self: None
ByteBlowerServerList_swigregister = _byteblower.ByteBlowerServerList_swigregister
ByteBlowerServerList_swigregister(ByteBlowerServerList)

class PhysicalInterfaceList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PhysicalInterfaceList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PhysicalInterfaceList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.PhysicalInterfaceList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.PhysicalInterfaceList___nonzero__(self)

    def __bool__(self):
        return _byteblower.PhysicalInterfaceList___bool__(self)

    def __len__(self):
        return _byteblower.PhysicalInterfaceList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.PhysicalInterfaceList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.PhysicalInterfaceList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.PhysicalInterfaceList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.PhysicalInterfaceList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.PhysicalInterfaceList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.PhysicalInterfaceList___setitem__(self, *args)

    def pop(self):
        return _byteblower.PhysicalInterfaceList_pop(self)

    def append(self, x):
        return _byteblower.PhysicalInterfaceList_append(self, x)

    def empty(self):
        return _byteblower.PhysicalInterfaceList_empty(self)

    def size(self):
        return _byteblower.PhysicalInterfaceList_size(self)

    def swap(self, v):
        return _byteblower.PhysicalInterfaceList_swap(self, v)

    def begin(self):
        return _byteblower.PhysicalInterfaceList_begin(self)

    def end(self):
        return _byteblower.PhysicalInterfaceList_end(self)

    def rbegin(self):
        return _byteblower.PhysicalInterfaceList_rbegin(self)

    def rend(self):
        return _byteblower.PhysicalInterfaceList_rend(self)

    def clear(self):
        return _byteblower.PhysicalInterfaceList_clear(self)

    def get_allocator(self):
        return _byteblower.PhysicalInterfaceList_get_allocator(self)

    def pop_back(self):
        return _byteblower.PhysicalInterfaceList_pop_back(self)

    def erase(self, *args):
        return _byteblower.PhysicalInterfaceList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_PhysicalInterfaceList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.PhysicalInterfaceList_push_back(self, x)

    def front(self):
        return _byteblower.PhysicalInterfaceList_front(self)

    def back(self):
        return _byteblower.PhysicalInterfaceList_back(self)

    def assign(self, n, x):
        return _byteblower.PhysicalInterfaceList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.PhysicalInterfaceList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.PhysicalInterfaceList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.PhysicalInterfaceList_reserve(self, n)

    def capacity(self):
        return _byteblower.PhysicalInterfaceList_capacity(self)
    __swig_destroy__ = _byteblower.delete_PhysicalInterfaceList
    __del__ = lambda self: None
PhysicalInterfaceList_swigregister = _byteblower.PhysicalInterfaceList_swigregister
PhysicalInterfaceList_swigregister(PhysicalInterfaceList)

class ByteBlowerInterfaceList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteBlowerInterfaceList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ByteBlowerInterfaceList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ByteBlowerInterfaceList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ByteBlowerInterfaceList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ByteBlowerInterfaceList___bool__(self)

    def __len__(self):
        return _byteblower.ByteBlowerInterfaceList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ByteBlowerInterfaceList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ByteBlowerInterfaceList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ByteBlowerInterfaceList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ByteBlowerInterfaceList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ByteBlowerInterfaceList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ByteBlowerInterfaceList___setitem__(self, *args)

    def pop(self):
        return _byteblower.ByteBlowerInterfaceList_pop(self)

    def append(self, x):
        return _byteblower.ByteBlowerInterfaceList_append(self, x)

    def empty(self):
        return _byteblower.ByteBlowerInterfaceList_empty(self)

    def size(self):
        return _byteblower.ByteBlowerInterfaceList_size(self)

    def swap(self, v):
        return _byteblower.ByteBlowerInterfaceList_swap(self, v)

    def begin(self):
        return _byteblower.ByteBlowerInterfaceList_begin(self)

    def end(self):
        return _byteblower.ByteBlowerInterfaceList_end(self)

    def rbegin(self):
        return _byteblower.ByteBlowerInterfaceList_rbegin(self)

    def rend(self):
        return _byteblower.ByteBlowerInterfaceList_rend(self)

    def clear(self):
        return _byteblower.ByteBlowerInterfaceList_clear(self)

    def get_allocator(self):
        return _byteblower.ByteBlowerInterfaceList_get_allocator(self)

    def pop_back(self):
        return _byteblower.ByteBlowerInterfaceList_pop_back(self)

    def erase(self, *args):
        return _byteblower.ByteBlowerInterfaceList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_ByteBlowerInterfaceList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.ByteBlowerInterfaceList_push_back(self, x)

    def front(self):
        return _byteblower.ByteBlowerInterfaceList_front(self)

    def back(self):
        return _byteblower.ByteBlowerInterfaceList_back(self)

    def assign(self, n, x):
        return _byteblower.ByteBlowerInterfaceList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.ByteBlowerInterfaceList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.ByteBlowerInterfaceList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.ByteBlowerInterfaceList_reserve(self, n)

    def capacity(self):
        return _byteblower.ByteBlowerInterfaceList_capacity(self)
    __swig_destroy__ = _byteblower.delete_ByteBlowerInterfaceList
    __del__ = lambda self: None
ByteBlowerInterfaceList_swigregister = _byteblower.ByteBlowerInterfaceList_swigregister
ByteBlowerInterfaceList_swigregister(ByteBlowerInterfaceList)

class ByteBlowerPortList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteBlowerPortList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ByteBlowerPortList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ByteBlowerPortList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ByteBlowerPortList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ByteBlowerPortList___bool__(self)

    def __len__(self):
        return _byteblower.ByteBlowerPortList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ByteBlowerPortList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ByteBlowerPortList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ByteBlowerPortList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ByteBlowerPortList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ByteBlowerPortList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ByteBlowerPortList___setitem__(self, *args)

    def pop(self):
        return _byteblower.ByteBlowerPortList_pop(self)

    def append(self, x):
        return _byteblower.ByteBlowerPortList_append(self, x)

    def empty(self):
        return _byteblower.ByteBlowerPortList_empty(self)

    def size(self):
        return _byteblower.ByteBlowerPortList_size(self)

    def swap(self, v):
        return _byteblower.ByteBlowerPortList_swap(self, v)

    def begin(self):
        return _byteblower.ByteBlowerPortList_begin(self)

    def end(self):
        return _byteblower.ByteBlowerPortList_end(self)

    def rbegin(self):
        return _byteblower.ByteBlowerPortList_rbegin(self)

    def rend(self):
        return _byteblower.ByteBlowerPortList_rend(self)

    def clear(self):
        return _byteblower.ByteBlowerPortList_clear(self)

    def get_allocator(self):
        return _byteblower.ByteBlowerPortList_get_allocator(self)

    def pop_back(self):
        return _byteblower.ByteBlowerPortList_pop_back(self)

    def erase(self, *args):
        return _byteblower.ByteBlowerPortList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_ByteBlowerPortList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.ByteBlowerPortList_push_back(self, x)

    def front(self):
        return _byteblower.ByteBlowerPortList_front(self)

    def back(self):
        return _byteblower.ByteBlowerPortList_back(self)

    def assign(self, n, x):
        return _byteblower.ByteBlowerPortList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.ByteBlowerPortList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.ByteBlowerPortList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.ByteBlowerPortList_reserve(self, n)

    def capacity(self):
        return _byteblower.ByteBlowerPortList_capacity(self)
    __swig_destroy__ = _byteblower.delete_ByteBlowerPortList
    __del__ = lambda self: None
ByteBlowerPortList_swigregister = _byteblower.ByteBlowerPortList_swigregister
ByteBlowerPortList_swigregister(ByteBlowerPortList)

class Layer25VlanList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Layer25VlanList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Layer25VlanList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.Layer25VlanList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.Layer25VlanList___nonzero__(self)

    def __bool__(self):
        return _byteblower.Layer25VlanList___bool__(self)

    def __len__(self):
        return _byteblower.Layer25VlanList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.Layer25VlanList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.Layer25VlanList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.Layer25VlanList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.Layer25VlanList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.Layer25VlanList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.Layer25VlanList___setitem__(self, *args)

    def pop(self):
        return _byteblower.Layer25VlanList_pop(self)

    def append(self, x):
        return _byteblower.Layer25VlanList_append(self, x)

    def empty(self):
        return _byteblower.Layer25VlanList_empty(self)

    def size(self):
        return _byteblower.Layer25VlanList_size(self)

    def swap(self, v):
        return _byteblower.Layer25VlanList_swap(self, v)

    def begin(self):
        return _byteblower.Layer25VlanList_begin(self)

    def end(self):
        return _byteblower.Layer25VlanList_end(self)

    def rbegin(self):
        return _byteblower.Layer25VlanList_rbegin(self)

    def rend(self):
        return _byteblower.Layer25VlanList_rend(self)

    def clear(self):
        return _byteblower.Layer25VlanList_clear(self)

    def get_allocator(self):
        return _byteblower.Layer25VlanList_get_allocator(self)

    def pop_back(self):
        return _byteblower.Layer25VlanList_pop_back(self)

    def erase(self, *args):
        return _byteblower.Layer25VlanList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_Layer25VlanList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.Layer25VlanList_push_back(self, x)

    def front(self):
        return _byteblower.Layer25VlanList_front(self)

    def back(self):
        return _byteblower.Layer25VlanList_back(self)

    def assign(self, n, x):
        return _byteblower.Layer25VlanList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.Layer25VlanList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.Layer25VlanList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.Layer25VlanList_reserve(self, n)

    def capacity(self):
        return _byteblower.Layer25VlanList_capacity(self)
    __swig_destroy__ = _byteblower.delete_Layer25VlanList
    __del__ = lambda self: None
Layer25VlanList_swigregister = _byteblower.Layer25VlanList_swigregister
Layer25VlanList_swigregister(Layer25VlanList)

class Layer25PPPoEList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Layer25PPPoEList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Layer25PPPoEList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.Layer25PPPoEList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.Layer25PPPoEList___nonzero__(self)

    def __bool__(self):
        return _byteblower.Layer25PPPoEList___bool__(self)

    def __len__(self):
        return _byteblower.Layer25PPPoEList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.Layer25PPPoEList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.Layer25PPPoEList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.Layer25PPPoEList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.Layer25PPPoEList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.Layer25PPPoEList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.Layer25PPPoEList___setitem__(self, *args)

    def pop(self):
        return _byteblower.Layer25PPPoEList_pop(self)

    def append(self, x):
        return _byteblower.Layer25PPPoEList_append(self, x)

    def empty(self):
        return _byteblower.Layer25PPPoEList_empty(self)

    def size(self):
        return _byteblower.Layer25PPPoEList_size(self)

    def swap(self, v):
        return _byteblower.Layer25PPPoEList_swap(self, v)

    def begin(self):
        return _byteblower.Layer25PPPoEList_begin(self)

    def end(self):
        return _byteblower.Layer25PPPoEList_end(self)

    def rbegin(self):
        return _byteblower.Layer25PPPoEList_rbegin(self)

    def rend(self):
        return _byteblower.Layer25PPPoEList_rend(self)

    def clear(self):
        return _byteblower.Layer25PPPoEList_clear(self)

    def get_allocator(self):
        return _byteblower.Layer25PPPoEList_get_allocator(self)

    def pop_back(self):
        return _byteblower.Layer25PPPoEList_pop_back(self)

    def erase(self, *args):
        return _byteblower.Layer25PPPoEList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_Layer25PPPoEList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.Layer25PPPoEList_push_back(self, x)

    def front(self):
        return _byteblower.Layer25PPPoEList_front(self)

    def back(self):
        return _byteblower.Layer25PPPoEList_back(self)

    def assign(self, n, x):
        return _byteblower.Layer25PPPoEList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.Layer25PPPoEList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.Layer25PPPoEList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.Layer25PPPoEList_reserve(self, n)

    def capacity(self):
        return _byteblower.Layer25PPPoEList_capacity(self)
    __swig_destroy__ = _byteblower.delete_Layer25PPPoEList
    __del__ = lambda self: None
Layer25PPPoEList_swigregister = _byteblower.Layer25PPPoEList_swigregister
Layer25PPPoEList_swigregister(Layer25PPPoEList)

class ScheduleList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ScheduleList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ScheduleList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ScheduleList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ScheduleList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ScheduleList___bool__(self)

    def __len__(self):
        return _byteblower.ScheduleList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ScheduleList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ScheduleList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ScheduleList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ScheduleList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ScheduleList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ScheduleList___setitem__(self, *args)

    def pop(self):
        return _byteblower.ScheduleList_pop(self)

    def append(self, x):
        return _byteblower.ScheduleList_append(self, x)

    def empty(self):
        return _byteblower.ScheduleList_empty(self)

    def size(self):
        return _byteblower.ScheduleList_size(self)

    def swap(self, v):
        return _byteblower.ScheduleList_swap(self, v)

    def begin(self):
        return _byteblower.ScheduleList_begin(self)

    def end(self):
        return _byteblower.ScheduleList_end(self)

    def rbegin(self):
        return _byteblower.ScheduleList_rbegin(self)

    def rend(self):
        return _byteblower.ScheduleList_rend(self)

    def clear(self):
        return _byteblower.ScheduleList_clear(self)

    def get_allocator(self):
        return _byteblower.ScheduleList_get_allocator(self)

    def pop_back(self):
        return _byteblower.ScheduleList_pop_back(self)

    def erase(self, *args):
        return _byteblower.ScheduleList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_ScheduleList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.ScheduleList_push_back(self, x)

    def front(self):
        return _byteblower.ScheduleList_front(self)

    def back(self):
        return _byteblower.ScheduleList_back(self)

    def assign(self, n, x):
        return _byteblower.ScheduleList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.ScheduleList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.ScheduleList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.ScheduleList_reserve(self, n)

    def capacity(self):
        return _byteblower.ScheduleList_capacity(self)
    __swig_destroy__ = _byteblower.delete_ScheduleList
    __del__ = lambda self: None
ScheduleList_swigregister = _byteblower.ScheduleList_swigregister
ScheduleList_swigregister(ScheduleList)

class StreamList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StreamList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.StreamList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.StreamList___nonzero__(self)

    def __bool__(self):
        return _byteblower.StreamList___bool__(self)

    def __len__(self):
        return _byteblower.StreamList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.StreamList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.StreamList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.StreamList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.StreamList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.StreamList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.StreamList___setitem__(self, *args)

    def pop(self):
        return _byteblower.StreamList_pop(self)

    def append(self, x):
        return _byteblower.StreamList_append(self, x)

    def empty(self):
        return _byteblower.StreamList_empty(self)

    def size(self):
        return _byteblower.StreamList_size(self)

    def swap(self, v):
        return _byteblower.StreamList_swap(self, v)

    def begin(self):
        return _byteblower.StreamList_begin(self)

    def end(self):
        return _byteblower.StreamList_end(self)

    def rbegin(self):
        return _byteblower.StreamList_rbegin(self)

    def rend(self):
        return _byteblower.StreamList_rend(self)

    def clear(self):
        return _byteblower.StreamList_clear(self)

    def get_allocator(self):
        return _byteblower.StreamList_get_allocator(self)

    def pop_back(self):
        return _byteblower.StreamList_pop_back(self)

    def erase(self, *args):
        return _byteblower.StreamList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_StreamList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.StreamList_push_back(self, x)

    def front(self):
        return _byteblower.StreamList_front(self)

    def back(self):
        return _byteblower.StreamList_back(self)

    def assign(self, n, x):
        return _byteblower.StreamList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.StreamList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.StreamList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.StreamList_reserve(self, n)

    def capacity(self):
        return _byteblower.StreamList_capacity(self)
    __swig_destroy__ = _byteblower.delete_StreamList
    __del__ = lambda self: None
StreamList_swigregister = _byteblower.StreamList_swigregister
StreamList_swigregister(StreamList)

class StreamMobileList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamMobileList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StreamMobileList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.StreamMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.StreamMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.StreamMobileList___bool__(self)

    def __len__(self):
        return _byteblower.StreamMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.StreamMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.StreamMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.StreamMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.StreamMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.StreamMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.StreamMobileList___setitem__(self, *args)

    def pop(self):
        return _byteblower.StreamMobileList_pop(self)

    def append(self, x):
        return _byteblower.StreamMobileList_append(self, x)

    def empty(self):
        return _byteblower.StreamMobileList_empty(self)

    def size(self):
        return _byteblower.StreamMobileList_size(self)

    def swap(self, v):
        return _byteblower.StreamMobileList_swap(self, v)

    def begin(self):
        return _byteblower.StreamMobileList_begin(self)

    def end(self):
        return _byteblower.StreamMobileList_end(self)

    def rbegin(self):
        return _byteblower.StreamMobileList_rbegin(self)

    def rend(self):
        return _byteblower.StreamMobileList_rend(self)

    def clear(self):
        return _byteblower.StreamMobileList_clear(self)

    def get_allocator(self):
        return _byteblower.StreamMobileList_get_allocator(self)

    def pop_back(self):
        return _byteblower.StreamMobileList_pop_back(self)

    def erase(self, *args):
        return _byteblower.StreamMobileList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_StreamMobileList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.StreamMobileList_push_back(self, x)

    def front(self):
        return _byteblower.StreamMobileList_front(self)

    def back(self):
        return _byteblower.StreamMobileList_back(self)

    def assign(self, n, x):
        return _byteblower.StreamMobileList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.StreamMobileList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.StreamMobileList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.StreamMobileList_reserve(self, n)

    def capacity(self):
        return _byteblower.StreamMobileList_capacity(self)
    __swig_destroy__ = _byteblower.delete_StreamMobileList
    __del__ = lambda self: None
StreamMobileList_swigregister = _byteblower.StreamMobileList_swigregister
StreamMobileList_swigregister(StreamMobileList)

class FrameList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FrameList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.FrameList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.FrameList___nonzero__(self)

    def __bool__(self):
        return _byteblower.FrameList___bool__(self)

    def __len__(self):
        return _byteblower.FrameList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.FrameList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.FrameList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.FrameList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.FrameList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.FrameList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.FrameList___setitem__(self, *args)

    def pop(self):
        return _byteblower.FrameList_pop(self)

    def append(self, x):
        return _byteblower.FrameList_append(self, x)

    def empty(self):
        return _byteblower.FrameList_empty(self)

    def size(self):
        return _byteblower.FrameList_size(self)

    def swap(self, v):
        return _byteblower.FrameList_swap(self, v)

    def begin(self):
        return _byteblower.FrameList_begin(self)

    def end(self):
        return _byteblower.FrameList_end(self)

    def rbegin(self):
        return _byteblower.FrameList_rbegin(self)

    def rend(self):
        return _byteblower.FrameList_rend(self)

    def clear(self):
        return _byteblower.FrameList_clear(self)

    def get_allocator(self):
        return _byteblower.FrameList_get_allocator(self)

    def pop_back(self):
        return _byteblower.FrameList_pop_back(self)

    def erase(self, *args):
        return _byteblower.FrameList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_FrameList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.FrameList_push_back(self, x)

    def front(self):
        return _byteblower.FrameList_front(self)

    def back(self):
        return _byteblower.FrameList_back(self)

    def assign(self, n, x):
        return _byteblower.FrameList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.FrameList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.FrameList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.FrameList_reserve(self, n)

    def capacity(self):
        return _byteblower.FrameList_capacity(self)
    __swig_destroy__ = _byteblower.delete_FrameList
    __del__ = lambda self: None
FrameList_swigregister = _byteblower.FrameList_swigregister
FrameList_swigregister(FrameList)

class FrameMobileList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameMobileList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FrameMobileList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.FrameMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.FrameMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.FrameMobileList___bool__(self)

    def __len__(self):
        return _byteblower.FrameMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.FrameMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.FrameMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.FrameMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.FrameMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.FrameMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.FrameMobileList___setitem__(self, *args)

    def pop(self):
        return _byteblower.FrameMobileList_pop(self)

    def append(self, x):
        return _byteblower.FrameMobileList_append(self, x)

    def empty(self):
        return _byteblower.FrameMobileList_empty(self)

    def size(self):
        return _byteblower.FrameMobileList_size(self)

    def swap(self, v):
        return _byteblower.FrameMobileList_swap(self, v)

    def begin(self):
        return _byteblower.FrameMobileList_begin(self)

    def end(self):
        return _byteblower.FrameMobileList_end(self)

    def rbegin(self):
        return _byteblower.FrameMobileList_rbegin(self)

    def rend(self):
        return _byteblower.FrameMobileList_rend(self)

    def clear(self):
        return _byteblower.FrameMobileList_clear(self)

    def get_allocator(self):
        return _byteblower.FrameMobileList_get_allocator(self)

    def pop_back(self):
        return _byteblower.FrameMobileList_pop_back(self)

    def erase(self, *args):
        return _byteblower.FrameMobileList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_FrameMobileList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.FrameMobileList_push_back(self, x)

    def front(self):
        return _byteblower.FrameMobileList_front(self)

    def back(self):
        return _byteblower.FrameMobileList_back(self)

    def assign(self, n, x):
        return _byteblower.FrameMobileList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.FrameMobileList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.FrameMobileList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.FrameMobileList_reserve(self, n)

    def capacity(self):
        return _byteblower.FrameMobileList_capacity(self)
    __swig_destroy__ = _byteblower.delete_FrameMobileList
    __del__ = lambda self: None
FrameMobileList_swigregister = _byteblower.FrameMobileList_swigregister
FrameMobileList_swigregister(FrameMobileList)

class FrameModifierFieldRandomList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameModifierFieldRandomList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FrameModifierFieldRandomList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.FrameModifierFieldRandomList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.FrameModifierFieldRandomList___nonzero__(self)

    def __bool__(self):
        return _byteblower.FrameModifierFieldRandomList___bool__(self)

    def __len__(self):
        return _byteblower.FrameModifierFieldRandomList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.FrameModifierFieldRandomList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.FrameModifierFieldRandomList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.FrameModifierFieldRandomList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.FrameModifierFieldRandomList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.FrameModifierFieldRandomList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.FrameModifierFieldRandomList___setitem__(self, *args)

    def pop(self):
        return _byteblower.FrameModifierFieldRandomList_pop(self)

    def append(self, x):
        return _byteblower.FrameModifierFieldRandomList_append(self, x)

    def empty(self):
        return _byteblower.FrameModifierFieldRandomList_empty(self)

    def size(self):
        return _byteblower.FrameModifierFieldRandomList_size(self)

    def swap(self, v):
        return _byteblower.FrameModifierFieldRandomList_swap(self, v)

    def begin(self):
        return _byteblower.FrameModifierFieldRandomList_begin(self)

    def end(self):
        return _byteblower.FrameModifierFieldRandomList_end(self)

    def rbegin(self):
        return _byteblower.FrameModifierFieldRandomList_rbegin(self)

    def rend(self):
        return _byteblower.FrameModifierFieldRandomList_rend(self)

    def clear(self):
        return _byteblower.FrameModifierFieldRandomList_clear(self)

    def get_allocator(self):
        return _byteblower.FrameModifierFieldRandomList_get_allocator(self)

    def pop_back(self):
        return _byteblower.FrameModifierFieldRandomList_pop_back(self)

    def erase(self, *args):
        return _byteblower.FrameModifierFieldRandomList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_FrameModifierFieldRandomList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.FrameModifierFieldRandomList_push_back(self, x)

    def front(self):
        return _byteblower.FrameModifierFieldRandomList_front(self)

    def back(self):
        return _byteblower.FrameModifierFieldRandomList_back(self)

    def assign(self, n, x):
        return _byteblower.FrameModifierFieldRandomList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.FrameModifierFieldRandomList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.FrameModifierFieldRandomList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.FrameModifierFieldRandomList_reserve(self, n)

    def capacity(self):
        return _byteblower.FrameModifierFieldRandomList_capacity(self)
    __swig_destroy__ = _byteblower.delete_FrameModifierFieldRandomList
    __del__ = lambda self: None
FrameModifierFieldRandomList_swigregister = _byteblower.FrameModifierFieldRandomList_swigregister
FrameModifierFieldRandomList_swigregister(FrameModifierFieldRandomList)

class FrameModifierFieldIncrementalList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FrameModifierFieldIncrementalList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FrameModifierFieldIncrementalList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.FrameModifierFieldIncrementalList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.FrameModifierFieldIncrementalList___nonzero__(self)

    def __bool__(self):
        return _byteblower.FrameModifierFieldIncrementalList___bool__(self)

    def __len__(self):
        return _byteblower.FrameModifierFieldIncrementalList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.FrameModifierFieldIncrementalList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.FrameModifierFieldIncrementalList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.FrameModifierFieldIncrementalList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.FrameModifierFieldIncrementalList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.FrameModifierFieldIncrementalList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.FrameModifierFieldIncrementalList___setitem__(self, *args)

    def pop(self):
        return _byteblower.FrameModifierFieldIncrementalList_pop(self)

    def append(self, x):
        return _byteblower.FrameModifierFieldIncrementalList_append(self, x)

    def empty(self):
        return _byteblower.FrameModifierFieldIncrementalList_empty(self)

    def size(self):
        return _byteblower.FrameModifierFieldIncrementalList_size(self)

    def swap(self, v):
        return _byteblower.FrameModifierFieldIncrementalList_swap(self, v)

    def begin(self):
        return _byteblower.FrameModifierFieldIncrementalList_begin(self)

    def end(self):
        return _byteblower.FrameModifierFieldIncrementalList_end(self)

    def rbegin(self):
        return _byteblower.FrameModifierFieldIncrementalList_rbegin(self)

    def rend(self):
        return _byteblower.FrameModifierFieldIncrementalList_rend(self)

    def clear(self):
        return _byteblower.FrameModifierFieldIncrementalList_clear(self)

    def get_allocator(self):
        return _byteblower.FrameModifierFieldIncrementalList_get_allocator(self)

    def pop_back(self):
        return _byteblower.FrameModifierFieldIncrementalList_pop_back(self)

    def erase(self, *args):
        return _byteblower.FrameModifierFieldIncrementalList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_FrameModifierFieldIncrementalList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.FrameModifierFieldIncrementalList_push_back(self, x)

    def front(self):
        return _byteblower.FrameModifierFieldIncrementalList_front(self)

    def back(self):
        return _byteblower.FrameModifierFieldIncrementalList_back(self)

    def assign(self, n, x):
        return _byteblower.FrameModifierFieldIncrementalList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.FrameModifierFieldIncrementalList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.FrameModifierFieldIncrementalList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.FrameModifierFieldIncrementalList_reserve(self, n)

    def capacity(self):
        return _byteblower.FrameModifierFieldIncrementalList_capacity(self)
    __swig_destroy__ = _byteblower.delete_FrameModifierFieldIncrementalList
    __del__ = lambda self: None
FrameModifierFieldIncrementalList_swigregister = _byteblower.FrameModifierFieldIncrementalList_swigregister
FrameModifierFieldIncrementalList_swigregister(FrameModifierFieldIncrementalList)

class TriggerBasicList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TriggerBasicList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TriggerBasicList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TriggerBasicList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TriggerBasicList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TriggerBasicList___bool__(self)

    def __len__(self):
        return _byteblower.TriggerBasicList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TriggerBasicList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TriggerBasicList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TriggerBasicList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TriggerBasicList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TriggerBasicList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TriggerBasicList___setitem__(self, *args)

    def pop(self):
        return _byteblower.TriggerBasicList_pop(self)

    def append(self, x):
        return _byteblower.TriggerBasicList_append(self, x)

    def empty(self):
        return _byteblower.TriggerBasicList_empty(self)

    def size(self):
        return _byteblower.TriggerBasicList_size(self)

    def swap(self, v):
        return _byteblower.TriggerBasicList_swap(self, v)

    def begin(self):
        return _byteblower.TriggerBasicList_begin(self)

    def end(self):
        return _byteblower.TriggerBasicList_end(self)

    def rbegin(self):
        return _byteblower.TriggerBasicList_rbegin(self)

    def rend(self):
        return _byteblower.TriggerBasicList_rend(self)

    def clear(self):
        return _byteblower.TriggerBasicList_clear(self)

    def get_allocator(self):
        return _byteblower.TriggerBasicList_get_allocator(self)

    def pop_back(self):
        return _byteblower.TriggerBasicList_pop_back(self)

    def erase(self, *args):
        return _byteblower.TriggerBasicList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_TriggerBasicList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.TriggerBasicList_push_back(self, x)

    def front(self):
        return _byteblower.TriggerBasicList_front(self)

    def back(self):
        return _byteblower.TriggerBasicList_back(self)

    def assign(self, n, x):
        return _byteblower.TriggerBasicList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.TriggerBasicList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.TriggerBasicList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.TriggerBasicList_reserve(self, n)

    def capacity(self):
        return _byteblower.TriggerBasicList_capacity(self)
    __swig_destroy__ = _byteblower.delete_TriggerBasicList
    __del__ = lambda self: None
TriggerBasicList_swigregister = _byteblower.TriggerBasicList_swigregister
TriggerBasicList_swigregister(TriggerBasicList)

class TriggerBasicMobileList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TriggerBasicMobileList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TriggerBasicMobileList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TriggerBasicMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TriggerBasicMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TriggerBasicMobileList___bool__(self)

    def __len__(self):
        return _byteblower.TriggerBasicMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TriggerBasicMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TriggerBasicMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TriggerBasicMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TriggerBasicMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TriggerBasicMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TriggerBasicMobileList___setitem__(self, *args)

    def pop(self):
        return _byteblower.TriggerBasicMobileList_pop(self)

    def append(self, x):
        return _byteblower.TriggerBasicMobileList_append(self, x)

    def empty(self):
        return _byteblower.TriggerBasicMobileList_empty(self)

    def size(self):
        return _byteblower.TriggerBasicMobileList_size(self)

    def swap(self, v):
        return _byteblower.TriggerBasicMobileList_swap(self, v)

    def begin(self):
        return _byteblower.TriggerBasicMobileList_begin(self)

    def end(self):
        return _byteblower.TriggerBasicMobileList_end(self)

    def rbegin(self):
        return _byteblower.TriggerBasicMobileList_rbegin(self)

    def rend(self):
        return _byteblower.TriggerBasicMobileList_rend(self)

    def clear(self):
        return _byteblower.TriggerBasicMobileList_clear(self)

    def get_allocator(self):
        return _byteblower.TriggerBasicMobileList_get_allocator(self)

    def pop_back(self):
        return _byteblower.TriggerBasicMobileList_pop_back(self)

    def erase(self, *args):
        return _byteblower.TriggerBasicMobileList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_TriggerBasicMobileList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.TriggerBasicMobileList_push_back(self, x)

    def front(self):
        return _byteblower.TriggerBasicMobileList_front(self)

    def back(self):
        return _byteblower.TriggerBasicMobileList_back(self)

    def assign(self, n, x):
        return _byteblower.TriggerBasicMobileList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.TriggerBasicMobileList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.TriggerBasicMobileList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.TriggerBasicMobileList_reserve(self, n)

    def capacity(self):
        return _byteblower.TriggerBasicMobileList_capacity(self)
    __swig_destroy__ = _byteblower.delete_TriggerBasicMobileList
    __del__ = lambda self: None
TriggerBasicMobileList_swigregister = _byteblower.TriggerBasicMobileList_swigregister
TriggerBasicMobileList_swigregister(TriggerBasicMobileList)

class TriggerSizeDistributionList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TriggerSizeDistributionList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TriggerSizeDistributionList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TriggerSizeDistributionList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TriggerSizeDistributionList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TriggerSizeDistributionList___bool__(self)

    def __len__(self):
        return _byteblower.TriggerSizeDistributionList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TriggerSizeDistributionList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TriggerSizeDistributionList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TriggerSizeDistributionList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TriggerSizeDistributionList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TriggerSizeDistributionList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TriggerSizeDistributionList___setitem__(self, *args)

    def pop(self):
        return _byteblower.TriggerSizeDistributionList_pop(self)

    def append(self, x):
        return _byteblower.TriggerSizeDistributionList_append(self, x)

    def empty(self):
        return _byteblower.TriggerSizeDistributionList_empty(self)

    def size(self):
        return _byteblower.TriggerSizeDistributionList_size(self)

    def swap(self, v):
        return _byteblower.TriggerSizeDistributionList_swap(self, v)

    def begin(self):
        return _byteblower.TriggerSizeDistributionList_begin(self)

    def end(self):
        return _byteblower.TriggerSizeDistributionList_end(self)

    def rbegin(self):
        return _byteblower.TriggerSizeDistributionList_rbegin(self)

    def rend(self):
        return _byteblower.TriggerSizeDistributionList_rend(self)

    def clear(self):
        return _byteblower.TriggerSizeDistributionList_clear(self)

    def get_allocator(self):
        return _byteblower.TriggerSizeDistributionList_get_allocator(self)

    def pop_back(self):
        return _byteblower.TriggerSizeDistributionList_pop_back(self)

    def erase(self, *args):
        return _byteblower.TriggerSizeDistributionList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_TriggerSizeDistributionList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.TriggerSizeDistributionList_push_back(self, x)

    def front(self):
        return _byteblower.TriggerSizeDistributionList_front(self)

    def back(self):
        return _byteblower.TriggerSizeDistributionList_back(self)

    def assign(self, n, x):
        return _byteblower.TriggerSizeDistributionList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.TriggerSizeDistributionList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.TriggerSizeDistributionList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.TriggerSizeDistributionList_reserve(self, n)

    def capacity(self):
        return _byteblower.TriggerSizeDistributionList_capacity(self)
    __swig_destroy__ = _byteblower.delete_TriggerSizeDistributionList
    __del__ = lambda self: None
TriggerSizeDistributionList_swigregister = _byteblower.TriggerSizeDistributionList_swigregister
TriggerSizeDistributionList_swigregister(TriggerSizeDistributionList)

class LatencyBasicList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatencyBasicList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LatencyBasicList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.LatencyBasicList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.LatencyBasicList___nonzero__(self)

    def __bool__(self):
        return _byteblower.LatencyBasicList___bool__(self)

    def __len__(self):
        return _byteblower.LatencyBasicList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.LatencyBasicList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.LatencyBasicList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.LatencyBasicList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.LatencyBasicList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.LatencyBasicList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.LatencyBasicList___setitem__(self, *args)

    def pop(self):
        return _byteblower.LatencyBasicList_pop(self)

    def append(self, x):
        return _byteblower.LatencyBasicList_append(self, x)

    def empty(self):
        return _byteblower.LatencyBasicList_empty(self)

    def size(self):
        return _byteblower.LatencyBasicList_size(self)

    def swap(self, v):
        return _byteblower.LatencyBasicList_swap(self, v)

    def begin(self):
        return _byteblower.LatencyBasicList_begin(self)

    def end(self):
        return _byteblower.LatencyBasicList_end(self)

    def rbegin(self):
        return _byteblower.LatencyBasicList_rbegin(self)

    def rend(self):
        return _byteblower.LatencyBasicList_rend(self)

    def clear(self):
        return _byteblower.LatencyBasicList_clear(self)

    def get_allocator(self):
        return _byteblower.LatencyBasicList_get_allocator(self)

    def pop_back(self):
        return _byteblower.LatencyBasicList_pop_back(self)

    def erase(self, *args):
        return _byteblower.LatencyBasicList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_LatencyBasicList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.LatencyBasicList_push_back(self, x)

    def front(self):
        return _byteblower.LatencyBasicList_front(self)

    def back(self):
        return _byteblower.LatencyBasicList_back(self)

    def assign(self, n, x):
        return _byteblower.LatencyBasicList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.LatencyBasicList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.LatencyBasicList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.LatencyBasicList_reserve(self, n)

    def capacity(self):
        return _byteblower.LatencyBasicList_capacity(self)
    __swig_destroy__ = _byteblower.delete_LatencyBasicList
    __del__ = lambda self: None
LatencyBasicList_swigregister = _byteblower.LatencyBasicList_swigregister
LatencyBasicList_swigregister(LatencyBasicList)

class LatencyBasicMobileList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatencyBasicMobileList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LatencyBasicMobileList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.LatencyBasicMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.LatencyBasicMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.LatencyBasicMobileList___bool__(self)

    def __len__(self):
        return _byteblower.LatencyBasicMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.LatencyBasicMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.LatencyBasicMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.LatencyBasicMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.LatencyBasicMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.LatencyBasicMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.LatencyBasicMobileList___setitem__(self, *args)

    def pop(self):
        return _byteblower.LatencyBasicMobileList_pop(self)

    def append(self, x):
        return _byteblower.LatencyBasicMobileList_append(self, x)

    def empty(self):
        return _byteblower.LatencyBasicMobileList_empty(self)

    def size(self):
        return _byteblower.LatencyBasicMobileList_size(self)

    def swap(self, v):
        return _byteblower.LatencyBasicMobileList_swap(self, v)

    def begin(self):
        return _byteblower.LatencyBasicMobileList_begin(self)

    def end(self):
        return _byteblower.LatencyBasicMobileList_end(self)

    def rbegin(self):
        return _byteblower.LatencyBasicMobileList_rbegin(self)

    def rend(self):
        return _byteblower.LatencyBasicMobileList_rend(self)

    def clear(self):
        return _byteblower.LatencyBasicMobileList_clear(self)

    def get_allocator(self):
        return _byteblower.LatencyBasicMobileList_get_allocator(self)

    def pop_back(self):
        return _byteblower.LatencyBasicMobileList_pop_back(self)

    def erase(self, *args):
        return _byteblower.LatencyBasicMobileList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_LatencyBasicMobileList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.LatencyBasicMobileList_push_back(self, x)

    def front(self):
        return _byteblower.LatencyBasicMobileList_front(self)

    def back(self):
        return _byteblower.LatencyBasicMobileList_back(self)

    def assign(self, n, x):
        return _byteblower.LatencyBasicMobileList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.LatencyBasicMobileList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.LatencyBasicMobileList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.LatencyBasicMobileList_reserve(self, n)

    def capacity(self):
        return _byteblower.LatencyBasicMobileList_capacity(self)
    __swig_destroy__ = _byteblower.delete_LatencyBasicMobileList
    __del__ = lambda self: None
LatencyBasicMobileList_swigregister = _byteblower.LatencyBasicMobileList_swigregister
LatencyBasicMobileList_swigregister(LatencyBasicMobileList)

class LatencyDistributionList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatencyDistributionList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LatencyDistributionList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.LatencyDistributionList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.LatencyDistributionList___nonzero__(self)

    def __bool__(self):
        return _byteblower.LatencyDistributionList___bool__(self)

    def __len__(self):
        return _byteblower.LatencyDistributionList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.LatencyDistributionList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.LatencyDistributionList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.LatencyDistributionList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.LatencyDistributionList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.LatencyDistributionList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.LatencyDistributionList___setitem__(self, *args)

    def pop(self):
        return _byteblower.LatencyDistributionList_pop(self)

    def append(self, x):
        return _byteblower.LatencyDistributionList_append(self, x)

    def empty(self):
        return _byteblower.LatencyDistributionList_empty(self)

    def size(self):
        return _byteblower.LatencyDistributionList_size(self)

    def swap(self, v):
        return _byteblower.LatencyDistributionList_swap(self, v)

    def begin(self):
        return _byteblower.LatencyDistributionList_begin(self)

    def end(self):
        return _byteblower.LatencyDistributionList_end(self)

    def rbegin(self):
        return _byteblower.LatencyDistributionList_rbegin(self)

    def rend(self):
        return _byteblower.LatencyDistributionList_rend(self)

    def clear(self):
        return _byteblower.LatencyDistributionList_clear(self)

    def get_allocator(self):
        return _byteblower.LatencyDistributionList_get_allocator(self)

    def pop_back(self):
        return _byteblower.LatencyDistributionList_pop_back(self)

    def erase(self, *args):
        return _byteblower.LatencyDistributionList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_LatencyDistributionList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.LatencyDistributionList_push_back(self, x)

    def front(self):
        return _byteblower.LatencyDistributionList_front(self)

    def back(self):
        return _byteblower.LatencyDistributionList_back(self)

    def assign(self, n, x):
        return _byteblower.LatencyDistributionList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.LatencyDistributionList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.LatencyDistributionList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.LatencyDistributionList_reserve(self, n)

    def capacity(self):
        return _byteblower.LatencyDistributionList_capacity(self)
    __swig_destroy__ = _byteblower.delete_LatencyDistributionList
    __del__ = lambda self: None
LatencyDistributionList_swigregister = _byteblower.LatencyDistributionList_swigregister
LatencyDistributionList_swigregister(LatencyDistributionList)

class LatencyDistributionMobileList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, LatencyDistributionMobileList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, LatencyDistributionMobileList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.LatencyDistributionMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.LatencyDistributionMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.LatencyDistributionMobileList___bool__(self)

    def __len__(self):
        return _byteblower.LatencyDistributionMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.LatencyDistributionMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.LatencyDistributionMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.LatencyDistributionMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.LatencyDistributionMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.LatencyDistributionMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.LatencyDistributionMobileList___setitem__(self, *args)

    def pop(self):
        return _byteblower.LatencyDistributionMobileList_pop(self)

    def append(self, x):
        return _byteblower.LatencyDistributionMobileList_append(self, x)

    def empty(self):
        return _byteblower.LatencyDistributionMobileList_empty(self)

    def size(self):
        return _byteblower.LatencyDistributionMobileList_size(self)

    def swap(self, v):
        return _byteblower.LatencyDistributionMobileList_swap(self, v)

    def begin(self):
        return _byteblower.LatencyDistributionMobileList_begin(self)

    def end(self):
        return _byteblower.LatencyDistributionMobileList_end(self)

    def rbegin(self):
        return _byteblower.LatencyDistributionMobileList_rbegin(self)

    def rend(self):
        return _byteblower.LatencyDistributionMobileList_rend(self)

    def clear(self):
        return _byteblower.LatencyDistributionMobileList_clear(self)

    def get_allocator(self):
        return _byteblower.LatencyDistributionMobileList_get_allocator(self)

    def pop_back(self):
        return _byteblower.LatencyDistributionMobileList_pop_back(self)

    def erase(self, *args):
        return _byteblower.LatencyDistributionMobileList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_LatencyDistributionMobileList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.LatencyDistributionMobileList_push_back(self, x)

    def front(self):
        return _byteblower.LatencyDistributionMobileList_front(self)

    def back(self):
        return _byteblower.LatencyDistributionMobileList_back(self)

    def assign(self, n, x):
        return _byteblower.LatencyDistributionMobileList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.LatencyDistributionMobileList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.LatencyDistributionMobileList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.LatencyDistributionMobileList_reserve(self, n)

    def capacity(self):
        return _byteblower.LatencyDistributionMobileList_capacity(self)
    __swig_destroy__ = _byteblower.delete_LatencyDistributionMobileList
    __del__ = lambda self: None
LatencyDistributionMobileList_swigregister = _byteblower.LatencyDistributionMobileList_swigregister
LatencyDistributionMobileList_swigregister(LatencyDistributionMobileList)

class OutOfSequenceList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, OutOfSequenceList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, OutOfSequenceList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.OutOfSequenceList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.OutOfSequenceList___nonzero__(self)

    def __bool__(self):
        return _byteblower.OutOfSequenceList___bool__(self)

    def __len__(self):
        return _byteblower.OutOfSequenceList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.OutOfSequenceList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.OutOfSequenceList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.OutOfSequenceList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.OutOfSequenceList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.OutOfSequenceList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.OutOfSequenceList___setitem__(self, *args)

    def pop(self):
        return _byteblower.OutOfSequenceList_pop(self)

    def append(self, x):
        return _byteblower.OutOfSequenceList_append(self, x)

    def empty(self):
        return _byteblower.OutOfSequenceList_empty(self)

    def size(self):
        return _byteblower.OutOfSequenceList_size(self)

    def swap(self, v):
        return _byteblower.OutOfSequenceList_swap(self, v)

    def begin(self):
        return _byteblower.OutOfSequenceList_begin(self)

    def end(self):
        return _byteblower.OutOfSequenceList_end(self)

    def rbegin(self):
        return _byteblower.OutOfSequenceList_rbegin(self)

    def rend(self):
        return _byteblower.OutOfSequenceList_rend(self)

    def clear(self):
        return _byteblower.OutOfSequenceList_clear(self)

    def get_allocator(self):
        return _byteblower.OutOfSequenceList_get_allocator(self)

    def pop_back(self):
        return _byteblower.OutOfSequenceList_pop_back(self)

    def erase(self, *args):
        return _byteblower.OutOfSequenceList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_OutOfSequenceList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.OutOfSequenceList_push_back(self, x)

    def front(self):
        return _byteblower.OutOfSequenceList_front(self)

    def back(self):
        return _byteblower.OutOfSequenceList_back(self)

    def assign(self, n, x):
        return _byteblower.OutOfSequenceList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.OutOfSequenceList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.OutOfSequenceList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.OutOfSequenceList_reserve(self, n)

    def capacity(self):
        return _byteblower.OutOfSequenceList_capacity(self)
    __swig_destroy__ = _byteblower.delete_OutOfSequenceList
    __del__ = lambda self: None
OutOfSequenceList_swigregister = _byteblower.OutOfSequenceList_swigregister
OutOfSequenceList_swigregister(OutOfSequenceList)

class HTTPClientList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPClientList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPClientList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPClientList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPClientList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPClientList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPClientList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPClientList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPClientList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPClientList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPClientList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPClientList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPClientList___setitem__(self, *args)

    def pop(self):
        return _byteblower.HTTPClientList_pop(self)

    def append(self, x):
        return _byteblower.HTTPClientList_append(self, x)

    def empty(self):
        return _byteblower.HTTPClientList_empty(self)

    def size(self):
        return _byteblower.HTTPClientList_size(self)

    def swap(self, v):
        return _byteblower.HTTPClientList_swap(self, v)

    def begin(self):
        return _byteblower.HTTPClientList_begin(self)

    def end(self):
        return _byteblower.HTTPClientList_end(self)

    def rbegin(self):
        return _byteblower.HTTPClientList_rbegin(self)

    def rend(self):
        return _byteblower.HTTPClientList_rend(self)

    def clear(self):
        return _byteblower.HTTPClientList_clear(self)

    def get_allocator(self):
        return _byteblower.HTTPClientList_get_allocator(self)

    def pop_back(self):
        return _byteblower.HTTPClientList_pop_back(self)

    def erase(self, *args):
        return _byteblower.HTTPClientList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_HTTPClientList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.HTTPClientList_push_back(self, x)

    def front(self):
        return _byteblower.HTTPClientList_front(self)

    def back(self):
        return _byteblower.HTTPClientList_back(self)

    def assign(self, n, x):
        return _byteblower.HTTPClientList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.HTTPClientList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.HTTPClientList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.HTTPClientList_reserve(self, n)

    def capacity(self):
        return _byteblower.HTTPClientList_capacity(self)
    __swig_destroy__ = _byteblower.delete_HTTPClientList
    __del__ = lambda self: None
HTTPClientList_swigregister = _byteblower.HTTPClientList_swigregister
HTTPClientList_swigregister(HTTPClientList)

class HTTPMultiDataList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPMultiDataList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPMultiDataList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPMultiDataList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPMultiDataList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPMultiDataList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPMultiDataList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPMultiDataList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPMultiDataList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPMultiDataList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPMultiDataList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPMultiDataList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPMultiDataList___setitem__(self, *args)

    def pop(self):
        return _byteblower.HTTPMultiDataList_pop(self)

    def append(self, x):
        return _byteblower.HTTPMultiDataList_append(self, x)

    def empty(self):
        return _byteblower.HTTPMultiDataList_empty(self)

    def size(self):
        return _byteblower.HTTPMultiDataList_size(self)

    def swap(self, v):
        return _byteblower.HTTPMultiDataList_swap(self, v)

    def begin(self):
        return _byteblower.HTTPMultiDataList_begin(self)

    def end(self):
        return _byteblower.HTTPMultiDataList_end(self)

    def rbegin(self):
        return _byteblower.HTTPMultiDataList_rbegin(self)

    def rend(self):
        return _byteblower.HTTPMultiDataList_rend(self)

    def clear(self):
        return _byteblower.HTTPMultiDataList_clear(self)

    def get_allocator(self):
        return _byteblower.HTTPMultiDataList_get_allocator(self)

    def pop_back(self):
        return _byteblower.HTTPMultiDataList_pop_back(self)

    def erase(self, *args):
        return _byteblower.HTTPMultiDataList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_HTTPMultiDataList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.HTTPMultiDataList_push_back(self, x)

    def front(self):
        return _byteblower.HTTPMultiDataList_front(self)

    def back(self):
        return _byteblower.HTTPMultiDataList_back(self)

    def assign(self, n, x):
        return _byteblower.HTTPMultiDataList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.HTTPMultiDataList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.HTTPMultiDataList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.HTTPMultiDataList_reserve(self, n)

    def capacity(self):
        return _byteblower.HTTPMultiDataList_capacity(self)
    __swig_destroy__ = _byteblower.delete_HTTPMultiDataList
    __del__ = lambda self: None
HTTPMultiDataList_swigregister = _byteblower.HTTPMultiDataList_swigregister
HTTPMultiDataList_swigregister(HTTPMultiDataList)

class HTTPMultiClientList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPMultiClientList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPMultiClientList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPMultiClientList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPMultiClientList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPMultiClientList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPMultiClientList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPMultiClientList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPMultiClientList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPMultiClientList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPMultiClientList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPMultiClientList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPMultiClientList___setitem__(self, *args)

    def pop(self):
        return _byteblower.HTTPMultiClientList_pop(self)

    def append(self, x):
        return _byteblower.HTTPMultiClientList_append(self, x)

    def empty(self):
        return _byteblower.HTTPMultiClientList_empty(self)

    def size(self):
        return _byteblower.HTTPMultiClientList_size(self)

    def swap(self, v):
        return _byteblower.HTTPMultiClientList_swap(self, v)

    def begin(self):
        return _byteblower.HTTPMultiClientList_begin(self)

    def end(self):
        return _byteblower.HTTPMultiClientList_end(self)

    def rbegin(self):
        return _byteblower.HTTPMultiClientList_rbegin(self)

    def rend(self):
        return _byteblower.HTTPMultiClientList_rend(self)

    def clear(self):
        return _byteblower.HTTPMultiClientList_clear(self)

    def get_allocator(self):
        return _byteblower.HTTPMultiClientList_get_allocator(self)

    def pop_back(self):
        return _byteblower.HTTPMultiClientList_pop_back(self)

    def erase(self, *args):
        return _byteblower.HTTPMultiClientList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_HTTPMultiClientList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.HTTPMultiClientList_push_back(self, x)

    def front(self):
        return _byteblower.HTTPMultiClientList_front(self)

    def back(self):
        return _byteblower.HTTPMultiClientList_back(self)

    def assign(self, n, x):
        return _byteblower.HTTPMultiClientList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.HTTPMultiClientList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.HTTPMultiClientList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.HTTPMultiClientList_reserve(self, n)

    def capacity(self):
        return _byteblower.HTTPMultiClientList_capacity(self)
    __swig_destroy__ = _byteblower.delete_HTTPMultiClientList
    __del__ = lambda self: None
HTTPMultiClientList_swigregister = _byteblower.HTTPMultiClientList_swigregister
HTTPMultiClientList_swigregister(HTTPMultiClientList)

class HTTPClientMobileList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPClientMobileList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPClientMobileList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPClientMobileList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPClientMobileList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPClientMobileList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPClientMobileList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPClientMobileList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPClientMobileList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPClientMobileList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPClientMobileList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPClientMobileList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPClientMobileList___setitem__(self, *args)

    def pop(self):
        return _byteblower.HTTPClientMobileList_pop(self)

    def append(self, x):
        return _byteblower.HTTPClientMobileList_append(self, x)

    def empty(self):
        return _byteblower.HTTPClientMobileList_empty(self)

    def size(self):
        return _byteblower.HTTPClientMobileList_size(self)

    def swap(self, v):
        return _byteblower.HTTPClientMobileList_swap(self, v)

    def begin(self):
        return _byteblower.HTTPClientMobileList_begin(self)

    def end(self):
        return _byteblower.HTTPClientMobileList_end(self)

    def rbegin(self):
        return _byteblower.HTTPClientMobileList_rbegin(self)

    def rend(self):
        return _byteblower.HTTPClientMobileList_rend(self)

    def clear(self):
        return _byteblower.HTTPClientMobileList_clear(self)

    def get_allocator(self):
        return _byteblower.HTTPClientMobileList_get_allocator(self)

    def pop_back(self):
        return _byteblower.HTTPClientMobileList_pop_back(self)

    def erase(self, *args):
        return _byteblower.HTTPClientMobileList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_HTTPClientMobileList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.HTTPClientMobileList_push_back(self, x)

    def front(self):
        return _byteblower.HTTPClientMobileList_front(self)

    def back(self):
        return _byteblower.HTTPClientMobileList_back(self)

    def assign(self, n, x):
        return _byteblower.HTTPClientMobileList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.HTTPClientMobileList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.HTTPClientMobileList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.HTTPClientMobileList_reserve(self, n)

    def capacity(self):
        return _byteblower.HTTPClientMobileList_capacity(self)
    __swig_destroy__ = _byteblower.delete_HTTPClientMobileList
    __del__ = lambda self: None
HTTPClientMobileList_swigregister = _byteblower.HTTPClientMobileList_swigregister
HTTPClientMobileList_swigregister(HTTPClientMobileList)

class HTTPServerList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPServerList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPServerList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPServerList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPServerList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPServerList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPServerList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPServerList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPServerList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPServerList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPServerList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPServerList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPServerList___setitem__(self, *args)

    def pop(self):
        return _byteblower.HTTPServerList_pop(self)

    def append(self, x):
        return _byteblower.HTTPServerList_append(self, x)

    def empty(self):
        return _byteblower.HTTPServerList_empty(self)

    def size(self):
        return _byteblower.HTTPServerList_size(self)

    def swap(self, v):
        return _byteblower.HTTPServerList_swap(self, v)

    def begin(self):
        return _byteblower.HTTPServerList_begin(self)

    def end(self):
        return _byteblower.HTTPServerList_end(self)

    def rbegin(self):
        return _byteblower.HTTPServerList_rbegin(self)

    def rend(self):
        return _byteblower.HTTPServerList_rend(self)

    def clear(self):
        return _byteblower.HTTPServerList_clear(self)

    def get_allocator(self):
        return _byteblower.HTTPServerList_get_allocator(self)

    def pop_back(self):
        return _byteblower.HTTPServerList_pop_back(self)

    def erase(self, *args):
        return _byteblower.HTTPServerList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_HTTPServerList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.HTTPServerList_push_back(self, x)

    def front(self):
        return _byteblower.HTTPServerList_front(self)

    def back(self):
        return _byteblower.HTTPServerList_back(self)

    def assign(self, n, x):
        return _byteblower.HTTPServerList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.HTTPServerList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.HTTPServerList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.HTTPServerList_reserve(self, n)

    def capacity(self):
        return _byteblower.HTTPServerList_capacity(self)
    __swig_destroy__ = _byteblower.delete_HTTPServerList
    __del__ = lambda self: None
HTTPServerList_swigregister = _byteblower.HTTPServerList_swigregister
HTTPServerList_swigregister(HTTPServerList)

class HTTPMultiServerList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, HTTPMultiServerList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, HTTPMultiServerList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.HTTPMultiServerList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.HTTPMultiServerList___nonzero__(self)

    def __bool__(self):
        return _byteblower.HTTPMultiServerList___bool__(self)

    def __len__(self):
        return _byteblower.HTTPMultiServerList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.HTTPMultiServerList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.HTTPMultiServerList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.HTTPMultiServerList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.HTTPMultiServerList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.HTTPMultiServerList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.HTTPMultiServerList___setitem__(self, *args)

    def pop(self):
        return _byteblower.HTTPMultiServerList_pop(self)

    def append(self, x):
        return _byteblower.HTTPMultiServerList_append(self, x)

    def empty(self):
        return _byteblower.HTTPMultiServerList_empty(self)

    def size(self):
        return _byteblower.HTTPMultiServerList_size(self)

    def swap(self, v):
        return _byteblower.HTTPMultiServerList_swap(self, v)

    def begin(self):
        return _byteblower.HTTPMultiServerList_begin(self)

    def end(self):
        return _byteblower.HTTPMultiServerList_end(self)

    def rbegin(self):
        return _byteblower.HTTPMultiServerList_rbegin(self)

    def rend(self):
        return _byteblower.HTTPMultiServerList_rend(self)

    def clear(self):
        return _byteblower.HTTPMultiServerList_clear(self)

    def get_allocator(self):
        return _byteblower.HTTPMultiServerList_get_allocator(self)

    def pop_back(self):
        return _byteblower.HTTPMultiServerList_pop_back(self)

    def erase(self, *args):
        return _byteblower.HTTPMultiServerList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_HTTPMultiServerList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.HTTPMultiServerList_push_back(self, x)

    def front(self):
        return _byteblower.HTTPMultiServerList_front(self)

    def back(self):
        return _byteblower.HTTPMultiServerList_back(self)

    def assign(self, n, x):
        return _byteblower.HTTPMultiServerList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.HTTPMultiServerList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.HTTPMultiServerList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.HTTPMultiServerList_reserve(self, n)

    def capacity(self):
        return _byteblower.HTTPMultiServerList_capacity(self)
    __swig_destroy__ = _byteblower.delete_HTTPMultiServerList
    __del__ = lambda self: None
HTTPMultiServerList_swigregister = _byteblower.HTTPMultiServerList_swigregister
HTTPMultiServerList_swigregister(HTTPMultiServerList)

class TelnetClientList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TelnetClientList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TelnetClientList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TelnetClientList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TelnetClientList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TelnetClientList___bool__(self)

    def __len__(self):
        return _byteblower.TelnetClientList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TelnetClientList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TelnetClientList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TelnetClientList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TelnetClientList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TelnetClientList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TelnetClientList___setitem__(self, *args)

    def pop(self):
        return _byteblower.TelnetClientList_pop(self)

    def append(self, x):
        return _byteblower.TelnetClientList_append(self, x)

    def empty(self):
        return _byteblower.TelnetClientList_empty(self)

    def size(self):
        return _byteblower.TelnetClientList_size(self)

    def swap(self, v):
        return _byteblower.TelnetClientList_swap(self, v)

    def begin(self):
        return _byteblower.TelnetClientList_begin(self)

    def end(self):
        return _byteblower.TelnetClientList_end(self)

    def rbegin(self):
        return _byteblower.TelnetClientList_rbegin(self)

    def rend(self):
        return _byteblower.TelnetClientList_rend(self)

    def clear(self):
        return _byteblower.TelnetClientList_clear(self)

    def get_allocator(self):
        return _byteblower.TelnetClientList_get_allocator(self)

    def pop_back(self):
        return _byteblower.TelnetClientList_pop_back(self)

    def erase(self, *args):
        return _byteblower.TelnetClientList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_TelnetClientList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.TelnetClientList_push_back(self, x)

    def front(self):
        return _byteblower.TelnetClientList_front(self)

    def back(self):
        return _byteblower.TelnetClientList_back(self)

    def assign(self, n, x):
        return _byteblower.TelnetClientList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.TelnetClientList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.TelnetClientList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.TelnetClientList_reserve(self, n)

    def capacity(self):
        return _byteblower.TelnetClientList_capacity(self)
    __swig_destroy__ = _byteblower.delete_TelnetClientList
    __del__ = lambda self: None
TelnetClientList_swigregister = _byteblower.TelnetClientList_swigregister
TelnetClientList_swigregister(TelnetClientList)

class TCPTunnelList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TCPTunnelList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TCPTunnelList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.TCPTunnelList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.TCPTunnelList___nonzero__(self)

    def __bool__(self):
        return _byteblower.TCPTunnelList___bool__(self)

    def __len__(self):
        return _byteblower.TCPTunnelList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.TCPTunnelList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.TCPTunnelList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.TCPTunnelList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.TCPTunnelList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.TCPTunnelList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.TCPTunnelList___setitem__(self, *args)

    def pop(self):
        return _byteblower.TCPTunnelList_pop(self)

    def append(self, x):
        return _byteblower.TCPTunnelList_append(self, x)

    def empty(self):
        return _byteblower.TCPTunnelList_empty(self)

    def size(self):
        return _byteblower.TCPTunnelList_size(self)

    def swap(self, v):
        return _byteblower.TCPTunnelList_swap(self, v)

    def begin(self):
        return _byteblower.TCPTunnelList_begin(self)

    def end(self):
        return _byteblower.TCPTunnelList_end(self)

    def rbegin(self):
        return _byteblower.TCPTunnelList_rbegin(self)

    def rend(self):
        return _byteblower.TCPTunnelList_rend(self)

    def clear(self):
        return _byteblower.TCPTunnelList_clear(self)

    def get_allocator(self):
        return _byteblower.TCPTunnelList_get_allocator(self)

    def pop_back(self):
        return _byteblower.TCPTunnelList_pop_back(self)

    def erase(self, *args):
        return _byteblower.TCPTunnelList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_TCPTunnelList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.TCPTunnelList_push_back(self, x)

    def front(self):
        return _byteblower.TCPTunnelList_front(self)

    def back(self):
        return _byteblower.TCPTunnelList_back(self)

    def assign(self, n, x):
        return _byteblower.TCPTunnelList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.TCPTunnelList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.TCPTunnelList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.TCPTunnelList_reserve(self, n)

    def capacity(self):
        return _byteblower.TCPTunnelList_capacity(self)
    __swig_destroy__ = _byteblower.delete_TCPTunnelList
    __del__ = lambda self: None
TCPTunnelList_swigregister = _byteblower.TCPTunnelList_swigregister
TCPTunnelList_swigregister(TCPTunnelList)

class ICMPEchoSessionList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICMPEchoSessionList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ICMPEchoSessionList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ICMPEchoSessionList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ICMPEchoSessionList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ICMPEchoSessionList___bool__(self)

    def __len__(self):
        return _byteblower.ICMPEchoSessionList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ICMPEchoSessionList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ICMPEchoSessionList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ICMPEchoSessionList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ICMPEchoSessionList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ICMPEchoSessionList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ICMPEchoSessionList___setitem__(self, *args)

    def pop(self):
        return _byteblower.ICMPEchoSessionList_pop(self)

    def append(self, x):
        return _byteblower.ICMPEchoSessionList_append(self, x)

    def empty(self):
        return _byteblower.ICMPEchoSessionList_empty(self)

    def size(self):
        return _byteblower.ICMPEchoSessionList_size(self)

    def swap(self, v):
        return _byteblower.ICMPEchoSessionList_swap(self, v)

    def begin(self):
        return _byteblower.ICMPEchoSessionList_begin(self)

    def end(self):
        return _byteblower.ICMPEchoSessionList_end(self)

    def rbegin(self):
        return _byteblower.ICMPEchoSessionList_rbegin(self)

    def rend(self):
        return _byteblower.ICMPEchoSessionList_rend(self)

    def clear(self):
        return _byteblower.ICMPEchoSessionList_clear(self)

    def get_allocator(self):
        return _byteblower.ICMPEchoSessionList_get_allocator(self)

    def pop_back(self):
        return _byteblower.ICMPEchoSessionList_pop_back(self)

    def erase(self, *args):
        return _byteblower.ICMPEchoSessionList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_ICMPEchoSessionList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.ICMPEchoSessionList_push_back(self, x)

    def front(self):
        return _byteblower.ICMPEchoSessionList_front(self)

    def back(self):
        return _byteblower.ICMPEchoSessionList_back(self)

    def assign(self, n, x):
        return _byteblower.ICMPEchoSessionList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.ICMPEchoSessionList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.ICMPEchoSessionList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.ICMPEchoSessionList_reserve(self, n)

    def capacity(self):
        return _byteblower.ICMPEchoSessionList_capacity(self)
    __swig_destroy__ = _byteblower.delete_ICMPEchoSessionList
    __del__ = lambda self: None
ICMPEchoSessionList_swigregister = _byteblower.ICMPEchoSessionList_swigregister
ICMPEchoSessionList_swigregister(ICMPEchoSessionList)

class ICMPv6EchoSessionList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ICMPv6EchoSessionList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ICMPv6EchoSessionList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.ICMPv6EchoSessionList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.ICMPv6EchoSessionList___nonzero__(self)

    def __bool__(self):
        return _byteblower.ICMPv6EchoSessionList___bool__(self)

    def __len__(self):
        return _byteblower.ICMPv6EchoSessionList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.ICMPv6EchoSessionList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.ICMPv6EchoSessionList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.ICMPv6EchoSessionList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.ICMPv6EchoSessionList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.ICMPv6EchoSessionList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.ICMPv6EchoSessionList___setitem__(self, *args)

    def pop(self):
        return _byteblower.ICMPv6EchoSessionList_pop(self)

    def append(self, x):
        return _byteblower.ICMPv6EchoSessionList_append(self, x)

    def empty(self):
        return _byteblower.ICMPv6EchoSessionList_empty(self)

    def size(self):
        return _byteblower.ICMPv6EchoSessionList_size(self)

    def swap(self, v):
        return _byteblower.ICMPv6EchoSessionList_swap(self, v)

    def begin(self):
        return _byteblower.ICMPv6EchoSessionList_begin(self)

    def end(self):
        return _byteblower.ICMPv6EchoSessionList_end(self)

    def rbegin(self):
        return _byteblower.ICMPv6EchoSessionList_rbegin(self)

    def rend(self):
        return _byteblower.ICMPv6EchoSessionList_rend(self)

    def clear(self):
        return _byteblower.ICMPv6EchoSessionList_clear(self)

    def get_allocator(self):
        return _byteblower.ICMPv6EchoSessionList_get_allocator(self)

    def pop_back(self):
        return _byteblower.ICMPv6EchoSessionList_pop_back(self)

    def erase(self, *args):
        return _byteblower.ICMPv6EchoSessionList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_ICMPv6EchoSessionList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.ICMPv6EchoSessionList_push_back(self, x)

    def front(self):
        return _byteblower.ICMPv6EchoSessionList_front(self)

    def back(self):
        return _byteblower.ICMPv6EchoSessionList_back(self)

    def assign(self, n, x):
        return _byteblower.ICMPv6EchoSessionList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.ICMPv6EchoSessionList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.ICMPv6EchoSessionList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.ICMPv6EchoSessionList_reserve(self, n)

    def capacity(self):
        return _byteblower.ICMPv6EchoSessionList_capacity(self)
    __swig_destroy__ = _byteblower.delete_ICMPv6EchoSessionList
    __del__ = lambda self: None
ICMPv6EchoSessionList_swigregister = _byteblower.ICMPv6EchoSessionList_swigregister
ICMPv6EchoSessionList_swigregister(ICMPv6EchoSessionList)

class CaptureRawPacketList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CaptureRawPacketList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CaptureRawPacketList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.CaptureRawPacketList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.CaptureRawPacketList___nonzero__(self)

    def __bool__(self):
        return _byteblower.CaptureRawPacketList___bool__(self)

    def __len__(self):
        return _byteblower.CaptureRawPacketList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.CaptureRawPacketList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.CaptureRawPacketList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.CaptureRawPacketList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.CaptureRawPacketList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.CaptureRawPacketList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.CaptureRawPacketList___setitem__(self, *args)

    def pop(self):
        return _byteblower.CaptureRawPacketList_pop(self)

    def append(self, x):
        return _byteblower.CaptureRawPacketList_append(self, x)

    def empty(self):
        return _byteblower.CaptureRawPacketList_empty(self)

    def size(self):
        return _byteblower.CaptureRawPacketList_size(self)

    def swap(self, v):
        return _byteblower.CaptureRawPacketList_swap(self, v)

    def begin(self):
        return _byteblower.CaptureRawPacketList_begin(self)

    def end(self):
        return _byteblower.CaptureRawPacketList_end(self)

    def rbegin(self):
        return _byteblower.CaptureRawPacketList_rbegin(self)

    def rend(self):
        return _byteblower.CaptureRawPacketList_rend(self)

    def clear(self):
        return _byteblower.CaptureRawPacketList_clear(self)

    def get_allocator(self):
        return _byteblower.CaptureRawPacketList_get_allocator(self)

    def pop_back(self):
        return _byteblower.CaptureRawPacketList_pop_back(self)

    def erase(self, *args):
        return _byteblower.CaptureRawPacketList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_CaptureRawPacketList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.CaptureRawPacketList_push_back(self, x)

    def front(self):
        return _byteblower.CaptureRawPacketList_front(self)

    def back(self):
        return _byteblower.CaptureRawPacketList_back(self)

    def assign(self, n, x):
        return _byteblower.CaptureRawPacketList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.CaptureRawPacketList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.CaptureRawPacketList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.CaptureRawPacketList_reserve(self, n)

    def capacity(self):
        return _byteblower.CaptureRawPacketList_capacity(self)
    __swig_destroy__ = _byteblower.delete_CaptureRawPacketList
    __del__ = lambda self: None
CaptureRawPacketList_swigregister = _byteblower.CaptureRawPacketList_swigregister
CaptureRawPacketList_swigregister(CaptureRawPacketList)

class CapturedFrameList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CapturedFrameList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CapturedFrameList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.CapturedFrameList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.CapturedFrameList___nonzero__(self)

    def __bool__(self):
        return _byteblower.CapturedFrameList___bool__(self)

    def __len__(self):
        return _byteblower.CapturedFrameList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.CapturedFrameList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.CapturedFrameList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.CapturedFrameList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.CapturedFrameList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.CapturedFrameList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.CapturedFrameList___setitem__(self, *args)

    def pop(self):
        return _byteblower.CapturedFrameList_pop(self)

    def append(self, x):
        return _byteblower.CapturedFrameList_append(self, x)

    def empty(self):
        return _byteblower.CapturedFrameList_empty(self)

    def size(self):
        return _byteblower.CapturedFrameList_size(self)

    def swap(self, v):
        return _byteblower.CapturedFrameList_swap(self, v)

    def begin(self):
        return _byteblower.CapturedFrameList_begin(self)

    def end(self):
        return _byteblower.CapturedFrameList_end(self)

    def rbegin(self):
        return _byteblower.CapturedFrameList_rbegin(self)

    def rend(self):
        return _byteblower.CapturedFrameList_rend(self)

    def clear(self):
        return _byteblower.CapturedFrameList_clear(self)

    def get_allocator(self):
        return _byteblower.CapturedFrameList_get_allocator(self)

    def pop_back(self):
        return _byteblower.CapturedFrameList_pop_back(self)

    def erase(self, *args):
        return _byteblower.CapturedFrameList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_CapturedFrameList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.CapturedFrameList_push_back(self, x)

    def front(self):
        return _byteblower.CapturedFrameList_front(self)

    def back(self):
        return _byteblower.CapturedFrameList_back(self)

    def assign(self, n, x):
        return _byteblower.CapturedFrameList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.CapturedFrameList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.CapturedFrameList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.CapturedFrameList_reserve(self, n)

    def capacity(self):
        return _byteblower.CapturedFrameList_capacity(self)
    __swig_destroy__ = _byteblower.delete_CapturedFrameList
    __del__ = lambda self: None
CapturedFrameList_swigregister = _byteblower.CapturedFrameList_swigregister
CapturedFrameList_swigregister(CapturedFrameList)

class CapabilityList(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CapabilityList, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CapabilityList, name)
    __repr__ = _swig_repr

    def iterator(self):
        return _byteblower.CapabilityList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _byteblower.CapabilityList___nonzero__(self)

    def __bool__(self):
        return _byteblower.CapabilityList___bool__(self)

    def __len__(self):
        return _byteblower.CapabilityList___len__(self)

    def __getslice__(self, i, j):
        return _byteblower.CapabilityList___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _byteblower.CapabilityList___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _byteblower.CapabilityList___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _byteblower.CapabilityList___delitem__(self, *args)

    def __getitem__(self, *args):
        return _byteblower.CapabilityList___getitem__(self, *args)

    def __setitem__(self, *args):
        return _byteblower.CapabilityList___setitem__(self, *args)

    def pop(self):
        return _byteblower.CapabilityList_pop(self)

    def append(self, x):
        return _byteblower.CapabilityList_append(self, x)

    def empty(self):
        return _byteblower.CapabilityList_empty(self)

    def size(self):
        return _byteblower.CapabilityList_size(self)

    def swap(self, v):
        return _byteblower.CapabilityList_swap(self, v)

    def begin(self):
        return _byteblower.CapabilityList_begin(self)

    def end(self):
        return _byteblower.CapabilityList_end(self)

    def rbegin(self):
        return _byteblower.CapabilityList_rbegin(self)

    def rend(self):
        return _byteblower.CapabilityList_rend(self)

    def clear(self):
        return _byteblower.CapabilityList_clear(self)

    def get_allocator(self):
        return _byteblower.CapabilityList_get_allocator(self)

    def pop_back(self):
        return _byteblower.CapabilityList_pop_back(self)

    def erase(self, *args):
        return _byteblower.CapabilityList_erase(self, *args)

    def __init__(self, *args):
        this = _byteblower.new_CapabilityList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _byteblower.CapabilityList_push_back(self, x)

    def front(self):
        return _byteblower.CapabilityList_front(self)

    def back(self):
        return _byteblower.CapabilityList_back(self)

    def assign(self, n, x):
        return _byteblower.CapabilityList_assign(self, n, x)

    def resize(self, *args):
        return _byteblower.CapabilityList_resize(self, *args)

    def insert(self, *args):
        return _byteblower.CapabilityList_insert(self, *args)

    def reserve(self, n):
        return _byteblower.CapabilityList_reserve(self, n)

    def capacity(self):
        return _byteblower.CapabilityList_capacity(self)
    __swig_destroy__ = _byteblower.delete_CapabilityList
    __del__ = lambda self: None
CapabilityList_swigregister = _byteblower.CapabilityList_swigregister
CapabilityList_swigregister(CapabilityList)

# This file expects that the lower layer ByteBlower is included as _byteblower


class ByteBlowerPortCounterType(object):

    RxAll = _byteblower.ByteBlowerPortResultRxData_CounterType_RxAll
    """ TODO"""

    RxBroadcast = _byteblower.ByteBlowerPortResultRxData_CounterType_RxBroadcast  # noqa: E501
    """ TODO"""

    RxUnicast = _byteblower.ByteBlowerPortResultRxData_CounterType_RxUnicast
    """ TODO"""


class DeviceOsType(object):
    Android = _byteblower.DeviceOsType_Android
    """ TODO"""

    iOS = _byteblower.DeviceOsType_iOS
    """ TODO"""

    Linux = _byteblower.DeviceOsType_Linux
    """ TODO"""

    OSx = _byteblower.DeviceOsType_OSx
    """ TODO"""

    Unknown = _byteblower.DeviceOsType_Unknown
    """ TODO"""

    Windows = _byteblower.DeviceOsType_Windows
    """ TODO"""


class DeviceStatus(object):
    Available = _byteblower.DeviceStatus_Available
    """ Wireless endpoint is registered  """

    Reserved = _byteblower.DeviceStatus_Reserved
    """ Wireless endpoint is locked/used by (another) user  """

    Running = _byteblower.DeviceStatus_Running
    """ Wireless endpoint is currently running a test """

    Starting = _byteblower.DeviceStatus_Starting
    """ Wireless endpoint will start any second now with a test"""

    Unavailable = _byteblower.DeviceStatus_Unavailable
    """Wireless endpoint not available/registered"""


class EthernetEncoding(object):
    DIX = _byteblower.EthernetEncoding_DIX
    SNAP = _byteblower.EthernetEncoding_SNAP


class FrameTagType(object):
    """ The type of the FrameTag as found in a Trigger and a Frame """

    SequenceNumber = _byteblower.FrameTagType_SequenceNumber
    """This is a FrameTag with a sequence number.  """

    TimeStamp = _byteblower.FrameTagType_TimeStamp
    """This is a FrameTag with a timestamp."""


class HTTPMultiClientStatus(object):
    Configuration = _byteblower.HTTPMultiClientStatus_Configuration
    """ initial state in which the configuration takes place"""

    Finished = _byteblower.HTTPMultiClientStatus_Finished
    """ flow finished succesfully"""

    Running = _byteblower.HTTPMultiClientStatus_Running
    """ when the flow is running"""

    Scheduled = _byteblower.HTTPMultiClientStatus_Scheduled
    """ during the initial time to wait"""

    Stopped = _byteblower.HTTPMultiClientStatus_Stopped
    """ flow was stopped by user"""


class HTTPMultiServerStatus(object):
    Started = _byteblower.HTTPMultiServerStatus_Started
    """ The HTTP server is active"""
    Stopped = _byteblower.HTTPMultiServerStatus_Stopped
    """ The HTTP server is not running"""


class HTTPRequestMethod(object):
    Delete = _byteblower.HTTPRequestMethod_Delete
    """ TODO"""
    Get = _byteblower.HTTPRequestMethod_Get
    """ TODO"""
    Head = _byteblower.HTTPRequestMethod_Head
    """ TODO"""
    Options = _byteblower.HTTPRequestMethod_Options
    """ TODO"""
    Post = _byteblower.HTTPRequestMethod_Post
    """ TODO"""
    Put = _byteblower.HTTPRequestMethod_Put
    """ TODO"""
    Trace = _byteblower.HTTPRequestMethod_Trace
    """ TODO"""
    Undefined = _byteblower.HTTPRequestMethod_Undefined
    """ TODO"""


class HTTPRequestStatus(object):
    Configuration = _byteblower.HTTPRequestStatus_Configuration
    """ initial state in which the configuration takes place"""
    Connecting = _byteblower.HTTPRequestStatus_Connecting
    """ while trying to establish a connection"""
    Error = _byteblower.HTTPRequestStatus_Error
    """ if an error occurred while trying to connect or while running"""
    Finished = _byteblower.HTTPRequestStatus_Finished
    """ after the http request has completed"""
    Running = _byteblower.HTTPRequestStatus_Running
    """ while the connection is established and before http request has
    completed"""
    Scheduled = _byteblower.HTTPRequestStatus_Scheduled
    """ during the initial time to wait of a scheduled request"""
    Stopped = _byteblower.HTTPRequestStatus_Stopped
    """ after the user stopped the request"""


class HTTPRequestType(object):
    Duration = _byteblower.HTTPRequestType_Duration
    Size = _byteblower.HTTPRequestType_Size


class HTTPServerStatus(object):
    Error = _byteblower.HTTPServerStatus_Error
    """ Error occurred while initializing"""

    Running = _byteblower.HTTPServerStatus_Running
    """ The HTTP server is active"""

    Stopped = _byteblower.HTTPServerStatus_Stopped
    """ The HTTP server is not running"""

    Unknown = _byteblower.HTTPServerStatus_Unknown
    """ The server status code is not known to the client"""


class IGMPVersion(object):
    IGMPv1 = _byteblower.IGMPVersion_IGMPv1
    IGMPv2 = _byteblower.IGMPVersion_IGMPv2
    IGMPv3 = _byteblower.IGMPVersion_IGMPv3


class LinkStatus(object):
    """Link status object

    """

    Offline = _byteblower.LinkStatus_Offline
    """The ByteBlower interface is offline"""

    Online = _byteblower.LinkStatus_Online
    """ The ByteBlower interface is fully up and running"""

    Unplugged = _byteblower.LinkStatus_Unplugged
    """The ByteBlower Interface is not plugged in"""

    Unknown = _byteblower.LinkStatus_Unknown
    """ The ByteBlower Interface has an unknown status."""


class LinkType(object):
    Ethernet = _byteblower.LinkType_Ethernet
    USB = _byteblower.LinkType_USB


class LogLevel(object):
    Critical = _byteblower.LogLevel_Critical
    Debug = _byteblower.LogLevel_Debug
    Error = _byteblower.LogLevel_Error
    Info = _byteblower.LogLevel_Info
    Warning = _byteblower.LogLevel_Warning


class MLDVersion(object):
    MLDv1 = _byteblower.MLDVersion_MLDv1
    MLDv2 = _byteblower.MLDVersion_MLDv2


class ModifierType(object):
    GrowingSize = _byteblower.ModifierType_GrowingSize
    MultiBurst = _byteblower.ModifierType_MultiBurst
    NormalDistributionTiming = _byteblower.ModifierType_NormalDistributionTiming  # noqa: E501
    RandomSize = _byteblower.ModifierType_RandomSize


class MulticastSourceFilter(object):
    Exclude = _byteblower.MulticastSourceFilter_Exclude
    Include = _byteblower.MulticastSourceFilter_Include


class NetworkInterfaceType(object):
    Unknown = _byteblower.NetworkInterfaceType_Unknown
    Ethernet = _byteblower.NetworkInterfaceType_Ethernet
    Loopback = _byteblower.NetworkInterfaceType_Loopback
    WiFi = _byteblower.NetworkInterfaceType_WiFi


class PhysicalInterfaceType(object):
    NonTrunk = _byteblower.PhysicalInterfaceType_NonTrunk
    NonTrunkUSB = _byteblower.PhysicalInterfaceType_NonTrunkUSB
    Trunk = _byteblower.PhysicalInterfaceType_Trunk


class PPPoEStatus(object):
    Discovering = _byteblower.PPPoEStatus_Discovering
    Initial = _byteblower.PPPoEStatus_Initial
    Requesting = _byteblower.PPPoEStatus_Requesting
    SessionActive = _byteblower.PPPoEStatus_SessionActive
    Terminated = _byteblower.PPPoEStatus_Terminated


class RequestStartType(object):
    Direct = _byteblower.HTTPClient_RequestStartType_Direct
    Scheduled = _byteblower.HTTPClient_RequestStartType_Scheduled


class ResultDataType(object):
    Cumulative = _byteblower.ResultDataType_Cumulative
    Interval = _byteblower.ResultDataType_Interval


class RetransmissionPolicy(object):
    FixedTiming = _byteblower.RetransmissionPolicy_FixedTiming
    RfcSuggested = _byteblower.RetransmissionPolicy_RfcSuggested
    Unknown = _byteblower.RetransmissionPolicy_Unknown


class Role(object):
    Client = _byteblower.HTTPSessionInfo_Role_Client
    Server = _byteblower.HTTPSessionInfo_Role_Server


class ScheduleGroupStatus(object):
    Configuration = _byteblower.ScheduleGroupStatus_Configuration
    Error = _byteblower.ScheduleGroupStatus_Error
    Prepared = _byteblower.ScheduleGroupStatus_Prepared
    Started = _byteblower.ScheduleGroupStatus_Started
    Stopped = _byteblower.ScheduleGroupStatus_Stopped


class SequenceNumberFormat(object):
    SequenceNumber_0 = _byteblower.SequenceNumberFormat_SequenceNumber_0
    SequenceNumber_0_CRC = _byteblower.SequenceNumberFormat_SequenceNumber_0_CRC  # noqa: E501


class TCPCongestionAvoidanceAlgorithm(object):
    NewReno = _byteblower.TCPCongestionAvoidanceAlgorithm_NewReno
    NewRenoWithCubic = _byteblower.TCPCongestionAvoidanceAlgorithm_NewRenoWithCubic  # noqa: E501
    No_Algorithm = _byteblower.TCPCongestionAvoidanceAlgorithm__None
    """ TODO

    .. note:: The algorithm is actually called `None`,
              but python has this as a keyword
    """
    Sack = _byteblower.TCPCongestionAvoidanceAlgorithm_Sack
    SackWithCubic = _byteblower.TCPCongestionAvoidanceAlgorithm_SackWithCubic


class TCPConnectionState(object):
    """The state of the TCP Connection

    """

    CLOSED = _byteblower.TCPConnectionState_CLOSED
    """ Closed"""

    LISTEN = _byteblower.TCPConnectionState_LISTEN
    """Listen"""

    SYN_RECEIVED = _byteblower.TCPConnectionState_SYN_RECEIVED
    """SYN received"""

    SYN_SENT = _byteblower.TCPConnectionState_SYN_SENT
    """SYN Sent"""

    ESTABLISHED = _byteblower.TCPConnectionState_ESTABLISHED
    """Established"""

    FIN_WAIT_1 = _byteblower.TCPConnectionState_FIN_WAIT_1
    """FIN wait (number 1)"""

    FIN_WAIT_2 = _byteblower.TCPConnectionState_FIN_WAIT_2
    """FIN wait (number 2)"""
    CLOSING = _byteblower.TCPConnectionState_CLOSING
    """Closing"""

    CLOSE_WAIT = _byteblower.TCPConnectionState_CLOSE_WAIT
    LAST_ACK = _byteblower.TCPConnectionState_LAST_ACK
    TIME_WAIT = _byteblower.TCPConnectionState_TIME_WAIT


class TransmitErrorStatus(object):
    """The error status of a :class:`Stream`

    """

    UNKNOWN = _byteblower.StreamRuntimeStatus_transmit_error_status_UNKNOWN
    """Unknown error.

    This can indicate 2 things:

    - The API is outdated
    - The server encountered an error, but does not know what

    """

    NONE = _byteblower.StreamRuntimeStatus_transmit_error_status_NONE
    """No error"""

    OUT_OF_RESOURCES = _byteblower.StreamRuntimeStatus_transmit_error_status_OUT_OF_RESOURCES  # noqa: E501
    """The server went out of resources.

    The origin of the error can be queried by calling
    :meth:`StreamRuntimeStatus.ErrorSourceGet`
    """


class TransmitErrorSource(object):
    """ The source of an error of a :class:`Stream`
    """

    UNKNOWN = _byteblower.StreamRuntimeStatus_transmit_error_source_UNKNOWN
    """The stream does honestly not know where the error came from.

    This can also be returned when you encounter an error with an outdated API.
    """

    NONE = _byteblower.StreamRuntimeStatus_transmit_error_source_NONE
    """Nothing has gone wrong, this is what you want!"""

    INTERFACE_HARDWARE = _byteblower.StreamRuntimeStatus_transmit_error_source_INTERFACE_HARDWARE  # noqa: E501
    """One tries to transmit more than the interface bandwith.

    e.g. One tries to send 2 700Mbps flows on a single 1Gbps interface
    """

    SCHEDULING_CONFLICT = _byteblower.StreamRuntimeStatus_transmit_error_source_SCHEDULING_CONFLICT  # noqa: E501
    """The stream cannot keep up.

    .. deprecated:: 2.9.0
       The stream has issues to schedule all frames on the network interface.
    """

    TXUSER = _byteblower.StreamRuntimeStatus_transmit_error_source_TXUSER
    """The user is requesting too much processing power on the server"""


class TransmitStatus(object):
    """The current transmission status of a class:`Stream`
    """

    UNKNOWN = _byteblower.StreamRuntimeStatus_transmit_status_UNKNOWN
    """The server honestly does not know what the stream is doing.

    .. note:: If this happens, please contact the ByteBlower support team.
              It will indicate us that something is going wrong.
    """

    INACTIVE = _byteblower.StreamRuntimeStatus_transmit_status_INACTIVE
    """The stream is inactive and not transmitting frames.

    This can either be because the stream is not started (yet)
    or the stream has transmitted all frames as configured
    by :meth:`.Stream.NumberOfFramesSet`
    """

    ACTIVE = _byteblower.StreamRuntimeStatus_transmit_status_ACTIVE
    """The stream is active and transmitting frames"""


class TimeStampFormat(object):
    Microseconds = _byteblower.TimeStampFormat_Microseconds
    Microseconds_CRC = _byteblower.TimeStampFormat_Microseconds_CRC
    TenNanoseconds = _byteblower.TimeStampFormat_TenNanoseconds


class TimeUnit(object):
    Microseconds = _byteblower.TimeUnit_Microseconds
    Milliseconds = _byteblower.TimeUnit_Milliseconds
    Nanoseconds = _byteblower.TimeUnit_Nanoseconds
    Seconds = _byteblower.TimeUnit_Seconds

# This file is compatible with both classic and new-style classes.


