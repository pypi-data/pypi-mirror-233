# -*- coding: utf-8 -*-

"""
Created on "Datum"

from: https://stackoverflow.com/questions/2490334/simple-way-to-encode-a-string-according-to-a-password
André Herber added stuff
"""


### Fernet with password – key derived from password, weakens the security somewhat
# https://stackoverflow.com/questions/2490334/simple-way-to-encode-a-string-according-to-a-password


import os
import pickle
from base64 import urlsafe_b64decode as b64d
from base64 import urlsafe_b64encode as b64e
from random import choice
from secrets import choice as secrets_choice
from secrets import token_bytes as secrets_token_bytes
from string import ascii_letters, ascii_uppercase, digits, punctuation

from cryptography.fernet import Fernet
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from passlib.context import CryptContext

from colorful_terminal import *
from easy_tasks import main_and_sub_progress_printer, pickle_pack, pickle_unpack


backend = default_backend()


def bytes_to_data_using_pickle(data):
    return pickle.loads(data)


def data_to_bytes_using_pickle(data):
    return pickle.dumps(data)


def derive_key_from_password(
    password: bytes, salt: bytes, iterations: int = 100_000
) -> bytes:
    """Derives a key from a password using the `hashes.SHA256()` algorithm and `PBKDF2HMAC` from `cryptography.hazmat.primitives.kdf.pbkdf2`.

    Args:
        - password (bytes): Password to use in the form of bytes.
        - salt (bytes): The salt to give to PBKDF2HMAC. Could be generated by `secrets_token_bytes()` of the secrets module.
        - iterations (int, optional): The iterations to give to PBKDF2HMAC. Higher is better but takes longer. Defaults to 100_000.

    Returns:
        bytes: key
    """
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=iterations,
        backend=backend,
    )
    return b64e(kdf.derive(password))


def decrypt_data(data: bytes, key: bytes) -> bytes:
    """Decypt data using a key.

    Args:
        - data (bytes): Encrypted data to decrypt.
        - key (bytes): Key to use.

    Returns:
        bytes: Decrypted data.
    """
    fernet = Fernet(key)
    decrypted = fernet.decrypt(data)
    return decrypted


def decrypt_directory(
    target_dir_path: str,
    enc_dir_path: str,
    keypath: str | None | bytes,
    override_target: bool = True,
):
    """Decrypts all files in a directory. Keeps the original directory structure.

    Args:
        - target_dir_path (str): Path for the decrypted directory.
        - enc_dir_path (str): Path to the encrypted directory.
        - keypath (str | None | bytes): Path to the key or alternativley the key itself.
        - override_target (bool, optional): Override the target files if they already exist. Defaults to False.
    """
    enc_dir_path = os.path.normpath(enc_dir_path)

    l1 = len(list(os.walk(enc_dir_path)))

    main_and_sub_progress_printer(
        0,
        l1,
        0,
        0,
        mainpre_string="Progress on dirpaths: ",
        subpre_string="Progress on files in current dir: ",
    )
    for main_index, (root, dirs, files) in enumerate(os.walk(enc_dir_path)):
        sub_path = root.replace(enc_dir_path, "")
        sub_path = sub_path.lstrip("\\")
        l2 = len(files)
        for sub_index, f in enumerate(files):
            fp = os.path.join(root, f)
            nfp = os.path.join(target_dir_path, sub_path, f)
            decrypt_file(nfp, fp, keypath, override_target)
            main_and_sub_progress_printer(
                main_index + 1,
                l1,
                sub_index + 1,
                l2,
                mainpre_string="Progress on dirpaths: ",
                subpre_string="Progress on files in current dir: ",
            )


def decrypt_file(
    to_be_filepath: str,
    enc_filepath: str,
    keypath: str | bytes,
    override_target: bool = False,
):
    """Decrypt a file using the generated key. The file was decrypted with encrypt_file.

    Args:
        - to_be_filepath (str): The path at which the file shall be generated, including the filename.
        - enc_filepath (str): The path to the encrypted file.
        - keypath (str | bytes): The path to the key or alternativley the key itself.
        - override_target (bool, optional): Override the target file if it already exists. Defaults to False.
    """
    if isinstance(keypath, str):
        with open(keypath, "rb") as f:
            key = f.read()
    else:
        key = keypath
    fernet = Fernet(key)
    with open(enc_filepath, "rb") as encrypted_file:
        encrypted = encrypted_file.read()
    decrypted = fernet.decrypt(encrypted)
    filename, fileext = os.path.splitext(os.path.basename(to_be_filepath))
    basepath = os.path.dirname(to_be_filepath)
    if not os.path.isdir(basepath):
        os.makedirs(basepath)
    pre_filepath = os.path.join(basepath, filename)
    with open(pre_filepath, "wb") as decrypted_file:
        decrypted_file.write(decrypted)
    if os.path.isdir(to_be_filepath):
        os.removedirs(to_be_filepath)
    if override_target:
        if os.path.isfile(to_be_filepath):
            os.remove(to_be_filepath)
    os.rename(pre_filepath, to_be_filepath)


def decrypt_file_with_password(
    to_be_filepath: str,
    enc_filepath: str,
    keypath: str,
    password: str,
    override_target: bool = False,
):
    """Decrypt a file using a password. The file was decrypted using encrypt_file_with_password.

    Args:
        - to_be_filepath (str): The path at which the file shall be generated, including the filename.
        - enc_filepath (str): The path to the encrypted file.
        - keypath (str): The path to the encrypted key.
        - password (str): The password to decrypt the actual key.
        - override_target (bool, optional): Override the target file if it already exists. Defaults to False.
    """
    with open(keypath, "rb") as f:
        enc_key = f.read()
    key = decrypt_string_with_password(enc_key, password)
    fernet = Fernet(key)
    with open(enc_filepath, "rb") as encrypted_file:
        encrypted = encrypted_file.read()
    decrypted = fernet.decrypt(encrypted)
    filename, fileext = os.path.splitext(os.path.basename(to_be_filepath))
    basepath = os.path.dirname(to_be_filepath)
    if not os.path.isdir(basepath):
        os.makedirs(basepath)
    pre_filepath = os.path.join(basepath, filename)
    with open(pre_filepath, "wb") as decrypted_file:
        decrypted_file.write(decrypted)
    if os.path.isdir(to_be_filepath):
        os.removedirs(to_be_filepath)
    if override_target:
        if os.path.isfile(to_be_filepath):
            os.remove(to_be_filepath)
    os.rename(pre_filepath, to_be_filepath)


def decrypt_hidden_directory_old(
    target_dir_path: str,
    enc_dir_path: str,
    enc_rename_path: str,
    keypath: str | bytes = None,
):
    """Decrypt a hidden directory. This is the decrytion function to `encrypt_and_hide_directory`.

    Args:
        target_dir_path (str): Path for the decrypted directory.
        enc_dir_path (str): Path to the encrypted directory.
        enc_rename_path (str): Path for the encrypted file containing the directory which has the new and the old file and directory names.
        keypath (str | bytes, optional): Path to the key or alternativley the key itself. Defaults to None.
    """
    colored_print(Fore.GREEN + "decrypt_hidden_directory")
    print("Reading names for directory contents...")

    if isinstance(keypath, str):
        with open(keypath, "rb") as f:
            key = f.read()
    elif isinstance(keypath, bytes):
        key = keypath

    renamed_to_path_enc = pickle_unpack(enc_rename_path)
    renamed_to_path_bytes = decrypt_data(renamed_to_path_enc, key)
    renamed_to_path = bytes_to_data_using_pickle(renamed_to_path_bytes)
    renamed_to_path: dict[str, str]

    print("Renaming directory contents...")
    for seq, fp in list(renamed_to_path.items())[::-1]:
        os.rename(seq, fp)

    print("Decrypting directory...")
    decrypt_directory(target_dir_path, enc_dir_path, key, True)

    if target_dir_path != enc_dir_path:
        print("Renaming directory contents...")
        for seq, fp in renamed_to_path.items():
            os.rename(fp, seq)

    print("Decryption done.\n")


def decrypt_hidden_directory(
    target_dir_path: str,
    enc_dir_path: str,
    enc_rename_path: str,
    key: bytes = None,
    keypath: str = None,
):
    """Decrypt a hidden directory. This is the decrytion function to `encrypt_and_hide_directory`.

    Args:
        target_dir_path (str): Path for the decrypted directory.
        enc_dir_path (str): Path to the encrypted directory.
        enc_rename_path (str): Path for the encrypted file containing the directory which has the new and the old file and directory names.
        key (bytes, optional): Key as bytes. Defaults to None.
        keypath (str | bytes, optional): Path to the key or alternativley the key itself. Defaults to None.
    """
    colored_print(Fore.GREEN + "decrypt_hidden_directory")
    print("Reading names for directory contents...")
    # renamed_to_path = pickle_unpack(rename_path)

    if keypath != None:
        with open(keypath, "rb") as f:
            key = f.read()
    renamed_to_path_enc = pickle_unpack(enc_rename_path)
    renamed_to_path_bytes = decrypt_data(renamed_to_path_enc, key)
    renamed_to_path = bytes_to_data_using_pickle(renamed_to_path_bytes)
    renamed_to_path: dict[str, str]

    print("Renaming directory contents...")
    for seq, fp in list(renamed_to_path.items())[::-1]:
        os.rename(seq, fp)

    print("Decrypting directory...")
    decrypt_directory(target_dir_path, enc_dir_path, key, True)

    if target_dir_path != enc_dir_path:
        print("Renaming directory contents...")
        for seq, fp in renamed_to_path.items():
            os.rename(fp, seq)

    print("Decryption done.\n")


def decrypt_secret(encrypted_secret, password: str, salt):
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=400000,
    )

    key = b64e(kdf.derive(password.encode()))

    f = Fernet(key)

    secret_msg = f.decrypt(encrypted_secret)
    secret_msg = secret_msg.decode()

    return secret_msg


def decrypt_string_with_password(token: bytes, password: str) -> str:
    """Decrypt a message aka token using a password.

    Args:
        - token (bytes): Your massage aka token.
        - password (str): The password.

    Returns:
        str: The decrypted message.
    """
    decoded = b64d(token)
    salt, iter, token = decoded[:16], decoded[16:20], b64e(decoded[20:])
    iterations = int.from_bytes(iter, "big")
    key = derive_key_from_password(password.encode(), salt, iterations)
    pw = Fernet(key).decrypt(token).decode()
    return pw


def dehide_directory(
    enc_rename_path: str,
    key: bytes = None,
):
    """From random names to original names (backwards hide_directory)."""
    renamed_to_path_enc = pickle_unpack(enc_rename_path)
    renamed_to_path_bytes = decrypt_data(renamed_to_path_enc, key)
    renamed_to_path = bytes_to_data_using_pickle(renamed_to_path_bytes)
    renamed_to_path: dict[str, str]

    print("Renaming directory contents...")
    for seq, fp in list(renamed_to_path.items())[::-1]:
        os.rename(seq, fp)


def encrypt_and_hide_directory(
    dir_path: str,
    enc_dir_path: str,
    enc_rename_path: str,
    key: bytes = None,
    keypath: str = None,
    ignore_permission_denied: bool = True,
):
    """Encrypt and hide a directory. You might want to encrypt the key with a password using `save_password_encrypted_key`.

    Args:
        dir_path (str): Path to the directory to be encypted.
        enc_dir_path (str): Target path to the encrypted directory.
        enc_rename_path (str): Path for the encrypted file containing the directory which has the new and the old file and directory names.
        key (bytes, optional): You can provide your own key. Defaults to None.
        keypath (str, optional): Path for the file containing the unprotected key. Defaults to None.

    Returns:
        bytes: Returns the used key.
    """
    colored_print(Fore.GREEN + "encrypt_and_hide_directory")
    print("Encrypting directory...")

    key, fails = encrypt_directory(
        dir_path,
        enc_dir_path,
        keypath,
        key,
        error_if_enc_is_file=False,
        ignore_permission_denied=ignore_permission_denied,
    )
    if len(fails) != 0:
        print("Failed to encrypt these files:", fails)

    print("Directory encrypted.")

    print("Getting new names for directory contents...")

    seq_to_path = {}
    for dirpath, dirnames, filenames in os.walk(enc_dir_path, topdown=False):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            seq = get_seq_for_seq_to_path(dirpath, seq_to_path)
            seq_to_path[seq] = fp
        for f in dirnames:
            fp = os.path.join(dirpath, f)
            seq = get_seq_for_seq_to_path(dirpath, seq_to_path)
            seq_to_path[seq] = fp

    seq_to_path_bytes = data_to_bytes_using_pickle(seq_to_path)
    seq_to_path_enc, k = encrypt_data(seq_to_path_bytes, key)

    print("Saving new names for directory contents...")
    # pickle_pack(seq_to_path, rename_path)
    pickle_pack(seq_to_path_enc, enc_rename_path)

    print("Renaming directory contents...")
    for seq, fp in seq_to_path.items():
        try:
            os.rename(fp, seq)
        except:
            fails.append((fp, seq))

    print("Encryption done.\n")
    return key, fails


def encrypt_data(data: bytes, key: bytes = None) -> tuple[bytes]:
    """Encypt data using a key. The data must be bytes. You can provide your own key if you want.
     Data can be converted to bytes using pickle. For convenience there is a `data_to_bytes_using_pickle` function which literally is `pickle.dumps(data)`.

    Args:
        - data (bytes): Data to encrypt.
        - key (bytes, optional): Specified key to use. Defaults to None.

    Returns:
        tuple[bytes]: Tuple containing the encrypted data and the key.
    """
    if key == None:
        key = Fernet.generate_key()
    fernet = Fernet(key)
    encrypted = fernet.encrypt(data)
    return (encrypted, key)


def encrypt_directory(
    dir_path: str,
    enc_dir_path: str,
    keypath: str | None = None,
    key: bytes = None,
    error_if_enc_is_file: bool = True,
    ignore_permission_denied: bool = True,
):
    """Uses `encrypt_file` for all files in a directory. Keeps the original directory structure.

    Args:
        - dir_path (str): Path to the directory to encrypt.
        - enc_dir_path (str): Path for the encrypted directory.
        - keypath (str | None, optional): Path for the key to be saved at, including the filename. Defaults to None, meaning it won't be saved.
        - key (bytes, optional): You can provide a specific key here. Defaults to None.
        - error_if_enc_is_file (bool, optional): Raise an exception if enc_filepath is already a file. Defaults to True.

    Returns:
        bytes: The used key.
    """
    dir_path = os.path.normpath(dir_path)
    if key == None:
        key = get_random_key()

    l1 = len(list(os.walk(dir_path)))

    main_and_sub_progress_printer(
        0,
        l1,
        0,
        0,
        mainpre_string="Progress on dirpaths: ",
        subpre_string="Progress on files in current dir: ",
    )
    fails = []
    for main_index, (root, dirs, files) in enumerate(os.walk(dir_path)):
        sub_path = root.replace(dir_path, "")
        sub_path = sub_path.lstrip("\\")
        l2 = len(files)
        for sub_index, f in enumerate(files):
            fp = os.path.join(root, f)
            nfp = os.path.join(enc_dir_path, sub_path, f)
            if ignore_permission_denied:
                try:
                    encrypt_file(fp, nfp, keypath, key, error_if_enc_is_file, False)
                except PermissionError:
                    fails.append(fp)
            else:
                encrypt_file(fp, nfp, keypath, key, error_if_enc_is_file, False)
            main_and_sub_progress_printer(
                main_index + 1,
                l1,
                sub_index + 1,
                l2,
                mainpre_string="Progress on dirpaths: ",
                subpre_string="Progress on files in current dir: ",
            )
    return key, fails


def encrypt_file(
    filepath: str,
    enc_filepath: str,
    keypath: str | None = None,
    key: bytes = None,
    error_if_enc_is_file: bool = True,
    error_if_key_is_file: bool = True,
):
    """Encrypt a file and save the unprotected key as a file under the specified location.

    Args:
        - filepath (str): The path to the file.
        - enc_filepath (str): The path for the encrypted file, including the filename.
        - keypath (str | None): The path for the unprotected key, including the filename. Defaults to None, meaning it won't be saved.
        - key (bytes, optional): You can reuse the key of earlier encryptions or generate a key using the function get_random_key. Defaults to None.
        - error_if_enc_is_file (bool, optional): Raise an exception if enc_filepath is already a file. Defaults to True.
        - error_if_key_is_file (bool, optional): Raise an exception if keypath is already a file. Defaults to True.

    Returns:
        bytes: The key generated by Fernet.generate_key()
    """
    if error_if_enc_is_file and os.path.isfile(enc_filepath):
        raise FileExistsError(
            f"There is already a file in the enc_filepath location.\n\tenc_filepath: {enc_filepath}"
        )
    if key == None:
        key = Fernet.generate_key()
    if not os.path.isdir(os.path.dirname(enc_filepath)):
        os.makedirs(os.path.dirname(enc_filepath))
    if keypath != None:
        if not os.path.isdir(os.path.dirname(keypath)):
            os.makedirs(os.path.dirname(keypath))
        if error_if_key_is_file and os.path.isfile(keypath):
            raise FileExistsError(
                f"There is already a file in the keypath location.\n\tkeypath: {keypath}"
            )
        with open(keypath, "wb") as f:
            f.write(key)
    fernet = Fernet(key)
    with open(filepath, "rb") as original_file:
        original = original_file.read()
    encrypted = fernet.encrypt(original)
    with open(enc_filepath, "wb") as encrypted_file:
        encrypted_file.write(encrypted)
    return key


def encrypt_file_with_password(
    filepath: str,
    enc_filepath: str,
    password: str,
    keypath: str | None = None,
    error_if_enc_is_file: bool = True,
    error_if_key_is_file: bool = True,
):
    """Encrypt a file and save the encrypted key as a file. The key will be encrypted using a password and the function encrypt_string_with_password.

    Args:
        - filepath (str): The path to the file.
        - enc_filepath (str): The path for the encrypted file, including the filename.
        - keypath (str | None): The path for the unprotected key, including the filename. Defaults to None, meaning it won't be saved.
        - password (str): Your password.
    """
    if error_if_enc_is_file and os.path.isfile(enc_filepath):
        raise FileExistsError(
            f"There is already a file in the enc_filepath location.\n\tenc_filepath: {enc_filepath}"
        )
    if error_if_key_is_file and os.path.isfile(keypath):
        raise FileExistsError(
            f"There is already a file in the keypath location.\n\tkeypath: {keypath}"
        )
    key = Fernet.generate_key()
    encryptet_key = encrypt_string_with_password(key, password)
    if not os.path.isdir(os.path.dirname(enc_filepath)):
        os.makedirs(os.path.dirname(enc_filepath))
    if not os.path.isdir(os.path.dirname(keypath)):
        os.makedirs(os.path.dirname(keypath))
    with open(keypath, "wb") as f:
        f.write(encryptet_key)
    fernet = Fernet(key)
    with open(filepath, "rb") as original_file:
        original = original_file.read()
    encrypted = fernet.encrypt(original)
    with open(enc_filepath, "wb") as encrypted_file:
        encrypted_file.write(encrypted)


def encrypt_secret(secret, password: str):
    """
    -> encrypted_secret, salt
    """
    salt = os.urandom(16)

    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=400000,
    )

    key = b64e(kdf.derive(password.encode()))

    f = Fernet(key)

    encrypted_secret = f.encrypt(secret.encode())

    return encrypted_secret, salt


def encrypt_string_with_password(
    message: str, password: str, iterations: int = 100000
) -> bytes:
    """Encrypt a message using a password. Iterations have an influence on the safety, the higher the stonger the longer the computation time.

    Args:
        - message (str): Message to encyrypt.
        - password (str): Password to use.
        - iterations (int, optional): Iterations have an influence on the safety, the higher the stonger the longer the computation time. Defaults to 100000.

    Returns:
        bytes: Encrypted message.
    """
    if type(message) != bytes:
        message = message.encode()
    salt = secrets_token_bytes(16)
    key = derive_key_from_password(password.encode(), salt, iterations)
    return b64e(
        b"%b%b%b"
        % (
            salt,
            iterations.to_bytes(4, "big"),
            b64d(Fernet(key).encrypt(message)),
        )
    )


def generate_password(length=16):
    chars = ascii_letters + punctuation + digits
    password = str()
    while True:
        password = "".join(secrets_choice(chars) for i in range(length))
        if (
            any(c.islower() for c in password)
            and any(c.isupper() for c in password)
            # and sum(c.isdigit() for c in password) >= 3
            and any(c.isdigit() for c in password)
            and any(punctuation)
        ):
            break

    return password


def generate_semi_random_alphanumeric_string(length=25):
    """NOT SECURE! DO NOT USE FOR PASSWORDS!!!"""
    chars = ascii_uppercase + digits
    random_str = "".join(choice(chars) for _ in range(length))
    return random_str


def get_random_key():
    """Generate a random key.

    Returns:
        bytes: The key generated by Fernet.generate_key()
    """
    return Fernet.generate_key()


def get_seq_for_seq_to_path(dirpath, seq_to_path=None):
    "A function for `encrypt_and_hide_directory`"
    seq = os.path.join(dirpath, generate_semi_random_alphanumeric_string())
    # while seq in seq_to_path.keys():
    #     seq = os.path.join(dirpath, generate_semi_random_alphanumeric_string())
    return seq


def hash_password_with_argon2(password: str, argon2_default_rounds=55):
    """Hash a password using argon2. Hashed passwords can be used to ckeck wheather you know the real password with the help of the function `verfiy_hashed_password_with_argon2`.

    Args:
        - password (str): Password to hash.
        - argon2_default_rounds (int, optional): Rounds of the default argon2 hash function. Defaults to 55.

    Returns:
        str: Hashed password.
    """
    context = CryptContext(
        schemes=["argon2"],
        default="argon2",
        argon2__default_rounds=argon2_default_rounds,
    )
    hashed_password = context.hash(password)
    return hashed_password


def hide_directory(
    enc_dir_path: str,
    enc_rename_path: str,
    key: bytes = None,
):
    print("Getting new names for directory contents...")
    if key == None:
        key = get_random_key()

    seq_to_path = {}
    for dirpath, dirnames, filenames in os.walk(enc_dir_path, topdown=False):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            seq = get_seq_for_seq_to_path(dirpath, seq_to_path)
            seq_to_path[seq] = fp
        for f in dirnames:
            fp = os.path.join(dirpath, f)
            seq = get_seq_for_seq_to_path(dirpath, seq_to_path)
            seq_to_path[seq] = fp

    seq_to_path_bytes = data_to_bytes_using_pickle(seq_to_path)
    seq_to_path_enc, k = encrypt_data(seq_to_path_bytes, key)

    print("Saving new names for directory contents...")
    # pickle_pack(seq_to_path, rename_path)
    pickle_pack(seq_to_path_enc, enc_rename_path)

    print("Renaming directory contents...")
    fails = []
    for seq, fp in seq_to_path.items():
        try:
            os.rename(fp, seq)
        except:
            fails.append((fp, seq))
    return key, fails


def load_password_encrypted_key(
    keypath: str,
    password: str | None = None,
):
    """Load the password encrypted key from a file.

    Args:
        - keypath (str): Path to the file containing the password encrypted key.
        - password (str | None, optional): If the key is password encrypted, you obviously need the password. Defaults to None.

    Returns:
        str: The decrypted key.
    """
    with open(keypath, "rb") as f:
        encrypted_key = f.read()
    return decrypt_string_with_password(encrypted_key, password).encode()


def password_decrypt_non_string(token: bytes, password: str):
    decoded = b64d(token)
    salt, iter, token = decoded[:16], decoded[16:20], b64e(decoded[20:])
    iterations = int.from_bytes(iter, "big")
    key = derive_key_from_password(password.encode(), salt, iterations)
    pw = Fernet(key).decrypt(token).decode()
    return pw


def password_encrypt_bytes(
    message: bytes, password: str, iterations: int = 100_000
) -> bytes:
    salt = secrets_token_bytes(16)
    key = derive_key_from_password(password.encode(), salt, iterations)
    return b64e(
        b"%b%b%b"
        % (
            salt,
            iterations.to_bytes(4, "big"),
            b64d(Fernet(key).encrypt(message)),
        )
    )


def save_password_encrypted_key(
    key: bytes,
    keypath: str,
    password: str | None = None,
    error_if_key_is_file: bool = True,
):
    """Save the key returned by an encryption function. You can but don't have to encrypt the key with a password.

    Args:
        - key (bytes): Key returned by an encryption function.
        - keypath (str): The path for the key to be written to.
        - password (str | None, optional): A password to encrypt the key. Defaults to None.
        - error_if_key_is_file (bool, optional): Throw an exception if there already is a file. Defaults to True.

    Raises:
        FileExistsError: If keypath is occupied.
    """
    if error_if_key_is_file and os.path.isfile(keypath):
        raise FileExistsError(
            f"There is already a file in the keypath location.\n\tkeypath: {keypath}"
        )
    if password != None:
        encryptet_key = encrypt_string_with_password(key, password)
    else:
        encryptet_key = key
    keypath_parent = os.path.dirname(keypath)
    if not os.path.isdir(keypath_parent):
        os.makedirs(keypath_parent)
    with open(keypath, "wb") as f:
        f.write(encryptet_key)


def verfiy_hashed_password_with_argon2(
    password: str, hashed_password, argon2_default_rounds=55
):
    """Verify a password using argon2. Input the hashed password and the password to be verified to check wheather you know the real password.

    Args:
        - password (str): Password to be verified.
        - hashed_password (bool): Hashed password.
        - argon2_default_rounds (int, optional): Rounds of the default argon2 hash function. Defaults to 55.

    Returns:
        bool: True if the password is correct, False otherwise.
    """
    _cryptcontext = CryptContext(
        schemes=["argon2"],
        default="argon2",
        argon2__default_rounds=argon2_default_rounds,
    )
    crypt_check = _cryptcontext.verify(password, hashed_password)
    return crypt_check


if __name__ == "__main__":
    # encrypt_directory(
    #     r"Code Sammlung\Passwort",
    #     r"C:\Users\Creed\OneDrive\Schul-Dokumente\Programmieren\Python\Code Sammlung\mehr\test",
    #     r"C:\Users\Creed\OneDrive\Schul-Dokumente\Programmieren\Python\Code Sammlung\mehr\KEY",
    # )
    decrypt_directory(
        r"Code Sammlung\Passwort2",
        r"C:\Users\Creed\OneDrive\Schul-Dokumente\Programmieren\Python\Code Sammlung\mehr\test",
        r"C:\Users\Creed\OneDrive\Schul-Dokumente\Programmieren\Python\Code Sammlung\mehr\KEY",
    )
