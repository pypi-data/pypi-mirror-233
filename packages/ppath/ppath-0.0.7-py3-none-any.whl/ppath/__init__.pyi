import contextlib
import dataclasses
import io
import os
import pathlib
from collections.abc import Iterable, Iterator
from dataclasses import Field, InitVar, dataclass
from typing import IO, Any, AnyStr, Generic, Literal, TypeAlias, TypeVar

import pproj

__all__: tuple = (
    "PathAccessor",
    "Path",
    "Passwd",
    "AnyPath",
)

_T = TypeVar("_T")
_Is: TypeAlias = Literal["exists", "is_dir", "is_file"]

class PathAccessor:
    stat: type[os.stat] = ...
    open: type[io.open] = ...  # noqa: A003
    listdir: type[os.listdir] = ...
    scandir: type[os.scandir] = ...
    chmod: type[os.chmod] = ...
    mkdir: type[os.mkdir] = ...
    unlink: type[os.unlink] = ...
    link: type[os.link] = ...
    rmdir: type[os.rmdir] = ...
    rename: type[os.rename] = ...
    replace: type[os.replace] = ...
    symlink: type[os.symlink] = ...

    def touch(
        self: Path, path: AnyPath, mode: int = ..., exist_ok: bool = ...
    ) -> None: ...

    readlink: type[os.link] = ...

    def owner(self: Path, path: AnyPath) -> str | None: ...
    def group(self: Path, path: AnyPath) -> str | None: ...

    getcwd: type[os.getcwd] = ...
    expanduser: type[pathlib._NormalAccessor.expanduser] = ...
    realpath: type[pathlib._NormalAccessor.realpath] = ...

class Path(pathlib.Path, pathlib.PurePosixPath, Generic[_T]):
    _accessor: PathAccessor = ...

    def __call__(
        self,
        name: AnyPath = ...,
        file: _Is = ...,
        passwd: Passwd | None = ...,
        mode: int | str = ...,
        effective_ids: bool = ...,
        follow_symlinks: bool = ...,
    ) -> Path: ...
    def __new__(cls: type[Path], *args: AnyPath, **kwargs: Any) -> Path | None: ...
    def __contains__(self, value: Iterable) -> bool: ...
    def __eq__(self, other: Path) -> bool: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator[_T]: ...
    def __lt__(self, other: Path) -> bool: ...
    def __le__(self, other: Path) -> bool: ...
    def __gt__(self, other: Path) -> bool: ...
    def __ge__(self, other: Path) -> bool: ...
    @property
    def _cparts(self) -> list[str]: ...
    @property
    def _parts(self) -> list[str]: ...
    def access(
        self,
        os_mode: int = ...,
        *,
        dir_fd: int | None = ...,
        effective_ids: bool = ...,
        follow_symlinks: bool = ...
    ) -> bool | None: ...
    def add(self, *args: str, exception: bool = ...) -> Path: ...
    def append_text(self, text: str, encoding: str = ..., errors=...) -> str: ...
    @contextlib.contextmanager
    def cd(self) -> Path: ...
    def chdir(self) -> Path: ...
    def checksum(
        self,
        algorithm: Literal["md5", "sha1", "sha224", "sha256", "sha384", "sha512"] = ...,
        block_size: int = ...,
    ) -> str: ...
    def chmod(
        self,
        mode: int | str | None = ...,
        effective_ids: bool = ...,
        exception: bool = ...,
        follow_symlinks: bool = ...,
        recursive: bool = ...,
    ) -> Path: ...
    def chown(
        self,
        passwd: Passwd | str = ...,
        effective_ids: bool = ...,
        exception: bool = ...,
        follow_symlinks: bool = ...,
        recursive: bool = ...,
    ) -> Path: ...
    def cmp(self, other: AnyPath) -> bool: ...
    def cp(
        self,
        dest: AnyPath,
        contents: bool = False,
        effective_ids: bool = ...,
        follow_symlinks: bool = ...,
        preserve: bool = ...,
    ) -> Path: ...
    def exists(self) -> bool: ...
    @classmethod
    def expandvars(cls, path: str | None = ...) -> Path: ...
    def file_in_parents(
        self, exception: bool = ..., follow_symlinks: bool = ...
    ) -> Path | None: ...
    def find_up(
        self, function: _Is = ..., name: str = ..., uppermost: bool = ...
    ) -> Path | None: ...
    def has(self, value: Iterable) -> bool: ...
    def ln(self, dest: AnyPath, force: bool = ...) -> Path: ...
    def mkdir(
        self,
        name: AnyPath = ...,
        passwd: Passwd | None = ...,
        mode: int | str = ...,
        effective_ids: bool = ...,
        follow_symlinks: bool = ...,
    ) -> Path: ...
    def mv(self, dest: Path | str) -> Path: ...
    def open(  # noqa: A003
        self,
        mode: str = ...,
        buffering: int = ...,
        encoding: str = ...,
        errors: str = ...,
        newline: str = ...,
        token: bool = ...,
    ) -> pproj.AnyIO | None: ...
    def realpath(self, exception: bool = ...) -> Path: ...
    def relative(self, path: Path | str) -> Path | None: ...
    def rm(
        self,
        *args: str,
        effective_ids: bool = ...,
        follow_symlinks: bool = ...,
        missing_ok: bool = ...
    ) -> None: ...
    def rm_empty(self, preserve: bool = ...) -> None: ...
    def setid(self, name: bool | str | None, uid: bool = ...) -> Path: ...
    def setid_cp(self, name: bool | str | None, uid: bool = ...) -> Path: ...
    def setid_executable_cp(self, name: str | None, uid: bool = ...) -> Path: ...
    def stats(self, follow_symlinks: bool = ...) -> PathStat: ...
    def sudo(
        self,
        force: bool = ...,
        to_list: bool = ...,
        os_mode: int = ...,
        effective_ids: bool = ...,
        follow_symlinks: bool = ...,
    ) -> list[str] | str | None: ...
    @property
    def text(self) -> str: ...
    @classmethod
    @contextlib.contextmanager
    def tempcd(
        cls,
        suffix: AnyStr | None = ...,
        prefix: AnyStr | None = ...,
        directory: AnyPath | None = ...,
    ) -> Path: ...
    @classmethod
    @contextlib.contextmanager
    def tempdir(
        cls,
        suffix: AnyStr | None = ...,
        prefix: AnyStr | None = ...,
        directory: AnyPath | None = ...,
    ) -> Path: ...
    @classmethod
    @contextlib.contextmanager
    def tempfile(
        cls,
        mode: Literal[
            "r",
            "w",
            "a",
            "x",
            "r+",
            "w+",
            "a+",
            "x+",
            "rt",
            "wt",
            "at",
            "xt",
            "r+t",
            "w+t",
            "a+t",
            "x+t",
        ] = ...,
        buffering: int = ...,
        encoding: str | None = ...,
        newline: str | None = ...,
        suffix: AnyStr | None = ...,
        prefix: AnyStr | None = ...,
        directory: AnyPath | None = ...,
        delete: bool = ...,
        *,
        errors: str | None = ...
    ) -> Path: ...
    def to_parent(self) -> Path: ...
    def touch(
        self,
        name: AnyPath = ...,
        passwd: Passwd | None = ...,
        mode: int | str = ...,
        effective_ids: bool = ...,
        follow_symlinks: bool = ...,
    ) -> Path: ...
    def with_suffix(self, suffix: str = ...) -> Path: ...

@dataclass
class Passwd:
    data: InitVar[int | str | Path] = ...
    gid: int | str | Field = ...
    gecos: str | Field = ...
    group: str | Field = ...
    groups: dict[str, int] | Field = ...
    home: Path | Field = ...
    shell: Field = ...
    uid: int | str | Field = ...
    user: str | Field = ...

    def __init__(self, data: int | str | Path = ...) -> None: ...
    def __post_init__(self, data: int | str | Path = ...) -> None: ...
    @property
    def is_su(self) -> bool: ...
    @property
    def is_sudo(self) -> bool: ...
    @property
    def is_user(self) -> bool: ...
    @classmethod
    def from_login(cls) -> Passwd: ...
    @classmethod
    def from_root(cls) -> Passwd: ...
    @classmethod
    def from_sudo(cls) -> Passwd: ...

@dataclasses.dataclass
class PathStat:
    gid: int
    group: str
    mode: str
    own: str
    passwd: Passwd
    result: os.stat_result
    root: bool
    sgid: bool
    sticky: bool
    suid: bool
    uid: int
    user: str

AnyPath: TypeAlias = Path | pathlib.Path | os.PathLike | AnyStr | IO[AnyStr]
