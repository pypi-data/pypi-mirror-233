"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from .sdkconfiguration import SDKConfiguration
from orb import utils
from orb.models import errors, operations, shared
from typing import Optional, Union

class Credit:
    r"""The [Credit Ledger Entry resource](/guides/product-catalog/prepurchase) models prepaid credits within Orb."""
    sdk_configuration: SDKConfiguration

    def __init__(self, sdk_config: SDKConfiguration) -> None:
        self.sdk_configuration = sdk_config
        
    
    def add_by_external_id(self, external_customer_id: Optional[str], add_credit_ledger_entry_request_params: Optional[Union[shared.AddIncrementCreditLedgerEntryRequestParams, shared.AddDecrementCreditLedgerEntryRequestParams, shared.AddExpirationChangeCreditLedgerEntryRequestParams, shared.AddVoidCreditLedgerEntryRequestParams]] = None) -> operations.CreateLedgerEntryExternalIDResponse:
        r"""Create ledger entry by external ID"""
        request = operations.CreateLedgerEntryExternalIDRequest(
            external_customer_id=external_customer_id,
            add_credit_ledger_entry_request_params=add_credit_ledger_entry_request_params,
        )
        
        base_url = utils.template_url(*self.sdk_configuration.get_server_details())
        
        url = utils.generate_url(operations.CreateLedgerEntryExternalIDRequest, base_url, '/customers/external_customer_id/{external_customer_id}/credits/ledger_entry', request)
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "add_credit_ledger_entry_request_params", False, True, 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        headers['Accept'] = 'application/json'
        headers['user-agent'] = self.sdk_configuration.user_agent
        
        client = self.sdk_configuration.security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateLedgerEntryExternalIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.IncrementLedgerEntry, shared.DecrementLedgerEntry, shared.ExpirationChangeLedgerEntry, shared.CreditBlockExpiryLedgerEntry, shared.VoidLedgerEntry, shared.VoidInitiatedLedgerEntry, shared.AmendmentLedgerEntry]])
                res.credit_ledger_entry = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.RequestValidationError, shared.DuplicateResourceCreationError, shared.DuplicateConstraintViolationError]])
                res.four_hundred_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FourHundredAndOneError])
                res.four_hundred_and_one_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.ResourceNotFoundError, shared.FeatureNotAvailableError, shared.URLNotFound]])
                res.four_hundred_and_four_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 409:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.IdempotencyConflict, shared.IdempotencyRequestMismatch, shared.IdempotencyKeyValidationError]])
                res.four_hundred_and_nine_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 413:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.RequestTooLargeError, shared.ResourceTooLargeError]])
                res.four_hundred_and_thirteen_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 429:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FourHundredAndTwentyNineError])
                res.four_hundred_and_twenty_nine_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 500:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FiveHundredError])
                res.five_hundred_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)

        return res

    
    def create(self, customer_id: Optional[str], add_credit_ledger_entry_request_params: Optional[Union[shared.AddIncrementCreditLedgerEntryRequestParams, shared.AddDecrementCreditLedgerEntryRequestParams, shared.AddExpirationChangeCreditLedgerEntryRequestParams, shared.AddVoidCreditLedgerEntryRequestParams]] = None) -> operations.CreateLedgerEntryResponse:
        r"""Create ledger entry"""
        request = operations.CreateLedgerEntryRequest(
            customer_id=customer_id,
            add_credit_ledger_entry_request_params=add_credit_ledger_entry_request_params,
        )
        
        base_url = utils.template_url(*self.sdk_configuration.get_server_details())
        
        url = utils.generate_url(operations.CreateLedgerEntryRequest, base_url, '/customers/{customer_id}/credits/ledger_entry', request)
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, "add_credit_ledger_entry_request_params", False, True, 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        headers['Accept'] = 'application/json'
        headers['user-agent'] = self.sdk_configuration.user_agent
        
        client = self.sdk_configuration.security_client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.CreateLedgerEntryResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 201:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.IncrementLedgerEntry, shared.DecrementLedgerEntry, shared.ExpirationChangeLedgerEntry, shared.CreditBlockExpiryLedgerEntry, shared.VoidLedgerEntry, shared.VoidInitiatedLedgerEntry, shared.AmendmentLedgerEntry]])
                res.credit_ledger_entry = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.RequestValidationError, shared.DuplicateResourceCreationError, shared.DuplicateConstraintViolationError]])
                res.four_hundred_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FourHundredAndOneError])
                res.four_hundred_and_one_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.ResourceNotFoundError, shared.FeatureNotAvailableError, shared.URLNotFound]])
                res.four_hundred_and_four_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 409:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.IdempotencyConflict, shared.IdempotencyRequestMismatch, shared.IdempotencyKeyValidationError]])
                res.four_hundred_and_nine_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 413:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.RequestTooLargeError, shared.ResourceTooLargeError]])
                res.four_hundred_and_thirteen_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 429:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FourHundredAndTwentyNineError])
                res.four_hundred_and_twenty_nine_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 500:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FiveHundredError])
                res.five_hundred_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)

        return res

    
    def fetch_balance(self, customer_id: Optional[str], cursor: Optional[str] = None, limit: Optional[int] = None) -> operations.FetchCustomerCreditsResponse:
        r"""Fetch customer credit balance
        Returns a paginated list of unexpired, non-zero credit blocks for a customer.
        """
        request = operations.FetchCustomerCreditsRequest(
            customer_id=customer_id,
            cursor=cursor,
            limit=limit,
        )
        
        base_url = utils.template_url(*self.sdk_configuration.get_server_details())
        
        url = utils.generate_url(operations.FetchCustomerCreditsRequest, base_url, '/customers/{customer_id}/credits', request)
        headers = {}
        query_params = utils.get_query_params(operations.FetchCustomerCreditsRequest, request)
        headers['Accept'] = 'application/json'
        headers['user-agent'] = self.sdk_configuration.user_agent
        
        client = self.sdk_configuration.security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchCustomerCreditsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomerCreditBalances])
                res.customer_credit_balances = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.RequestValidationError, shared.DuplicateResourceCreationError, shared.DuplicateConstraintViolationError]])
                res.four_hundred_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FourHundredAndOneError])
                res.four_hundred_and_one_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.ResourceNotFoundError, shared.FeatureNotAvailableError, shared.URLNotFound]])
                res.four_hundred_and_four_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 409:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.IdempotencyConflict, shared.IdempotencyRequestMismatch, shared.IdempotencyKeyValidationError]])
                res.four_hundred_and_nine_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 413:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.RequestTooLargeError, shared.ResourceTooLargeError]])
                res.four_hundred_and_thirteen_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 429:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FourHundredAndTwentyNineError])
                res.four_hundred_and_twenty_nine_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 500:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FiveHundredError])
                res.five_hundred_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)

        return res

    
    def fetch_balance_by_external_id(self, external_customer_id: Optional[str], cursor: Optional[str] = None, limit: Optional[int] = None) -> operations.FetchCustomerCreditsExternalIDResponse:
        r"""Fetch customer credit balance by external customer id
        Returns a paginated list of unexpired, non-zero credit blocks for a customer.
        """
        request = operations.FetchCustomerCreditsExternalIDRequest(
            external_customer_id=external_customer_id,
            cursor=cursor,
            limit=limit,
        )
        
        base_url = utils.template_url(*self.sdk_configuration.get_server_details())
        
        url = utils.generate_url(operations.FetchCustomerCreditsExternalIDRequest, base_url, '/customers/external_customer_id/{external_customer_id}/credits', request)
        headers = {}
        query_params = utils.get_query_params(operations.FetchCustomerCreditsExternalIDRequest, request)
        headers['Accept'] = 'application/json'
        headers['user-agent'] = self.sdk_configuration.user_agent
        
        client = self.sdk_configuration.security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchCustomerCreditsExternalIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CustomerCreditBalances])
                res.customer_credit_balances = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.RequestValidationError, shared.DuplicateResourceCreationError, shared.DuplicateConstraintViolationError]])
                res.four_hundred_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FourHundredAndOneError])
                res.four_hundred_and_one_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.ResourceNotFoundError, shared.FeatureNotAvailableError, shared.URLNotFound]])
                res.four_hundred_and_four_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 409:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.IdempotencyConflict, shared.IdempotencyRequestMismatch, shared.IdempotencyKeyValidationError]])
                res.four_hundred_and_nine_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 413:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.RequestTooLargeError, shared.ResourceTooLargeError]])
                res.four_hundred_and_thirteen_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 429:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FourHundredAndTwentyNineError])
                res.four_hundred_and_twenty_nine_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 500:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FiveHundredError])
                res.five_hundred_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)

        return res

    
    def fetch_ledger(self, request: operations.FetchCustomerCreditsLedgerRequest) -> operations.FetchCustomerCreditsLedgerResponse:
        r"""Fetch customer credits ledger
        The credits ledger provides _auditing_ functionality over Orb's credits system with a list of actions that have
        taken place to modify a customer's credit balance. This [paginated endpoint](../reference/pagination) lists these
        entries, starting from the most recent ledger entry.

        More details on using Orb's real-time credit feature are [here](../guides/product-catalog/prepurchase.md).

        There are four major types of modifications to credit balance, detailed below.

        ## Increment
        Credits (which optionally expire on a future date) can be added via the API
        ([Add Ledger Entry](create-ledger-entry)). The ledger entry for such an action will always contain the total
        eligible starting and ending balance for the customer at the time the entry was added to the ledger.

        ## Decrement
        Deductions can occur as a result of an API call to create a ledger entry (see
        [Add Ledger Entry](create-ledger-entry)), or automatically as a result of incurring usage. Both ledger entries
        present the `decrement` entry type.

        As usage for a customer is reported into Orb, credits may be deducted according to the customer's plan
        configuration. An automated deduction of this type will result in a ledger entry, also with a starting and ending
        balance. In order to provide better tracing capabilities for automatic deductions, Orb always associates each
        automatic deduction with the `event_id` at the time of ingestion, used to pinpoint _why_ credit deduction took
        place and to ensure that credits are never deducted without an associated usage event.

        By default, Orb uses an algorithm that automatically deducts from the *soonest expiring credit block* first in
        order to ensure that all credits are utilized appropriately. As an example, if trial credits with an expiration date
        of 2 weeks from now are present for a customer, they will be used before any deductions take place from a
        non-expiring credit block.

        If there are multiple blocks with the same expiration date, Orb will deduct from the block with the
        *lower cost basis* first (ex. trial credits with a $0 cost basis before paid credits with a $5.00 cost basis).

        It's also possible for a single usage event's deduction to _span_ credit blocks. In this case, Orb will deduct from
        the next block, ending at the credit block which consists of unexpiring credits. Each of these deductions will lead
        to a _separate_ ledger entry, one per credit block that is deducted from. By default, the customer's total credit
        balance in Orb can be negative as a result of a decrement.

        ## Expiration change
        The expiry of credits can be changed as a result of the API (See [Add Ledger Entry](create-ledger-entry)). This will
        create a ledger entry that specifies the balance as well as the initial and target expiry dates.

        Note that for this entry type, `starting_balance` will equal `ending_balance`, and the `amount` represents the
        balance transferred. The credit block linked to the ledger entry is the source credit block from which there was an
        expiration change

        ## Credits expiry
        When a set of credits expire on pre-set expiration date, the customer's balance automatically reflects this change
        and adds an entry to the ledger indicating this event. Note that credit expiry should always happen close to a date
        boundary in the customer's timezone.

        ## Void initiated
        Credit blocks can be voided via the API. The `amount` on this entry corresponds to the number of credits that were
        remaining in the block at time of void. `void_reason` will be populated if the void is created with a reason.

        ## Void
        When a set of credits is voided, the customer's balance automatically reflects this change and adds an entry to the
        ledger indicating this event.

        ## Amendment
        When credits are added to a customer's balance as a result of a correction, this entry will be added to the ledger
        to indicate the adjustment of credits.
        """
        base_url = utils.template_url(*self.sdk_configuration.get_server_details())
        
        url = utils.generate_url(operations.FetchCustomerCreditsLedgerRequest, base_url, '/customers/{customer_id}/credits/ledger', request)
        headers = {}
        query_params = utils.get_query_params(operations.FetchCustomerCreditsLedgerRequest, request)
        headers['Accept'] = 'application/json'
        headers['user-agent'] = self.sdk_configuration.user_agent
        
        client = self.sdk_configuration.security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchCustomerCreditsLedgerResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreditLedgerEntries])
                res.credit_ledger_entries = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.RequestValidationError, shared.DuplicateResourceCreationError, shared.DuplicateConstraintViolationError]])
                res.four_hundred_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FourHundredAndOneError])
                res.four_hundred_and_one_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.ResourceNotFoundError, shared.FeatureNotAvailableError, shared.URLNotFound]])
                res.four_hundred_and_four_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 409:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.IdempotencyConflict, shared.IdempotencyRequestMismatch, shared.IdempotencyKeyValidationError]])
                res.four_hundred_and_nine_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 413:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.RequestTooLargeError, shared.ResourceTooLargeError]])
                res.four_hundred_and_thirteen_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 429:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FourHundredAndTwentyNineError])
                res.four_hundred_and_twenty_nine_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 500:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FiveHundredError])
                res.five_hundred_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)

        return res

    
    def fetch_ledger_by_external_id(self, request: operations.FetchCustomerCreditsLedgerExternalIDRequest) -> operations.FetchCustomerCreditsLedgerExternalIDResponse:
        r"""Fetch customer credits ledger by external ID
        The credits ledger provides _auditing_ functionality over Orb's credits system with a list of actions that have
        taken place to modify a customer's credit balance. This [paginated endpoint](../reference/pagination) lists these
        entries, starting from the most recent ledger entry.

        More details on using Orb's real-time credit feature are [here](../guides/product-catalog/prepurchase.md).

        There are four major types of modifications to credit balance, detailed below.

        ## Increment
        Credits (which optionally expire on a future date) can be added via the API
        ([Add Ledger Entry](create-ledger-entry)). The ledger entry for such an action will always contain the total
        eligible starting and ending balance for the customer at the time the entry was added to the ledger.

        ## Decrement
        Deductions can occur as a result of an API call to create a ledger entry (see
        [Add Ledger Entry](create-ledger-entry)), or automatically as a result of incurring usage. Both ledger entries
        present the `decrement` entry type.

        As usage for a customer is reported into Orb, credits may be deducted according to the customer's plan
        configuration. An automated deduction of this type will result in a ledger entry, also with a starting and ending
        balance. In order to provide better tracing capabilities for automatic deductions, Orb always associates each
        automatic deduction with the `event_id` at the time of ingestion, used to pinpoint _why_ credit deduction took
        place and to ensure that credits are never deducted without an associated usage event.

        By default, Orb uses an algorithm that automatically deducts from the *soonest expiring credit block* first in
        order to ensure that all credits are utilized appropriately. As an example, if trial credits with an expiration date
        of 2 weeks from now are present for a customer, they will be used before any deductions take place from a
        non-expiring credit block.

        If there are multiple blocks with the same expiration date, Orb will deduct from the block with the
        *lower cost basis* first (ex. trial credits with a $0 cost basis before paid credits with a $5.00 cost basis).

        It's also possible for a single usage event's deduction to _span_ credit blocks. In this case, Orb will deduct from
        the next block, ending at the credit block which consists of unexpiring credits. Each of these deductions will lead
        to a _separate_ ledger entry, one per credit block that is deducted from. By default, the customer's total credit
        balance in Orb can be negative as a result of a decrement.

        ## Expiration change
        The expiry of credits can be changed as a result of the API (See [Add Ledger Entry](create-ledger-entry)). This will
        create a ledger entry that specifies the balance as well as the initial and target expiry dates.

        Note that for this entry type, `starting_balance` will equal `ending_balance`, and the `amount` represents the
        balance transferred. The credit block linked to the ledger entry is the source credit block from which there was an
        expiration change

        ## Credits expiry
        When a set of credits expire on pre-set expiration date, the customer's balance automatically reflects this change
        and adds an entry to the ledger indicating this event. Note that credit expiry should always happen close to a date
        boundary in the customer's timezone.

        ## Void initiated
        Credit blocks can be voided via the API. The `amount` on this entry corresponds to the number of credits that were
        remaining in the block at time of void. `void_reason` will be populated if the void is created with a reason.

        ## Void
        When a set of credits is voided, the customer's balance automatically reflects this change and adds an entry to the
        ledger indicating this event.

        ## Amendment
        When credits are added to a customer's balance as a result of a correction, this entry will be added to the ledger
        to indicate the adjustment of credits.
        """
        base_url = utils.template_url(*self.sdk_configuration.get_server_details())
        
        url = utils.generate_url(operations.FetchCustomerCreditsLedgerExternalIDRequest, base_url, '/customers/external_customer_id/{external_customer_id}/credits/ledger', request)
        headers = {}
        query_params = utils.get_query_params(operations.FetchCustomerCreditsLedgerExternalIDRequest, request)
        headers['Accept'] = 'application/json'
        headers['user-agent'] = self.sdk_configuration.user_agent
        
        client = self.sdk_configuration.security_client
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.FetchCustomerCreditsLedgerExternalIDResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.CreditLedgerEntries])
                res.credit_ledger_entries = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 400:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.RequestValidationError, shared.DuplicateResourceCreationError, shared.DuplicateConstraintViolationError]])
                res.four_hundred_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 401:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FourHundredAndOneError])
                res.four_hundred_and_one_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.ResourceNotFoundError, shared.FeatureNotAvailableError, shared.URLNotFound]])
                res.four_hundred_and_four_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 409:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.IdempotencyConflict, shared.IdempotencyRequestMismatch, shared.IdempotencyKeyValidationError]])
                res.four_hundred_and_nine_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 413:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[Union[shared.RequestTooLargeError, shared.ResourceTooLargeError]])
                res.four_hundred_and_thirteen_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 429:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FourHundredAndTwentyNineError])
                res.four_hundred_and_twenty_nine_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code == 500:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.FiveHundredError])
                res.five_hundred_error = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)

        return res

    