# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/30_item.ipynb.

# %% auto 0
__all__ = ['Item']

# %% ../nbs/30_item.ipynb 3
from tqdm import tqdm
import requests
import urllib.parse
from typing import Dict, List, Union, Any
import datetime
import hashlib
from io import BytesIO
from PIL import Image

# %% ../nbs/30_item.ipynb 4
class Item:

    endpoint: str
    uri: str

    prefixes = {
        "schema": "http://schema.org/",
        "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
        "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
    }

    def __init__(self, endpoint, uri):
        self.endpoint = endpoint
        self.uri = uri

    @staticmethod
    def get_uris(endpoint, query, is_debug=False):

        limit = 10000
        page = 0

        uris = []  

        while 1:

            if is_debug:
                print(f"page: {page}")

            sparql_page = query + f""" limit {limit} offset {limit * page}"""

            url = f"{endpoint}?query={urllib.parse.quote(sparql_page)}&format=json"
            df = requests.get(url).json()

            bindings = df["results"]["bindings"]
        
            if len(bindings) == 0:
                break
            
            for b in bindings:
                uris.append(b["cho"]["value"])

            page += 1

        return uris
    
    @staticmethod
    def main(endpoint, uri_list, debug=False):
        for uri in tqdm(uri_list):
            item = Item(endpoint, uri)
            # item.endpoint = endpoint
            # item.uri_list = uri_list
            item.debug = debug

            if item.debug:
                print("### ### ###", "JSONのダウンロード", "### ### ###")

            item.download_json()

            # uri

    def download_json(self): # , endpoint, uri, opath
        # , uri

        uri = self.uri

        '''
        sparql = f"""DESCRIBE <{uri}>
    <{uri}#accessinfo>
    <{uri}#sourceinfo>
    """
        '''

        data = {}

        sparql = f"""select * where {{
    ?s ?p ?o .
    filter(?s = <{uri}> || ?s = <{uri}#accessinfo> || ?s = <{uri}#sourceinfo>)
    # optional {{ ?o ?p2 ?o2 . }}
        }}"""

        url = f"{self.endpoint}?query={urllib.parse.quote(sparql)}&format=json"
        df = requests.get(url).json()

        bindings = df["results"]["bindings"]

        for b in bindings:
            s = b["s"]["value"]
            p = b["p"]["value"]
            o = b["o"]

            if s not in data:
                data[s] = {}

            if p not in data[s]:
                data[s][p] = []

            data[s][p].append(o)

        '''
        os.makedirs(os.path.dirname(opath), exist_ok=True)
        with open(opath, "w") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        '''

        self.json = data

    def _get_today(self):
        today = datetime.date.today()

        # xxxx-xx-xxの形式で出力
        formatted_date = today.strftime('%Y-%m-%d')
        return formatted_date
    
    def _create_hash(self, item):
        item_id = item["id"]

        if "dignl" in item_id or item["attributes"]["o:thumbnail"][0] == 0:
            return "Z"
        else:
            return hashlib.md5(item_id.encode()).hexdigest()
        
    def _get_media(self, attributes):
        if "o:manifest" in attributes:
            return [
                {
                    "ja": "IIIF",
                    "en": "IIIF",
                    # "uri": "IIIF"
                }
            ]
        elif "schema:associatedMedia" in attributes:
            return [
                {
                    "ja": "IIIF（動的生成）",
                    "en": "IIIF (Dynamic)",
                    # "uri": "IIIF"
                }
            ]

        elif "schema:image" in attributes:
            return [
                {
                    "ja": "画像あり",
                    "en": "Image"
                }
            ]
        
        return [
            {
                "ja": "画像なし",
                "en": "None"
            }
        ]


        # metadata["o:media"] = 

    def convert(self):

        data = self.json

        uris = list(data.keys())

        main_uri = ""
        for uri in uris:
            if "#" not in uri:
                main_uri = uri
                break

        item_id = main_uri.split("/")[-1]

        attributes = {
            "o:updated": [self._get_today()],
            "o:identifier" : [main_uri],
            "o:db": [item_id.split("-")[0]]
        }

        item = {
            # "o:identifier" : main_uri,
            # "o:id" : item_id,
            "id": item_id,
            "type": "Item",
            "attributes": attributes
        }

        # メインの情報を取得
        metadata = self.handle_main(data[main_uri])
        for k, v in metadata.items():
            # item[k] = v
            attributes[k] = v
        
        # ソース情報を取得
        metadata = self.handle_source(data[main_uri+"#sourceinfo"])
        for k, v in metadata.items():
            # item[k] = v
            attributes[k] = v

        # アクセス情報を取得
        access_uri = main_uri+"#accessinfo"
        metadata = self.handle_access(access_uri, data[access_uri])
        for k, v in metadata.items():
            # item[k] = v
            attributes[k] = v

        hash_id = self._create_hash(item)
        item["attributes"]["o:hash"] = [hash_id]

        # media
        media = self._get_media(item["attributes"])
        item["attributes"]["o:media"] = media

        url = self._get_url_from_main(main_uri)
        if url is not None:
            item["attributes"]["schema:url"] = [url]

        self.metadata = item

    def _get_url_from_main(self, main_uri):
        url = self._get_url_from_source(f"{main_uri}#sourceinfo")
        if url is not None:
            return url
        else:
            access_uri = f"{main_uri}#accessinfo"
            url = self.get_url(access_uri)
            if url is not None:
                return url

        return None

    def _get_url_from_source(self, uri):
        query = f"""prefix schema: <http://schema.org/>
select distinct ?url where {{
  <{uri}> schema:url ?url . 
}}"""

        url = f"{self.endpoint}?query={urllib.parse.quote(query)}&format=json"

        df = requests.get(url).json()

        bindings = df["results"]["bindings"]

        if len(bindings) == 0:
            return None
        
        r = bindings[0]

        return r["url"]["value"]

    def handle_main_entities(self, data):

        prefixes = self.prefixes

        keys = [
            {
                "uri": prefixes["rdf"] + "type",
                "term": "rdf:type"
            },
            {
                "uri": prefixes["schema"] + "creator",
                "term": "o:agential"
            },
            {
                "uri": prefixes["schema"] + "contributor",
                "term": "o:agential"
            },
            {
                "uri": prefixes["schema"] + "about",
                "term": "schema:about"
            },
            {
                "uri": prefixes["schema"] + "spatial",
                "term": "schema:spatial"
            },
            {
                "uri": prefixes["schema"] + "temporal",
                "term": "schema:temporal"
            },
            {
                "uri": prefixes["schema"] + "category",
                "term": "schema:category"
            },
            {
                "uri": prefixes["schema"] + "isPartOf",
                "term": "schema:isPartOf"
            }
        ]

        metadata = self.handle_entities(data, keys)

        return metadata
    
    def handle_main_literals(self, data):
        prefixes = self.prefixes

        keys = [
            {
                "uri": prefixes["schema"] + "description",
                "term": "schema:" + "description",
            },
            {
                "uri": prefixes["schema"] + "abstract",
                "term": "schema:" + "abstract",
            }
        ]

        metadata = self.handle_literals(data, keys)
        return metadata

    def _get_thumbnail(self, image):
        if image is None:
            return 0
        else:
            return 1

    def handle_main(self, data):
        """
        Extract main metadata information from the given data.

        :param data: Dictionary containing the data to be processed.
        :return: Dictionary containing the extracted metadata.
        """

        prefixes = self.prefixes

        metadata = {}

        # Extract schema:image value if it exists
        schema_image_key = prefixes["schema"] + "image"
        if schema_image_key in data:
            metadata["schema:image"] = [data[schema_image_key][0]["value"]]

        metadata["o:thumbnail"] = [self._get_thumbnail(metadata["schema:image"])]

        # Handle main label extraction
        label, names = self.handle_main_label(data)
        metadata["rdfs:label"] = [label]
        metadata["schema:name"] = names

        entities = self.handle_main_entities(data)
        for k, v in entities.items():
            metadata[k] = v

        literals = self.handle_main_literals(data)
        for k, v in literals.items():
            metadata[k] = v

        if "schema:temporal" in metadata:
            era_list = self._get_era(metadata["schema:temporal"])
            if era_list is not None:
                metadata["o:era"] = era_list


        return metadata

    def _get_era(self, items):
        uris = []
        for item in items:
            uri = item["uri"]

            sparql = f"""
            PREFIX schema: <http://schema.org/>
            PREFIX type: <https://jpsearch.go.jp/term/type/>
            select distinct ?parent where {{
            <{uri}> schema:isPartOf ?parent . 
            ?parent a type:HistoricalEra
            }}"""

            url = f"{self.endpoint}?query={urllib.parse.quote(sparql)}&format=json"
            df = requests.get(url).json()

            bindings = df["results"]["bindings"]

            if len(bindings) == 0:
                continue

            for r in bindings:
                parent = r["parent"]["value"]

                if parent not in uris:
                    uris.append(parent)

        values = []

        for uri in uris:
            value = self.get_lang_label(uri)
            del value["status"]
            values.append(value)

        return values

    
    def handle_main_label(self, data):
        prefixes = self.prefixes
        """
        Extract main label information (in Japanese and English) from the given data.

        :param data: Dictionary containing the data to be processed.
        :return: Tuple containing the label dictionary and a list of names.
        """
        # Extract Japanese label
        label_ja = data[prefixes["rdfs"] + "label"][0]["value"]
        label_en = label_ja  # Set English label to Japanese label by default
        label_ja_x_mt = None

        names = []

        # Process schema:name values
        schema_name_key = prefixes["schema"] + "name"
        if schema_name_key in data:
            values = data[schema_name_key]

            # Iterate through values and update labels and names list accordingly
            for v in values:
                if "xml:lang" in v:
                    lang = v["xml:lang"]
                    if lang == "en":
                        label_en = v["value"]
                    elif lang == "ja-x-mt":
                        label_ja_x_mt = v["value"]
                names.append(v["value"])

        # Create label dictionary
        label = {
            "ja": label_ja,
            "en": label_en
        }

        # Add ja-x-mt label if it exists
        if label_ja_x_mt is not None:
            label["ja-x-mt"] = label_ja_x_mt

        return label, names
    
    def get_ln(self, uri):
        kigos = ["#", "/"]
        for kigo in kigos:
            if kigo in uri:
                # return uri.split(kigo)[-1]
                uri = uri.split(kigo)[-1]

        return uri

    def get_lang_label(self, uri: str) -> Dict[str, str]:

        """
        Fetches Japanese and English labels for a given URI.

        Parameters:
        - uri (str): The URI for which to fetch the labels.

        Returns:
        - Dict[str, str]: A dictionary containing the Japanese ('ja') and English ('en') labels, the URI, and the status.
        """
        # Retrieve labels using SPARQL
        sparql = f"""
        PREFIX schema: <http://schema.org/>
        PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
        select distinct ?ja ?en where {{
        bind(<{uri}> as ?s)
        ?s rdfs:label ?ja . 
        optional {{?s schema:name ?en . filter (lang(?en) = "en")}}
        }}"""

        url = f"{self.endpoint}?query={urllib.parse.quote(sparql)}&format=json"
        df = requests.get(url).json()

        bindings = df["results"]["bindings"]

        # Extract labels from the results
        ja, en = self._extract_labels(bindings, uri)

        return {
            "ja": ja,
            "en": en,
            "uri": uri,
            "status": "new"
        }

    def _extract_labels(self, bindings: Dict[str, Dict[str, str]], uri: str) -> (str, str):
        """
        Helper function to extract Japanese and English labels from the bindings.

        Parameters:
        - bindings (Dict[str, Dict[str, str]]): The results from the SPARQL query.
        - uri (str): The URI for which to fetch the labels.

        Returns:
        - (str, str): Tuple containing Japanese and English labels.
        """
        if len(bindings) == 0:
            ja = self.get_ln(uri)  # Assuming `get_ln` is another method in your class
            en = ja
        else:
            r = bindings[0]
            ja = r["ja"]["value"]
            en = r["en"]["value"] if "en" in r else ja
        
        return ja, en

    def handle_entities(self, data, keys):
        metadata = {}

        for c in keys:
            k = c["uri"]
            if k in data:
                values = data[k]
                for v in values:
                    if "value" in v:
                        value = self.get_lang_label(v["value"])

                        del value["status"]
                        
                        term = c["term"]
                        if term not in metadata:
                            metadata[term] = []

                        metadata[term].append(value)

        return metadata
    
    def handle_literals(self, data, keys):
        metadata = {}

        for c in keys:
            k = c["uri"]
            if k in data:
                values = data[k]
                for v in values:
                    if "value" in v:

                        term = c["term"]
                        if term not in metadata:
                            metadata[term] = []

                        metadata[term].append(v["value"])

        return metadata

    def handle_source_entities(self, data):
        keys = [
            {
                "uri": "http://schema.org/provider",
                "term": "o:source"
            }
        ]

        metadata = self.handle_entities(data, keys)

        return metadata

    def handle_source(self, data):
        metadata = {}

        entities = self.handle_source_entities(data)
        for k, v in entities.items():
            metadata[k] = v

        prefixes = self.prefixes

        keys = [
            {
                "uri": f"{prefixes['schema']}dateModified",
                "term": "schema:dateModified"
            }
        ]
        literals = self.handle_literals(data, keys)
        for k, v in literals.items():
            metadata[k] = v

        return metadata

    def handle_access_entities(self, data):
        keys = [
            {
                "uri": "http://schema.org/provider",
                "term": "o:access"
            }
        ]

        metadata = self.handle_entities(data, keys)

        return metadata
    
    def get_country(self, uri):
        query = f"""prefix schema: <http://schema.org/>
prefix jps: <http://jpsearch.go.jp/term/property#>
select distinct ?country ?parent where {{
  <{uri}> schema:provider/schema:location/schema:containedInPlace ?country . 
  optional {{ ?country schema:isPartOf ?parent }}
}}"""

        url = f"{self.endpoint}?query={urllib.parse.quote(query)}&format=json"

        df = requests.get(url).json()

        bindings = df["results"]["bindings"]

        if len(bindings) == 0:
            return None
        
        r = bindings[0]        

        if "parent" in r:
            country = r["parent"]["value"]
        else:
            country = r["country"]["value"]

        value = self.get_lang_label(country)

        del value["status"]

        return value
    
    def get_manifest(self, uri):
        query = f"""prefix schema: <http://schema.org/>
prefix jps: <http://jpsearch.go.jp/term/property#>
select ?manifest where {{
  <{uri}> schema:url ?manifest . 
  ?manifest a <http://iiif.io/api/presentation/2#Manifest>
}}"""

        url = f"{self.endpoint}?query={urllib.parse.quote(query)}&format=json"

        df = requests.get(url).json()

        bindings = df["results"]["bindings"]

        if len(bindings) == 0:
            return None
        
        r = bindings[0]
        manifest = r["manifest"]["value"]

        return manifest

    def get_url(self, uri):
        query = f"""prefix schema: <http://schema.org/>
        select ?url where {{
  <{uri}> schema:url ?url . 
  minus {{ ?url a <http://iiif.io/api/presentation/2#Manifest> }}
}}"""

        url = f"{self.endpoint}?query={urllib.parse.quote(query)}&format=json"

        df = requests.get(url).json()

        bindings = df["results"]["bindings"]

        if len(bindings) == 0:
            return None
        
        r = bindings[0]
        url = r["url"]["value"]

        return url
    
    def _get_parent_version(self, uri):
        query = f"""prefix dct: <http://purl.org/dc/terms/>
        select ?parent where {{
        BIND (<{uri}> AS ?s) 
        ?s dct:isVersionOf ?parent . 
        }}"""

        url = f"{self.endpoint}?query={urllib.parse.quote(query)}&format=json"

        df = requests.get(url).json()

        bindings = df["results"]["bindings"]

        if len(bindings) == 0:
            return None
        
        r = bindings[0]
        url = r["parent"]["value"]

        return url

    def handle_access_licenses(self,data):
        prefixes = self.prefixes
        metadata = {}

        licenses_key = prefixes["schema"] + "license"
        if licenses_key in data:
            licenses = data[licenses_key]
            for license in licenses:
                if "value" in license:
                    license_uri = license["value"]
                    metadata["schema:license"] = [license_uri]

                    # license_uri
                    # http://creativecommons.org/publicdomain/mark/1.0/

                    parent = self._get_parent_version(license_uri)

                    if parent is not None:
                        v = self.get_lang_label(parent)
                        del v["status"]
                        metadata["o:license"] = [v]
                    

                    # license_label = get_lang_label(license_uri)
                    # del license_label["status"]
                    # metadata["schema:license"] = license_label

                    '''
                    db_name = "/Users/nakamura/git/cj/cj_utils/demo/item/db/license.db"
                    conn = sqlite3.connect(db_name)
                    cur = conn.cursor()

                    table_name = "license"

                    cur.execute(f'SELECT * FROM {table_name} WHERE uri = ?', (license_uri,))

                    row = cur.fetchone()

                    '''

                    '''
                    if row is not None:

                        category = row[1]

                        # conn.close()

                    else:
                    '''

                    categories = []

                    if True:

                        sparql = f"""PREFIX schema: <http://schema.org/>
    PREFIX dct: <http://purl.org/dc/terms/>
    SELECT ?license ?lcategory WHERE {{
        bind(<{license_uri}> as ?license)
        ?license dct:isVersionOf?/schema:category ?lcategory .
    }}"""

                        url = f"{self.endpoint}?query={urllib.parse.quote(sparql)}&format=json"

                        df = requests.get(url).json()

                        bindings = df["results"]["bindings"]

                        if len(bindings) == 0:
                            category = ""
                        else:
                            for r in bindings:
                                # r = bindings[0]
                                category = r["lcategory"]["value"]
                                categories.append(category)

                        '''

                        
                        insert = f'INSERT OR IGNORE INTO {table_name} values("{license_uri}", "{category}")'
                        update = f'UPDATE {table_name} SET category = "{category}" WHERE uri = "{license_uri}"'

                        
                        cur.execute(insert)
                        cur.execute(update)

                        '''

                    '''
                    conn.commit()
                    conn.close()
                    '''

                    # カテゴリの取得
                    # if category != "":
                    if len(categories) > 0:

                        for category in categories:

                            value = self.get_lang_label(category)

                            value["ja"] = self._fix_license_category_ja(value["ja"])

                            del value["status"]

                            term = "schema:licenseCategory"

                            if term not in metadata:
                                metadata[term] = []

                            metadata[term].append(value)

        return metadata

    def _fix_license_category_ja(self, value):
        dicts = {
            "Allow commercial": "商用利用可",
            "No restriction": "制約なし",
            "Educational only": "教育利用のみ",
            "Non-commercial only": "非商用利用のみ"
        }
        if value in dicts:
            return dicts[value]
        else:
            return value


    def handle_access(self, access_uri, data):
        prefixes = self.prefixes

        metadata = {}

        entities = self.handle_access_entities(data)
        for k, v in entities.items():
            metadata[k] = v

        keys = [
            {
                "uri": f"{prefixes['schema']}associatedMedia",
                "term": "schema:associatedMedia"
            }
        ]

        urls = self.handle_literals(data, keys)
        for k, v in urls.items():
            metadata[k] = v

        licenses = self.handle_access_licenses(data)
        for k, v in licenses.items():
            metadata[k] = v

        location = self.get_country(access_uri)

        if location is not None:
            metadata["schema:location"] = [location]

        manifest = self.get_manifest(access_uri)

        if manifest is not None:
            metadata["o:manifest"] = [manifest]

        return metadata
    
    def _get_media_info(self, url):
        try:
            req  = requests.get(url)
            im = Image.open(BytesIO(req.content))
            w, h = im.size
            return {
                "width": w,
                "height": h,
                "url": url
            }
        except Exception as e:
            print(url, e)
            return None

    
    def convert_to_es(self, index, op_type):
        doc = {}

        metadata = self.metadata
        attributes = metadata["attributes"]

        _fulltext = []

        if "schema:description" in attributes:
            doc["description"] = attributes["schema:description"]

            for d in doc["description"]:
                _fulltext.append(d)

        if "schema:abstract" in attributes:
            doc["abstract"] = attributes["schema:abstract"]

            for d in doc["abstract"]:
                _fulltext.append(d)

        if "rdfs:label" in attributes:
            value = attributes["rdfs:label"][0]

            doc["_title_en"] = [value["en"]]
            doc["_title_ja"] = [value["ja"]]

            for d in doc["_title_en"]:
                if d not in _fulltext:
                    _fulltext.append(d)

            for d in doc["_title_ja"]:
                if d not in _fulltext:
                    _fulltext.append(d)

        if "schema:name" in attributes:
            doc["name"] = attributes["schema:name"]

        doc["dateUpdated"] = attributes["o:updated"]
        doc["dateModified"] = attributes["schema:dateModified"]

        if "schema:associatedMedia" in attributes:
            urls = attributes["schema:associatedMedia"]
            doc["associatedMedia"] = urls

            info_list = []

            for url in urls:
                info = self._get_media_info(url)

                if info is not None:
                    info_list.append(info)
                    info["label"] = f"[{len(info_list)}]"

            if len(info_list) > 0:
                doc["_media_list"] = info_list

        doc["_uri"] = attributes["o:identifier"]
        doc["_url"] = attributes["schema:url"]

        doc["_thumbnail"] = attributes["o:thumbnail"]

        if "o:manifest" in attributes:
            doc["_manifest"] = attributes["o:manifest"]
        elif "schema:associatedMedia" in attributes:
            doc["_manifest"] = [f'https://api.cultural.jp/iiif/{metadata["id"]}/manifest']

        doc["_image"] = attributes["schema:image"]

        doc["_hash"] = attributes["o:hash"]

        doc["type"] = self._convert_value(attributes["rdf:type"])

        # フルテキスト
        if doc["type"] is not None:
            keys = ["ja", "en"]
            for k in keys:
                values = doc["type"][k]
                for v in values:
                    if v not in _fulltext:
                        _fulltext.append(v)

        entities = [
            ["schema:temporal", "temporal"],
            ["o:agential", "agential"],
            ["o:source", "source"],
            ["o:access", "access"],
            ["o:media", "_media"],
            ["schema:location", "country"],
            ["o:license", "license"],
            ["schema:licenseCategory", "licenseCategory"],
            ["o:era", "era"],
            ["schema:category", "category"],
            ["schema:isPartOf", "isPartOf"],
        ]

        for entity in entities:
            doc[entity[1]] = self._set_value(attributes, entity[0])

        # jaやenを持たない場合
        if "schema:license" in attributes:
            doc["_rights"] = attributes["schema:license"]

        # フルテキスト
        doc["_fulltext"] = _fulltext

        # 値が空のキーを削除
        filtered_doc = {k: v for k, v in doc.items() if v is not None}

        return {
            "_index": index,
            "_id": metadata["id"],
            "_op_type": op_type,
            "doc": filtered_doc
        }
    def _set_value (self, attributes, term):
        if term not in attributes:
            return None
        
        return self._convert_value(attributes[term])

    def _convert_value(self, value: Union[List[Dict[str, Any]], None]) -> Union[Dict[str, List[Any]], None]:
        """
        Converts the values associated with the keys "ja", "en", and "uri" in the first element of 'value' into lists.
        例：valueが[{"ja": "日本語", "en": "English", "uri": "example.com"}]の場合、この関数は{"ja": ["日本語"], "en": ["English"], "uri": ["example.com"]}を返します。

        Parameters:
        - value (Union[List[Dict[str, Any]], None]): A list containing a dictionary or None.

        Returns:
        - Union[Dict[str, List[Any]], None]: A dictionary with values converted to lists or None.
        """
        if value is None:
            return None

        keys = ["ja", "en"]

        results = {}

        for key in keys:
            results[key] = []

            for obj in value:
                v = obj[key]

                results[key].append(v)
                    

        return results
