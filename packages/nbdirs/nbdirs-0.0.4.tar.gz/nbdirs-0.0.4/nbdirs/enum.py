# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_enum.ipynb.

# %% auto 0
__all__ = ['RelDirsType', 'RelDirsEnumMeta', 'RelDirsEnum']

# %% ../nbs/05_enum.ipynb 4
import copy
from typing import Any, Dict, List
from enum import Enum, EnumMeta, _EnumDict, member

# %% ../nbs/05_enum.ipynb 6
from nbdirs.cons import (
    __RESTORE__, __MEMBERS__, __INHERITABLE_MEMBERS__, 
    ROOT, RDIR, DROOT,
    MIXINS, ASMEMBER, __METACLASS__
)
from .atyp import (DirLike, DirLikeQ, Mixin)

# %% ../nbs/05_enum.ipynb 8
from nbdirs.utils import (
    isdunder, vvalue, newedict, getmeminfo
)

# %% ../nbs/05_enum.ipynb 10
from nbdirs.dirs import (
    RelDir, ROOT_DIR, NBKS_DIR, EXPL_DIR, 
    DATA_DIR, RSLT_DIR, FIGS_DIR
)

# %% ../nbs/05_enum.ipynb 12
from .mixs import (ROOT_MIXIN)

# %% ../nbs/05_enum.ipynb 14
class RelDirsType(type):
    root: DirLikeQ = None
    mixins: List[Mixin] = [ROOT_MIXIN]

    @classmethod
    def __delval__(metacls, clsdict, key):
        if key in clsdict:
            clsdict.__delitem__(key)
            clsdict._member_names.pop(key)

    @classmethod
    def __copyval__(metacls, val, mixins = None, *args, **kwargs) -> Any:
        mixins = mixins or getattr(metacls, MIXINS, [])
        newval = copy.deepcopy(vvalue(val))
        for (mix, hook) in mixins:
            if isinstance(newval, mix):
                newval = hook(newval, *args, **kwargs)

        return newval
    
    @classmethod
    def __updateval__(metacls, clsdict, val, mixins = None, *args, **kwargs) -> member:
        asmemb= kwargs.get(ASMEMBER, False)
        newval = metacls.__copyval__(val, mixins, *args, **kwargs)        
        return member(newval) if asmemb else newval

    @classmethod
    def __getroot__(metacls, clsdict, **kwargs) -> DirLike: 
        rkws = kwargs.get(ROOT, None)
        edir = clsdict.get(ROOT, None) # getattr(clsdict, ROOT, None)
        rdir = clsdict.get(RDIR, None) # getattr(clsdict, RDIR, None)
        mdir = getattr(metacls, ROOT, None)
        root = rkws or edir or rdir or mdir or DROOT
        return root 
        
    @classmethod
    def __rootdir__(metacls, clsdict, **kwargs):
        root = metacls.__getroot__(clsdict, **kwargs)
        if isinstance(root, str):
            root = RelDir(root=root, abrv=ROOT, desc='The root directory')
        return root

    @staticmethod
    def __updateroot__(val, root):
        val = copy.deepcopy(vvalue(val))
        if isinstance(val, RelDir): 
            val.update(root=root, inplace=True)
        return member(val)
    
    @classmethod
    def __setdict__(metacls, clsdict, key, val = None, *args, **kwargs):
        if key in clsdict or key in clsdict._member_names:
            if val is None: 
                val = clsdict.__getitem__(key)
            
            try: metacls.__delval__(clsdict, key)
            except AttributeError: pass

        val = metacls.__updateval__(clsdict, val, asmember=True, *args, **kwargs)
        clsdict.__setitem__(key, val)
        clsdict._member_names[key] = clsdict[key]
        return clsdict
    
    @classmethod
    def __setroot__(metacls, clsdict, root):
        for k in (ROOT, RDIR): metacls.__delval__(clsdict, k)
        setattr(clsdict, ROOT, root)
        clsdict = metacls.__setdict__(clsdict, RDIR, root, root=root)
        return clsdict
    
    @classmethod
    def __copydict__(metacls, clsdict, *args, **kwargs):
        newdict = newedict(clsdict._cls_name)
        mixins = kwargs.get(MIXINS, []) or getattr(metacls, MIXINS, [])

        for k, v in clsdict.items():
            newdict[k] = metacls.__copyval__(v, mixins,  *args, **kwargs)            
        
        return newdict

# %% ../nbs/05_enum.ipynb 16
class RelDirsEnumMeta(RelDirsType, EnumMeta):
    root: DirLikeQ = ROOT_DIR.deepcopy()
    mixins: List[Mixin] = [ROOT_MIXIN]
    
    def _check_for_existing_members_(class_name, bases): 
        pass
    
    @classmethod
    def __prepare__(metacls, name, bases, **kwargs) -> dict:
        clsdict = newedict(name)
        root = metacls.__rootdir__(clsdict, **kwargs)
        clsdict = metacls.__setroot__(clsdict, root)

        # NOTE: this does inheritance
        members, _ = getmeminfo(bases)
        if RDIR in clsdict:
            metacls.__delval__(clsdict, RDIR)
        for mem, val in members.items():
            if isdunder(mem): continue
            if mem == RDIR: continue
            clsdict = metacls.__setdict__(clsdict, mem, val, root=root)
        return clsdict
    
    def __new__(metacls, name, bases, clsdict, *, root: DirLikeQ = None, **kwargs): 
        root = metacls.__rootdir__(clsdict, root=root, **kwargs)
        clsdict = metacls.__setroot__(clsdict, root)
        newdict = metacls.__copydict__(clsdict, root=root, **kwargs)
        if RDIR not in newdict:
            newdict = metacls.__setdict__(newdict, RDIR, root, root=root)
        newcls = super().__new__(metacls, name, bases, newdict)
        return newcls
    
    @classmethod
    def _missing_(cls, value):
        return None
    
    @property
    def dirnames(cls) -> list: 
        return sorted([attr for attr in cls._member_names_])

    @property
    def dirs(cls) -> dict: 
        return {d: getattr(cls, d).value for d in sorted(cls._member_names_)}
    
    @property
    def todict(cls) -> Dict[str, RelDir]: 
        return {k: v.value for k, v in cls.__members__.items()}

    @property
    def clsname(cls) -> str:  
        return cls.__name__
    
    def __contains__(cls, key):
        return key in cls._member_map_ or key in cls._member_names_ or key in cls.dirs.values()
    
    def makedirs(self, verbose: bool = False):
        dirs = self.dirs
        for name, path in dirs.items():
            path.make(verbose=verbose)
        return dirs
        
    def update_root(cls, root: str, inplace: bool = False):
        if inplace:
            nenum = cls
        else:
            clsdict = _EnumDict()
            clsdict._cls_name = cls.__name__
            edict = {mem.name: member(copy.deepcopy(mem.value)) for mem in cls}
            for n, v in edict.items(): 
                clsdict[n] = v
            clsdict[__METACLASS__] = type(cls)
            nenum = type(cls.__name__, (cls, ), clsdict)

        kls = copy.deepcopy(nenum)
        kls.__members__.get(RDIR).value.update(root=root, inplace=True)
        for name, path in kls.__members__.items():
            if name == RDIR: continue
            path.value.update(root=root, inplace=True)
        return kls

# %% ../nbs/05_enum.ipynb 18
class RelDirsEnum(Enum, metaclass=RelDirsEnumMeta):
    ...
