import os
import time
from subprocess import DEVNULL, STDOUT, CalledProcessError, check_call

import numpy as np
from networkx import cycle_basis

from tscode.algebra import dihedral, norm, norm_of
from tscode.calculators._xtb import read_xtb_energy
from tscode.graph_manipulations import neighbors
from tscode.optimization_methods import optimize
from tscode.utils import (clean_directory, graphize, read_xyz, scramble_check,
                          write_xyz)


def automep(embedder, n_images=7):

    assert embedder.options.calculator == "XTB"

    mol = embedder.objects[0]
    coords = mol.atomcoords[0]

    # Get cycle indices bigger than 6
    graph = graphize(coords, mol.atomnos)
    cycles = [l for l in cycle_basis(graph) if len(l) == 7]
    assert len(cycles) == 1, "Automep only works for 7-membered ring flips at the moment"

    embedder.log('--> AutoMEP - Building MEP for 7-membered ring inversion')
    embedder.log(f'    Preoptimizing starting point at {embedder.options.calculator}/{embedder.options.theory_level}({embedder.options.solvent}) level')

    coords, _, _ = optimize(
                            coords,
                            mol.atomnos,
                            embedder.options.calculator,
                            method=embedder.options.theory_level,
                            procs=embedder.options.procs,
                            solvent=embedder.options.solvent,
                            title=f'temp',
                            logfunction=embedder.log,
                            )

    dihedrals = cycle_to_dihedrals(cycles[0])
    exocyclic = get_exocyclic_dihedrals(graph, cycles[0])

    start_angles = np.array([dihedral(coords[d]) for d in dihedrals+exocyclic])
    target_angles = np.array([0 for _ in dihedrals] + [180 for _ in exocyclic])
    multipliers = np.linspace(1, -1, n_images)

    mep_angles = [(start_angles * m + target_angles * (1-m)) % 360 for m in multipliers]

    mep = []
    for i, m_a in enumerate(mep_angles):
        t_start = time.perf_counter()
        coords, _, _ = xtb_popt(coords,
                                mol.atomnos,
                                constrained_dihedrals=dihedrals+exocyclic,
                                angles=m_a,
                                method=embedder.options.theory_level,
                                solvent=embedder.options.solvent,
                                procs=embedder.options.procs)
        embedder.log(f'    - optimized image {i+1}/{len(mep_angles)} ({round(time.perf_counter()-t_start, 3)} s)')
        mep.append(coords)

    with open(f"{mol.rootname}_automep.xyz", "w") as f:
        for c in mep:
            write_xyz(c, mol.atomnos, f)

    embedder.log(f"\n--> Saved autogenerated MEP as {mol.rootname}_automep.xyz\n")

    return f"{mol.rootname}_automep.xyz"

def get_exocyclic_dihedrals(graph, cycle):
    '''
    '''
    exo_dihs = []
    for index in cycle:
        for exo_id in neighbors(graph, index):
            if exo_id not in cycle:
                dummy1 = next(i for i in cycle if i not in (exo_id, index) and i in neighbors(graph, index))
                dummy2 = next(i for i in cycle if i not in (exo_id, index, dummy1) and i in neighbors(graph, dummy1))
                exo_dihs.append([exo_id, index, dummy1, dummy2])

    return exo_dihs    

def cycle_to_dihedrals(cycle):
    '''
    '''
    dihedrals = []
    for i in range(len(cycle)):

        a = cycle[i % len(cycle)]
        b = cycle[(i+1) % len(cycle)]
        c = cycle[(i+2) % len(cycle)]
        d = cycle[(i+3) % len(cycle)]
        dihedrals.append([a, b, c, d])
    return dihedrals

def xtb_popt(coords, atomnos, constrained_indices=None,
            constrained_distances=None, constrained_dihedrals=None, angles=None, method='GFN-FF', solvent="CH2Cl2",
            charge=0, title='temp', read_output=True, procs=None, **kwargs):
    '''
    This function writes an XTB .inp file, runs it with the subprocess
    module and reads its output.

    coords: array of shape (n,3) with cartesian coordinates for atoms.
    atomnos: array of atomic numbers for atoms.
    constrained_indices: array of shape (n,2), with the indices
    of atomic pairs to be constrained.
    method: string, specifiyng the theory level to be used.
    title: string, used as a file name and job title for the mopac input file.
    read_output: Whether to read the output file and return anything.
    '''

    if constrained_distances is not None:
        for target_d, (a, b) in zip(constrained_distances, constrained_indices):
            d = norm_of(coords[b] - coords[a])
            delta = d - target_d

            if abs(delta) > 0.2:
                sign = (d > target_d)
                recursive_c_d = [d + 0.2 * sign for d in constrained_distances]

                coords, _, _ = xtb_opt(
                                        coords,
                                        atomnos,
                                        constrained_indices,
                                        constrained_distances=recursive_c_d,
                                        method=method,
                                        title=title,
                                        **kwargs,
                                    )

            d = norm_of(coords[b] - coords[a])
            delta = d - target_d
            coords[b] -= norm(coords[b] - coords[a]) * delta


    with open(f'{title}.xyz', 'w') as f:
        write_xyz(coords, atomnos, f, title=title)

    s = f'$opt\n   logfile={title}_opt.log\n$end'
        
    if constrained_indices is not None:
        s += '\n$constrain\n'
        for a, b in constrained_indices:
            s += '   distance: %s, %s, %s\n' % (a+1, b+1, round(norm_of(coords[a]-coords[b]), 5))

    if constrained_dihedrals is not None:
        assert len(constrained_dihedrals) == len(angles)
        s += '\n$constrain\n'
        for (a, b, c, d), angle in zip(constrained_dihedrals, angles):
            s += f"   dihedral: {a+1}, {b+1}, {c+1}, {d+1}, {angle}\n"  
    
    if method.upper() in ('GFN-XTB', 'GFNXTB'):
        s += '\n$gfn\n   method=1\n'

    elif method.upper() in ('GFN2-XTB', 'GFN2XTB'):
        s += '\n$gfn\n   method=2\n'
    
    s += '\n$end'

    s = ''.join(s)
    with open(f'{title}.inp', 'w') as f:
        f.write(s)
    
    flags = '--opt'
    
    if method in ('GFN-FF', 'GFNFF'):
        flags += ' tight'
        # tighter convergence for GFN-FF works better

        flags += ' --gfnff'
        # declaring the use of FF instead of semiempirical

    if charge != 0:
        flags += f' --chrg {charge}'

    if procs != None:
        flags += f' -P {procs}'

    if solvent is not None:

        if solvent == 'methanol':
            flags += f' --gbsa methanol'

        else:
            flags += f' --alpb {solvent}'

    elif method.upper() in ('GFN-FF', 'GFNFF'):
        flags += f' --alpb thf'
        # if using the GFN-FF force field, add THF solvation for increased accuracy

    try:
        check_call(f'xtb --input {title}.inp {title}.xyz {flags} > temp.log 2>&1'.split(), stdout=DEVNULL, stderr=STDOUT)

    except KeyboardInterrupt:
        print('KeyboardInterrupt requested by user. Quitting.')
        quit()

    # sometimes the SCC does not converge
    except CalledProcessError:
        return coords, None, False

    if read_output:

        try:
            outname = 'xtbopt.xyz'
            opt_coords = read_xyz(outname).atomcoords[0]
            energy = read_xtb_energy(outname)

            clean_directory((f'{title}.inp', f'{title}.xyz', f'{title}_opt.log'))
            os.remove(outname)

            for filename in ('gfnff_topo', 'gfnff_charges', 'charges', 'wbo', 'xtbrestart', 'xtbtopo.mol', '.xtboptok'):
                try:
                    os.remove(filename)
                except FileNotFoundError:
                    pass

            return opt_coords, energy, True

        except FileNotFoundError:
            return None, None, False